<html>
<head>
<title>Socio-PLT: Clustering Languages</title>
<script src="jquery.js"></script>
<script src="d3.v2.js"></script>
<script src="colorbrewer.js"></script>
<script src="main.js"></script>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27943864-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<link rel="stylesheet" type="text/css" href="main.css" />
<div id="loader"><span>loading...</span></div>
<link rel="stylesheet" type="text/css" href="grid.css" />
<link rel="stylesheet" type="text/css" href="kmeans.css" />
<script src="kmeans.js"></script>
<script>
$(function(){  $("#loader").fadeOut(1000); });
</script>
</head>
<body>

<h1><span><a href="index.html">Socio-PLT:</a></span> Clustering Languages</h1>

<div class="about">
<p><a href="index.html">What is Socio-PLT?</a> 
| <a href="http://www.youtube.com/watch?v=v2ITaI4y7_0">Video</a> 
| <a href="more.html">Further Resources</a>
| Created by <a href="http://www.eecs.berkeley.edu/~lmeyerov">Leo Meyerovich</a> and <a href="http://www.eecs.berkeley.edu/~asrabkin/">Ari Rabkin</a> (EECS @ Berkeley)</p></div>

<!-- <div class="toolbar survey">Contribute to science by filling out our <a href="survey.html">anonymous 2-page survey</a> about programming languages!</div> -->
<div class="toolbar"><span><b>Visualizations:</b> <a href="rank.html">Language/statement ranking</a> <a href="statementcorr.html">Statement correlation</a> <a href="languagecorr.html">Language correlation</a> <a href="statekmeans.html">Statement clustering</a> <a href="langkmeans.html">Language clustering</a></div>

<p>We split the 51 languages  into clusters based on perceived properties by  k-means clustering.  A language with a bright color and low distance number beside it is close to the center of its cluster. 

<p>Explore what happens when you change the number of clusters. Also, look for items that can or cannot be easily fit.


<div id="control"><a id="decreaseBig" href="#">decrease 5</a><a id="decrease" href="#">decrease</a><span id="k">k</span> <span>(avg distance: <span id="dist">0</span>)</span>
 <a id="increase" href="#">increase</a><a id="increaseBig" href="#">increase 5</a></div>


<div style="display: inline-block">
<div id="active" style="float: left; width: 70%"></div>
<div id="activeSupport" style="float: left; left: 70%; position: fixed; margin-top: 1em"></div>
</div>

<div id="data">


k-means with k = 2
<tabled class="data" id="clusters2">
  <trd>
    <tdd>TCL,7.0</tdd>
    <tdd>R,7.0</tdd>
    <tdd>Delphi,7.0</tdd>
    <tdd>Matlab,7.0</tdd>
    <tdd>ELisp,8.0</tdd>
    <tdd>Fortran,8.0</tdd>
    <tdd>Javascript,8.0</tdd>
    <tdd>Objective C,8.0</tdd>
    <tdd>Shell,8.0</tdd>
    <tdd>Pascal,8.0</tdd>
    <tdd>Ada,9.0</tdd>
    <tdd>Perl,9.0</tdd>
    <tdd>PHP,9.0</tdd>
    <tdd>AWK,9.0</tdd>
    <tdd>Mathematica,9.0</tdd>
    <tdd>Forth,10.0</tdd>
    <tdd>APL,10.0</tdd>
    <tdd>Prolog,10.0</tdd>
    <tdd>Visual Basic,10.0</tdd>
    <tdd>C++,12.0</tdd>
    <tdd>Cobol,12.0</tdd>
    <tdd>ActionScript,12.0</tdd>
    <tdd>Java,14.0</tdd>
    <tdd>C,15.0</tdd>
    <tdd>Assembler,16.0</tdd>
  </trd>
  <trd>
    <tdd>O'Caml,6.0</tdd>
    <tdd>Go,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>D,7.0</tdd>
    <tdd>F#,7.0</tdd>
    <tdd>Lua,7.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Clojure,7.0</tdd>
    <tdd>Groovy,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
    <tdd>Factor,8.0</tdd>
    <tdd>Scheme,8.0</tdd>
    <tdd>Io,8.0</tdd>
    <tdd>Mozart-Oz,8.0</tdd>
    <tdd>Erlang,9.0</tdd>
    <tdd>J,9.0</tdd>
    <tdd>Scala,9.0</tdd>
    <tdd>Eiffel,9.0</tdd>
    <tdd>Haskell,10.0</tdd>
    <tdd>Ruby,10.0</tdd>
    <tdd>Python,11.0</tdd>
    <tdd>C#,12.0</tdd>
    <tdd>Coq,12.0</tdd>
    <tdd>REBOL,13.0</tdd>
    <tdd>Agda,15.0</tdd>
  </trd>
</tabled>
<div class="support" id="support2">
<ul>
<li class="supNeg">23 (8%) This language excels at concurrency</li>
</ul>
<ul>
<li>30 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supPos">80 (9%) This is a high level language</li>
</ul>
</div>
k-means with k = 3
<tabled class="data" id="clusters3">
  <trd>
    <tdd>C#,7.0</tdd>
    <tdd>Javascript,7.0</tdd>
    <tdd>Objective C,7.0</tdd>
    <tdd>Groovy,8.0</tdd>
    <tdd>Java,9.0</tdd>
    <tdd>Perl,9.0</tdd>
    <tdd>Ruby,9.0</tdd>
    <tdd>Python,10.0</tdd>
    <tdd>C++,11.0</tdd>
    <tdd>C,12.0</tdd>
  </trd>
  <trd>
    <tdd>TCL,6.0</tdd>
    <tdd>Delphi,7.0</tdd>
    <tdd>Matlab,7.0</tdd>
    <tdd>Pascal,7.0</tdd>
    <tdd>ELisp,8.0</tdd>
    <tdd>Fortran,8.0</tdd>
    <tdd>AWK,8.0</tdd>
    <tdd>Prolog,8.0</tdd>
    <tdd>R,8.0</tdd>
    <tdd>APL,9.0</tdd>
    <tdd>Visual Basic,9.0</tdd>
    <tdd>Shell,9.0</tdd>
    <tdd>Mathematica,9.0</tdd>
    <tdd>Ada,10.0</tdd>
    <tdd>Forth,10.0</tdd>
    <tdd>PHP,10.0</tdd>
    <tdd>Cobol,11.0</tdd>
    <tdd>ActionScript,12.0</tdd>
    <tdd>Assembler,15.0</tdd>
  </trd>
  <trd>
    <tdd>O'Caml,6.0</tdd>
    <tdd>Go,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>D,7.0</tdd>
    <tdd>F#,7.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Clojure,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Erlang,8.0</tdd>
    <tdd>Factor,8.0</tdd>
    <tdd>Lua,8.0</tdd>
    <tdd>Scheme,8.0</tdd>
    <tdd>Io,8.0</tdd>
    <tdd>Haxe,8.0</tdd>
    <tdd>Mozart-Oz,8.0</tdd>
    <tdd>J,9.0</tdd>
    <tdd>Eiffel,9.0</tdd>
    <tdd>Haskell,10.0</tdd>
    <tdd>Scala,10.0</tdd>
    <tdd>Coq,12.0</tdd>
    <tdd>REBOL,12.0</tdd>
    <tdd>Agda,15.0</tdd>
  </trd>
</tabled>
<div class="support" id="support3">
<ul>
<li>36 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>44 (5%) I would like to write more of this language than I currently do</li>
<li>27 (6%) This language excels at concurrency</li>
<li>51 (9%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>38 (9%) Learning this language significantly changed how I use other languages.</li>
<li>32 (9%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">23 (9%) When I write code in this language I can be very sure it is correct</li>
<li>56 (9%) I can imagine this will be a popular language in twenty years time</li>
</ul>
<ul>
<li class="supNeg">15 (8%) This language is good for distributed computing</li>
<li class="supNeg">23 (9%) This language excels at concurrency</li>
</ul>
<ul>
<li>30 (9%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
</ul>
</div>
k-means with k = 4
<tabled class="data" id="clusters4">
  <trd>
    <tdd>Delphi,6.0</tdd>
    <tdd>Fortran,7.0</tdd>
    <tdd>TCL,7.0</tdd>
    <tdd>Pascal,7.0</tdd>
    <tdd>AWK,8.0</tdd>
    <tdd>Visual Basic,8.0</tdd>
    <tdd>Shell,8.0</tdd>
    <tdd>Matlab,8.0</tdd>
    <tdd>PHP,9.0</tdd>
    <tdd>Cobol,10.0</tdd>
    <tdd>ActionScript,11.0</tdd>
    <tdd>Assembler,15.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,7.0</tdd>
    <tdd>Prolog,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Go,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>D,8.0</tdd>
    <tdd>J,8.0</tdd>
    <tdd>R,8.0</tdd>
    <tdd>Eiffel,8.0</tdd>
    <tdd>Io,8.0</tdd>
    <tdd>Mathematica,8.0</tdd>
    <tdd>Ada,9.0</tdd>
    <tdd>ELisp,9.0</tdd>
    <tdd>Erlang,9.0</tdd>
    <tdd>APL,9.0</tdd>
    <tdd>Forth,10.0</tdd>
    <tdd>Coq,10.0</tdd>
    <tdd>Agda,15.0</tdd>
  </trd>
  <trd>
    <tdd>C#,7.0</tdd>
    <tdd>Objective C,7.0</tdd>
    <tdd>C++,8.0</tdd>
    <tdd>Java,8.0</tdd>
    <tdd>Javascript,8.0</tdd>
    <tdd>Perl,9.0</tdd>
    <tdd>C,11.0</tdd>
  </trd>
  <trd>
    <tdd>Clojure,5.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>F#,7.0</tdd>
    <tdd>Lua,7.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Groovy,7.0</tdd>
    <tdd>O'Caml,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
    <tdd>Ruby,8.0</tdd>
    <tdd>Scala,8.0</tdd>
    <tdd>Scheme,8.0</tdd>
    <tdd>Haskell,9.0</tdd>
    <tdd>Python,9.0</tdd>
    <tdd>REBOL,13.0</tdd>
  </trd>
</tabled>
<div class="support" id="support4">
<ul>
<li>35 (6%) This language has a very dogmatic community</li>
<li class="supNeg">12 (7%) This language is good for distributed computing</li>
<li class="supNeg">19 (8%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">16 (8%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">14 (8%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">17 (9%) I can imagine using this language in my day job</li>
<li class="supNeg">16 (9%) I would use this language for writing server programs</li>
<li class="supNeg">15 (9%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">11 (9%) I enjoy using this language</li>
<li>25 (9%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
</ul>
<ul>
<li>65 (9%) I use this language out of choice</li>
</ul>
<ul>
<li>35 (3%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>42 (4%) I would like to write more of this language than I currently do</li>
<li>26 (5%) This language excels at concurrency</li>
<li>53 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>55 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>35 (8%) I find code written in this language very elegant</li>
<li>35 (8%) Learning this language significantly changed how I use other languages.</li>
<li>55 (8%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">21 (9%) When I write code in this language I can be very sure it is correct</li>
<li>47 (9%) This language is likely to have a strong influence on future languages</li>
<li>34 (9%) This language has unusual features that I often miss when using other languages</li>
<li>41 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>62 (9%) This is a high level language</li>
<li>45 (9%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>47 (9%) Code written in this language is very readable</li>
</ul>
<ul>
<li class="supNeg">22 (4%) This is a low level language</li>
<li class="supPos">86 (7%) I find this language easy to prototype in</li>
<li class="supPos">84 (7%) This is a high level language</li>
<li>28 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">18 (8%) Writing code in this language is a lot of work</li>
<li class="supNeg">19 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li>38 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>38 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
</ul>
</div>
k-means with k = 5
<tabled class="data" id="clusters5">
  <trd>
    <tdd>Clojure,5.0</tdd>
    <tdd>F#,6.0</tdd>
    <tdd>O'Caml,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Go,7.0</tdd>
    <tdd>Lua,8.0</tdd>
    <tdd>Ruby,8.0</tdd>
    <tdd>Scala,8.0</tdd>
    <tdd>Scheme,8.0</tdd>
    <tdd>Haxe,8.0</tdd>
    <tdd>Erlang,9.0</tdd>
    <tdd>Haskell,9.0</tdd>
    <tdd>Python,9.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,7.0</tdd>
    <tdd>Prolog,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>J,8.0</tdd>
    <tdd>APL,8.0</tdd>
    <tdd>Io,8.0</tdd>
    <tdd>Mozart-Oz,8.0</tdd>
    <tdd>Forth,9.0</tdd>
    <tdd>Mathematica,9.0</tdd>
    <tdd>Coq,10.0</tdd>
    <tdd>REBOL,12.0</tdd>
    <tdd>Agda,14.0</tdd>
  </trd>
  <trd>
    <tdd>TCL,6.0</tdd>
    <tdd>R,6.0</tdd>
    <tdd>ELisp,7.0</tdd>
    <tdd>Javascript,7.0</tdd>
    <tdd>Groovy,7.0</tdd>
    <tdd>Shell,7.0</tdd>
    <tdd>Matlab,7.0</tdd>
    <tdd>Perl,8.0</tdd>
    <tdd>PHP,8.0</tdd>
    <tdd>AWK,8.0</tdd>
    <tdd>ActionScript,11.0</tdd>
  </trd>
  <trd>
    <tdd>C#,7.0</tdd>
    <tdd>Java,7.0</tdd>
    <tdd>C++,8.0</tdd>
    <tdd>C,10.0</tdd>
  </trd>
  <trd>
    <tdd>Delphi,5.0</tdd>
    <tdd>Fortran,6.0</tdd>
    <tdd>Pascal,6.0</tdd>
    <tdd>Ada,7.0</tdd>
    <tdd>Objective C,8.0</tdd>
    <tdd>D,9.0</tdd>
    <tdd>Visual Basic,9.0</tdd>
    <tdd>Eiffel,9.0</tdd>
    <tdd>Cobol,10.0</tdd>
    <tdd>Assembler,15.0</tdd>
  </trd>
</tabled>
<div class="support" id="support5">
<ul>
<li>34 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">85 (7%) I find this language easy to prototype in</li>
<li>42 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>30 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>31 (8%) This language makes it easy to shoot yourself in the foot</li>
<li>25 (8%) This is a low level language</li>
<li class="supPos">83 (8%) This is a high level language</li>
<li class="supNeg">18 (8%) There is a lot of accidental complexity when writing code in this language</li>
<li>25 (9%) I often get angry when writing code in this language</li>
<li class="supNeg">20 (9%) Writing code in this language is a lot of work</li>
<li class="supPos">86 (9%) This language encourages writing reusable code.</li>
<li>48 (9%) There are many good commercial tools for this language</li>
<li>49 (9%) Code written in this language tends to be terse</li>
<li>72 (9%) This language has a high quality implementation</li>
</ul>
<ul>
<li class="supNeg">17 (4%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">24 (7%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">13 (8%) I can imagine using this language in my day job</li>
<li>28 (9%) This language excels at concurrency</li>
<li>47 (9%) Code written in this language is very readable</li>
<li>70 (9%) I find this language easy to prototype in</li>
<li>25 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
</ul>
<ul>
<li class="supNeg">22 (5%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>29 (5%) This is a low level language</li>
<li class="supNeg">21 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">16 (6%) When I write code in this language I can be very sure it is correct</li>
<li>32 (7%) Writing code in this language is a lot of work</li>
<li>28 (7%) I can imagine using this language in my day job</li>
<li>45 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>40 (8%) Code written in this language tends to be terse</li>
<li class="supNeg">22 (8%) This language excels at concurrency</li>
<li>46 (8%) I usually use this language on solo projects</li>
<li class="supNeg">16 (8%) This language has a strong static type system</li>
<li>39 (9%) This language has a very dogmatic community</li>
<li>74 (9%) This is a high level language</li>
<li>49 (9%) Code written in this language is very readable</li>
<li>47 (9%) I find it easy to write efficient code in this language</li>
<li>58 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">21 (9%) Programs written in this language tend to be efficient</li>
</ul>
<ul>
<li>54 (1%) I can imagine this will be a popular language in twenty years time</li>
<li>39 (3%) I would like to write more of this language than I currently do</li>
<li class="supNeg">4 (3%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">94 (3%) This language has a high quality implementation</li>
<li>60 (4%) This language has a strong static type system</li>
<li>34 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">94 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supPos">91 (5%) This is a mainstream language</li>
<li class="supPos">83 (5%) The resources for learning this language are of high quality</li>
<li>28 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li>32 (5%) I find code written in this language very elegant</li>
<li class="supPos">91 (5%) There are many good commercial tools for this language</li>
<li>33 (6%) This language excels at symbolic manipulation</li>
<li>39 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>26 (7%) This language excels at concurrency</li>
<li class="supPos">91 (7%) I know many other people who use this language</li>
<li>55 (7%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supPos">75 (7%) I know this language well</li>
<li class="supPos">81 (7%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">91 (7%) I find it easy to write efficient code in this language</li>
<li>46 (7%) I would use this language for casual scripting</li>
<li>51 (8%) Code written in this language is very readable</li>
<li>61 (8%) This language is good for scientific computing</li>
<li class="supNeg">24 (8%) This language has a niche outside of which I would not use it</li>
<li>64 (8%) This language is good for numeric computing</li>
<li>26 (8%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">89 (8%) I use many applications written in this language</li>
<li>26 (8%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">23 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>57 (9%) This is a high level language</li>
<li>72 (9%) I would use this language to write a command-line app</li>
<li class="supPos">83 (9%) There are many good tools for this language</li>
<li class="supPos">82 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
</ul>
<ul>
<li>31 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">16 (8%) I would use this language as a scripting language embedded inside a larger application</li>
<li>45 (9%) This is a mainstream language</li>
<li class="supNeg">20 (9%) Code written in this language tends to be terse</li>
<li class="supNeg">22 (9%) There are many good open-source tools for this language</li>
</ul>
</div>
k-means with k = 6
<tabled class="data" id="clusters6">
  <trd>
    <tdd>REBOL,0.0</tdd>
  </trd>
  <trd>
    <tdd>ELisp,6.0</tdd>
    <tdd>TCL,6.0</tdd>
    <tdd>R,6.0</tdd>
    <tdd>Matlab,6.0</tdd>
    <tdd>AWK,7.0</tdd>
    <tdd>Prolog,7.0</tdd>
    <tdd>Mathematica,7.0</tdd>
    <tdd>APL,8.0</tdd>
    <tdd>Shell,8.0</tdd>
  </trd>
  <trd>
    <tdd>C#,7.0</tdd>
    <tdd>Objective C,7.0</tdd>
    <tdd>C++,8.0</tdd>
    <tdd>Java,8.0</tdd>
    <tdd>Javascript,8.0</tdd>
    <tdd>Perl,9.0</tdd>
    <tdd>C,11.0</tdd>
  </trd>
  <trd>
    <tdd>F#,6.0</tdd>
    <tdd>Clojure,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Groovy,7.0</tdd>
    <tdd>O'Caml,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
    <tdd>Lua,8.0</tdd>
    <tdd>Ruby,8.0</tdd>
    <tdd>Scala,8.0</tdd>
    <tdd>Scheme,8.0</tdd>
    <tdd>Haskell,9.0</tdd>
    <tdd>Python,9.0</tdd>
  </trd>
  <trd>
    <tdd>Delphi,6.0</tdd>
    <tdd>Pascal,6.0</tdd>
    <tdd>Fortran,7.0</tdd>
    <tdd>Visual Basic,7.0</tdd>
    <tdd>PHP,9.0</tdd>
    <tdd>Cobol,9.0</tdd>
    <tdd>ActionScript,12.0</tdd>
    <tdd>Assembler,14.0</tdd>
  </trd>
  <trd>
    <tdd>Standard ML,6.0</tdd>
    <tdd>Go,6.0</tdd>
    <tdd>D,7.0</tdd>
    <tdd>Factor,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>J,8.0</tdd>
    <tdd>Eiffel,8.0</tdd>
    <tdd>Io,8.0</tdd>
    <tdd>Ada,9.0</tdd>
    <tdd>Erlang,9.0</tdd>
    <tdd>Forth,10.0</tdd>
    <tdd>Coq,10.0</tdd>
    <tdd>Agda,14.0</tdd>
  </trd>
</tabled>
<div class="support" id="support6">
<ul></ul>
<ul>
<li>26 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>57 (6%) I use this language out of choice</li>
<li class="supNeg">13 (6%) This language is good for distributed computing</li>
<li>74 (6%) I find this language easy to prototype in</li>
<li>41 (6%) I am reluctant to admit to knowing this language</li>
<li>53 (6%) This language is unusually bad for beginners</li>
<li>32 (7%) Writing code in this language is a lot of work</li>
<li>26 (7%) This language is suitable for real-time applications</li>
<li>47 (7%) Code written in this language is very readable</li>
<li>40 (7%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">16 (7%) This language has a strong static type system</li>
<li class="supNeg">11 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">23 (7%) This is a low level language</li>
<li>32 (7%) Code written in this language tends to be very reliable</li>
<li>50 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">20 (8%) This language excels at concurrency</li>
<li>49 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">85 (8%) This language has a niche outside of which I would not use it</li>
<li>50 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">14 (8%) This language is best for very large projects</li>
<li class="supNeg">20 (8%) When I write code in this language I can be very sure it is correct</li>
<li>52 (8%) I often get angry when writing code in this language</li>
<li class="supNeg">17 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>34 (8%) This language has unusual features that I often miss when using other languages</li>
<li>32 (9%) This language is good for beginners</li>
<li>57 (9%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">22 (9%) I would use this language for mobile applications</li>
<li>46 (9%) I find it easy to write efficient code in this language</li>
<li>40 (9%) This language has a very dogmatic community</li>
<li>29 (9%) I would use this language for a web project</li>
<li>30 (9%) This language is likely to have a strong influence on future languages</li>
<li>54 (9%) This language has a high quality implementation</li>
</ul>
<ul>
<li>35 (3%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>42 (4%) I would like to write more of this language than I currently do</li>
<li>26 (5%) This language excels at concurrency</li>
<li>53 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>55 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>35 (8%) I find code written in this language very elegant</li>
<li>35 (8%) Learning this language significantly changed how I use other languages.</li>
<li>55 (8%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">21 (9%) When I write code in this language I can be very sure it is correct</li>
<li>47 (9%) This language is likely to have a strong influence on future languages</li>
<li>34 (9%) This language has unusual features that I often miss when using other languages</li>
<li>41 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>62 (9%) This is a high level language</li>
<li>45 (9%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>47 (9%) Code written in this language is very readable</li>
</ul>
<ul>
<li class="supNeg">22 (4%) This is a low level language</li>
<li class="supPos">88 (5%) I find this language easy to prototype in</li>
<li>40 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">85 (6%) This is a high level language</li>
<li>29 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>31 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">18 (8%) Writing code in this language is a lot of work</li>
<li>50 (9%) There are many good commercial tools for this language</li>
<li>38 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>49 (9%) Code written in this language tends to be terse</li>
<li class="supNeg">19 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li>50 (9%) This language is suitable for real-time applications</li>
</ul>
<ul>
<li class="supNeg">5 (5%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">11 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>37 (6%) This language has a very dogmatic community</li>
<li class="supNeg">9 (6%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">12 (7%) This language is good for distributed computing</li>
<li>31 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">24 (9%) This language excels at concurrency</li>
<li class="supNeg">16 (9%) This language excels at symbolic manipulation</li>
<li class="supNeg">14 (9%) I can imagine using this language in my day job</li>
<li>47 (9%) The resources for learning this language are of high quality</li>
<li class="supNeg">15 (9%) I would use this language for writing server programs</li>
<li class="supNeg">17 (9%) This language is likely to have a strong influence on future languages</li>
</ul>
<ul>
<li>26 (7%) There is a wide variety of open source code written in this language</li>
<li>33 (7%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>40 (8%) I would use this language for mobile applications</li>
<li class="supNeg">18 (8%) I know many other people who use this language</li>
<li>67 (9%) I use this language out of choice</li>
<li>42 (9%) I enjoy using this language</li>
</ul>
</div>
k-means with k = 7
<tabled class="data" id="clusters7">
  <trd>
    <tdd>Go,5.0</tdd>
    <tdd>D,6.0</tdd>
    <tdd>Lua,7.0</tdd>
    <tdd>Groovy,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>Objective C,8.0</tdd>
    <tdd>Eiffel,8.0</tdd>
    <tdd>Io,8.0</tdd>
    <tdd>Ada,9.0</tdd>
    <tdd>REBOL,13.0</tdd>
  </trd>
  <trd>
    <tdd>Fortran,5.0</tdd>
    <tdd>Pascal,6.0</tdd>
    <tdd>Delphi,7.0</tdd>
    <tdd>Cobol,8.0</tdd>
    <tdd>Visual Basic,8.0</tdd>
    <tdd>Assembler,13.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,8.0</tdd>
    <tdd>Agda,8.0</tdd>
    <tdd>Haskell,9.0</tdd>
  </trd>
  <trd>
    <tdd>APL,6.0</tdd>
    <tdd>Prolog,6.0</tdd>
    <tdd>Factor,7.0</tdd>
    <tdd>J,7.0</tdd>
    <tdd>Forth,8.0</tdd>
    <tdd>Mathematica,8.0</tdd>
  </trd>
  <trd>
    <tdd>TCL,6.0</tdd>
    <tdd>ELisp,7.0</tdd>
    <tdd>Javascript,7.0</tdd>
    <tdd>R,7.0</tdd>
    <tdd>Shell,7.0</tdd>
    <tdd>Matlab,7.0</tdd>
    <tdd>Perl,8.0</tdd>
    <tdd>PHP,8.0</tdd>
    <tdd>AWK,8.0</tdd>
    <tdd>ActionScript,11.0</tdd>
  </trd>
  <trd>
    <tdd>C#,6.0</tdd>
    <tdd>Java,7.0</tdd>
    <tdd>Python,9.0</tdd>
    <tdd>Ruby,10.0</tdd>
    <tdd>C,11.0</tdd>
    <tdd>C++,11.0</tdd>
  </trd>
  <trd>
    <tdd>O'Caml,5.0</tdd>
    <tdd>Common Lisp,6.0</tdd>
    <tdd>F#,6.0</tdd>
    <tdd>Clojure,6.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Erlang,8.0</tdd>
    <tdd>Scala,8.0</tdd>
    <tdd>Scheme,8.0</tdd>
  </trd>
</tabled>
<div class="support" id="support7">
<ul>
<li>42 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>66 (7%) I use this language out of choice</li>
<li>70 (8%) This is a high level language</li>
<li>27 (8%) I often feel like I am not smart enough to write this language</li>
<li>47 (9%) This language is likely to have a strong influence on future languages</li>
<li>28 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>37 (9%) I am reluctant to admit to knowing this language</li>
<li>59 (9%) This language is expressive</li>
</ul>
<ul>
<li class="supNeg">11 (3%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">12 (4%) I would use this language for writing server programs</li>
<li class="supNeg">6 (5%) I still discover new features of this language on a fairly regular basis</li>
<li>36 (6%) This language has a very dogmatic community</li>
<li class="supNeg">17 (6%) This language excels at symbolic manipulation</li>
<li>28 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">10 (6%) I can imagine using this language in my day job</li>
<li>47 (6%) This is a mainstream language</li>
<li class="supNeg">10 (7%) This language has unusual features that I often miss when using other languages</li>
<li>35 (7%) I use many applications written in this language</li>
<li class="supNeg">12 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li>58 (7%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">10 (7%) I enjoy using this language</li>
<li class="supNeg">12 (8%) This language is good for distributed computing</li>
<li class="supPos">81 (8%) I learned this language early in my career as a programmer</li>
<li class="supNeg">16 (9%) I usually use this language on solo projects</li>
</ul>
<ul>
<li class="supNeg">20 (1%) I would use this language for writing programs for an embedded hardware platform</li>
<li>37 (1%) I would use this language for writing embedded programs</li>
<li class="supPos">95 (3%) Learning this language improved my ability as a programmer</li>
<li class="supPos">80 (3%) This language has a very coherent design</li>
<li>71 (3%) The semantics of this language are much different than other languages I know.</li>
<li>40 (3%) This language is well documented</li>
<li class="supPos">95 (3%) This language has a strong static type system</li>
<li class="supPos">85 (3%) I use this language out of choice</li>
<li>55 (4%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">94 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supPos">93 (4%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">24 (5%) I can imagine using this language in my day job</li>
<li class="supPos">93 (6%) This is a high level language</li>
<li>25 (6%) This language excels at concurrency</li>
<li>57 (6%) Code written in this language is very readable</li>
<li class="supNeg">9 (6%) This is a low level language</li>
<li class="supNeg">19 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">11 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>67 (8%) This language excels at symbolic manipulation</li>
<li>62 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supPos">87 (8%) This language is expressive</li>
<li>59 (8%) I enjoy using this language</li>
<li class="supPos">88 (8%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>28 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>39 (9%) This language is large</li>
<li>38 (9%) I would use this language for mobile applications</li>
<li class="supPos">86 (9%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">90 (9%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">13 (9%) I often get angry when writing code in this language</li>
</ul>
<ul>
<li>62 (2%) This language is unusually bad for beginners</li>
<li>45 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>26 (4%) I would use this language for a web project</li>
<li>49 (4%) I often get angry when writing code in this language</li>
<li>35 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">18 (4%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">22 (4%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">7 (5%) I can imagine using this language in my day job</li>
<li>39 (5%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">20 (6%) This language is good for distributed computing</li>
<li>36 (6%) Writing code in this language is a lot of work</li>
<li>27 (7%) This language excels at concurrency</li>
<li>38 (7%) This language has many features which feel "tacked on"</li>
<li class="supNeg">21 (7%) It is easy to debug programs written in this language when it goes wrong</li>
<li>50 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>60 (8%) I use this language out of choice</li>
<li>46 (8%) I would like to write more of this language than I currently do</li>
<li>32 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>41 (8%) This language has a very dogmatic community</li>
<li>43 (8%) Code written in this language is very readable</li>
<li>37 (8%) This language is likely to be around for a very long time</li>
<li class="supPos">86 (8%) I enjoy playing with this language but would never use it for "real code"</li>
<li>35 (8%) I enjoy using this language</li>
<li>67 (9%) This language has a very coherent design</li>
<li>52 (9%) This language has an annoying syntax</li>
<li>25 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>27 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>30 (9%) There are many good tools for this language</li>
<li class="supNeg">24 (9%) When I write code in this language I can be very sure it is correct</li>
<li>40 (9%) This language has a very rigid idea of how things should be done</li>
<li>52 (9%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">21 (9%) This language has a strong static type system</li>
<li>36 (9%) I would use this language as a scripting language embedded inside a larger application</li>
</ul>
<ul>
<li class="supNeg">21 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>29 (5%) This is a low level language</li>
<li class="supNeg">21 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>26 (6%) I can imagine using this language in my day job</li>
<li class="supNeg">16 (7%) When I write code in this language I can be very sure it is correct</li>
<li>33 (7%) Writing code in this language is a lot of work</li>
<li class="supNeg">14 (7%) This language is good for distributed computing</li>
<li class="supNeg">15 (7%) This language has a strong static type system</li>
<li class="supNeg">20 (8%) This language excels at concurrency</li>
<li>56 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li>45 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>45 (8%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>45 (8%) I usually use this language on solo projects</li>
<li>48 (8%) Code written in this language is very readable</li>
<li>40 (8%) Code written in this language tends to be terse</li>
<li>39 (9%) This language has a very dogmatic community</li>
<li class="supPos">77 (9%) I find this language easy to prototype in</li>
<li>73 (9%) This is a high level language</li>
<li class="supNeg">20 (9%) Programs written in this language tend to be efficient</li>
<li>47 (9%) I find it easy to write efficient code in this language</li>
</ul>
<ul>
<li>34 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>43 (6%) I would like to write more of this language than I currently do</li>
<li>74 (6%) I know this language well</li>
<li>26 (7%) This language excels at concurrency</li>
<li class="supPos">87 (7%) The resources for learning this language are of high quality</li>
<li>28 (8%) When I write code in this language I can be very sure it is correct</li>
<li>36 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>59 (9%) I can imagine this will be a popular language in twenty years time</li>
<li class="supPos">85 (9%) This is a mainstream language</li>
</ul>
<ul>
<li>35 (3%) I would use this language for writing programs for an embedded hardware platform</li>
<li>30 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supPos">85 (4%) This is a high level language</li>
<li class="supNeg">22 (4%) This is a low level language</li>
<li>32 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>69 (5%) This language has a high quality implementation</li>
<li class="supPos">75 (6%) This language is likely to have a strong influence on future languages</li>
<li>29 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>51 (6%) Code written in this language tends to be terse</li>
<li>38 (7%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>36 (7%) I use many applications written in this language</li>
<li class="supPos">77 (7%) I find code written in this language very elegant</li>
<li class="supNeg">22 (7%) Writing code in this language is a lot of work</li>
<li class="supNeg">13 (7%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>49 (7%) I often feel like I am not smart enough to write this language</li>
<li>36 (8%) This is a mainstream language</li>
<li class="supPos">87 (8%) This language encourages writing reusable code.</li>
<li>38 (8%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">20 (8%) There is a lot of accidental complexity when writing code in this language</li>
<li>66 (8%) Code written in this language is very readable</li>
<li>39 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>69 (8%) This language has unusual features that I often miss when using other languages</li>
<li>57 (8%) The semantics of this language are much different than other languages I know.</li>
<li>36 (8%) I usually use this language on projects with many other members</li>
<li>72 (9%) This language encourages writing code that is easy to maintain.</li>
<li>27 (9%) I often get angry when writing code in this language</li>
<li>61 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>49 (9%) This language is likely to be around for a very long time</li>
<li>35 (9%) I know many other people who use this language</li>
<li>68 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li>39 (9%) There is a wide variety of open source code written in this language</li>
<li>48 (9%) This language excels at text processing</li>
<li>27 (9%) Code written in this language tends to be verbose</li>
<li class="supPos">78 (9%) This language has a very coherent design</li>
</ul>
</div>
k-means with k = 8
<tabled class="data" id="clusters8">
  <trd>
    <tdd>F#,6.0</tdd>
    <tdd>Scala,6.0</tdd>
    <tdd>Clojure,6.0</tdd>
    <tdd>Python,7.0</tdd>
    <tdd>Ruby,7.0</tdd>
    <tdd>Haskell,9.0</tdd>
    <tdd>C#,10.0</tdd>
  </trd>
  <trd>
    <tdd>Forth,0.0</tdd>
  </trd>
  <trd>
    <tdd>Javascript,6.0</tdd>
    <tdd>Objective C,7.0</tdd>
    <tdd>Perl,8.0</tdd>
    <tdd>PHP,8.0</tdd>
    <tdd>Shell,9.0</tdd>
    <tdd>C++,10.0</tdd>
    <tdd>Java,10.0</tdd>
    <tdd>C,12.0</tdd>
    <tdd>ActionScript,12.0</tdd>
  </trd>
  <trd>
    <tdd>Delphi,5.0</tdd>
    <tdd>Pascal,5.0</tdd>
    <tdd>Fortran,6.0</tdd>
    <tdd>Ada,8.0</tdd>
    <tdd>Cobol,8.0</tdd>
    <tdd>Visual Basic,8.0</tdd>
  </trd>
  <trd>
    <tdd>Assembler,0.0</tdd>
  </trd>
  <trd>
    <tdd>Go,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>D,7.0</tdd>
    <tdd>Factor,7.0</tdd>
    <tdd>Lua,7.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Groovy,7.0</tdd>
    <tdd>O'Caml,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Io,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>Scheme,8.0</tdd>
    <tdd>Erlang,9.0</tdd>
    <tdd>J,9.0</tdd>
    <tdd>Eiffel,9.0</tdd>
    <tdd>REBOL,12.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,7.0</tdd>
    <tdd>Agda,7.0</tdd>
  </trd>
  <trd>
    <tdd>ELisp,6.0</tdd>
    <tdd>R,6.0</tdd>
    <tdd>Matlab,6.0</tdd>
    <tdd>Prolog,7.0</tdd>
    <tdd>TCL,7.0</tdd>
    <tdd>Mathematica,7.0</tdd>
    <tdd>APL,8.0</tdd>
    <tdd>AWK,8.0</tdd>
  </trd>
</tabled>
<div class="support" id="support8">
<ul>
<li class="supPos">88 (5%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">89 (5%) I find this language easy to prototype in</li>
<li>39 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>30 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>69 (6%) Programs written in this language tend to play well with others</li>
<li>49 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">21 (7%) This is a low level language</li>
<li>26 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>32 (7%) I would use this language for writing embedded programs</li>
<li class="supPos">89 (8%) This language encourages writing reusable code.</li>
<li>52 (8%) I regularly use this language</li>
<li class="supPos">90 (8%) I use this language out of choice</li>
<li class="supPos">78 (8%) I would list this language on my resume</li>
<li>49 (9%) This language is suitable for real-time applications</li>
<li class="supPos">87 (9%) I would use this language to write a command-line app</li>
<li class="supNeg">16 (9%) Writing code in this language is a lot of work</li>
<li>26 (9%) I often get angry when writing code in this language</li>
<li>51 (9%) This language matches it's problem domain particularly well.</li>
<li class="supPos">86 (9%) This is a high level language</li>
</ul>
<ul></ul>
<ul>
<li class="supNeg">22 (3%) This language excels at concurrency</li>
<li>37 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>46 (9%) Code written in this language is very readable</li>
<li>42 (9%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supNeg">19 (9%) When I write code in this language I can be very sure it is correct</li>
</ul>
<ul>
<li>54 (4%) Code written in this language is very readable</li>
<li class="supNeg">13 (5%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">15 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li>40 (5%) There are many good tools for this language</li>
<li>28 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>55 (6%) I know this language well</li>
<li>44 (6%) This is a low level language</li>
<li>47 (7%) This is a mainstream language</li>
<li>34 (7%) I use many applications written in this language</li>
<li>52 (7%) It is easy to tell at a glance what code in this language does</li>
<li class="supNeg">9 (7%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">12 (7%) I usually use this language on solo projects</li>
<li class="supNeg">16 (7%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">21 (8%) This language excels at symbolic manipulation</li>
<li class="supNeg">12 (8%) I can imagine using this language in my day job</li>
<li>26 (9%) The semantics of this language are much different than other languages I know.</li>
<li>58 (9%) This is a high level language</li>
<li class="supNeg">16 (9%) This language is best for very small projects</li>
<li class="supNeg">18 (9%) There are many good open-source tools for this language</li>
<li class="supNeg">11 (9%) I enjoy using this language</li>
<li>31 (9%) I usually use this language on projects with many other members</li>
<li>28 (9%) I would use this language for casual scripting</li>
<li>59 (9%) This language has many features which feel "tacked on"</li>
<li>39 (9%) This language has a good library distribution mechanism.</li>
</ul>
<ul></ul>
<ul>
<li>68 (6%) I use this language out of choice</li>
<li class="supPos">76 (7%) This is a high level language</li>
<li>36 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>32 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>50 (9%) I would use this language for a desktop GUI project</li>
<li>37 (9%) Libraries in this language tend to be well documented.</li>
<li>26 (9%) Writing code in this language is a lot of work</li>
<li>58 (9%) This language has a good community</li>
</ul>
<ul>
<li>35 (0%) I would use this language for writing embedded programs</li>
<li class="supNeg">0 (0%) This is a mainstream language</li>
<li>69 (0%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">20 (0%) This language excels at concurrency</li>
<li class="supNeg">20 (1%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">21 (1%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">20 (1%) I can imagine using this language in my day job</li>
<li>52 (1%) Code written in this language is very readable</li>
<li>58 (1%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>68 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>61 (1%) This language excels at symbolic manipulation</li>
<li class="supPos">79 (1%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">97 (2%) Learning this language improved my ability as a programmer</li>
<li>47 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">83 (2%) I use this language out of choice</li>
<li>30 (2%) This language is best for very large projects</li>
<li class="supPos">97 (2%) I often feel like I am not smart enough to write this language</li>
<li>53 (2%) I enjoy using this language</li>
<li>54 (2%) Writing code in this language is a lot of work</li>
<li class="supNeg">15 (3%) This language is good for distributed computing</li>
<li class="supNeg">16 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">17 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">23 (3%) This language is good for numeric computing</li>
<li class="supPos">81 (3%) This language has a very coherent design</li>
<li>32 (3%) This language is large</li>
<li class="supPos">95 (4%) When I write code in this language I can be very sure it is correct</li>
<li>29 (4%) I regularly use this language</li>
<li class="supPos">95 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">4 (4%) Programs written in this language tend to be efficient</li>
<li>40 (4%) This language is well documented</li>
<li class="supPos">95 (4%) This language has a strong static type system</li>
<li class="supPos">82 (4%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>64 (4%) I would like to write more of this language than I currently do</li>
<li class="supNeg">15 (4%) Programs written in this language tend to play well with others</li>
<li class="supPos">94 (5%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">81 (5%) This language has a niche outside of which I would not use it</li>
<li class="supNeg">5 (5%) This is a low level language</li>
<li class="supNeg">5 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>58 (5%) This language is likely to be a passing fad</li>
<li>57 (5%) This language is good for scientific computing</li>
<li>39 (5%) This language has a good library distribution mechanism.</li>
<li>74 (5%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">89 (5%) This is a high level language</li>
<li class="supNeg">19 (5%) There are many good tools for this language</li>
<li>67 (6%) This language encourages writing reusable code.</li>
<li>58 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li>46 (6%) This language has an annoying syntax</li>
<li class="supNeg">8 (6%) I often get angry when writing code in this language</li>
<li class="supNeg">22 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">7 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">80 (8%) I find code written in this language very elegant</li>
<li class="supNeg">13 (8%) I use many applications written in this language</li>
<li>55 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>44 (8%) Code written in this language tends to be verbose</li>
<li class="supPos">84 (8%) This language is expressive</li>
<li class="supNeg">9 (9%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">24 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">22 (9%) Libraries in this language tend to be well documented.</li>
<li>49 (9%) I know this language well</li>
<li class="supNeg">10 (9%) I would use this language for writing server programs</li>
</ul>
<ul>
<li class="supPos">88 (4%) This language has a niche outside of which I would not use it</li>
<li>27 (5%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>49 (6%) Code written in this language is very readable</li>
<li>34 (6%) Code written in this language tends to be very reliable</li>
<li class="supNeg">18 (6%) This language has a strong static type system</li>
<li>46 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>54 (6%) This language is unusually bad for beginners</li>
<li class="supNeg">14 (6%) This language is good for distributed computing</li>
<li>41 (6%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>57 (6%) I use this language out of choice</li>
<li class="supPos">75 (6%) I find this language easy to prototype in</li>
<li>31 (7%) Writing code in this language is a lot of work</li>
<li>41 (7%) I am reluctant to admit to knowing this language</li>
<li>48 (7%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">16 (7%) This language is best for very large projects</li>
<li class="supPos">82 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">21 (7%) This is a low level language</li>
<li>27 (7%) This language is suitable for real-time applications</li>
<li>41 (7%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">10 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>43 (8%) I would like to write more of this language than I currently do</li>
<li>55 (8%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">21 (8%) When I write code in this language I can be very sure it is correct</li>
<li>35 (8%) This language has unusual features that I often miss when using other languages</li>
<li>49 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">20 (8%) This language excels at concurrency</li>
<li>45 (8%) This language encourages writing code that is easy to maintain.</li>
<li>50 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li>51 (9%) I often get angry when writing code in this language</li>
<li class="supNeg">17 (9%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>41 (9%) This language has a very dogmatic community</li>
<li>31 (9%) This language is likely to have a strong influence on future languages</li>
<li>32 (9%) This language is good for beginners</li>
<li class="supNeg">21 (9%) I would use this language for mobile applications</li>
<li>47 (9%) I find it easy to write efficient code in this language</li>
</ul>
</div>
k-means with k = 9
<tabled class="data" id="clusters9">
  <trd>
    <tdd>Python,4.0</tdd>
    <tdd>Ruby,4.0</tdd>
  </trd>
  <trd>
    <tdd>ELisp,6.0</tdd>
    <tdd>TCL,6.0</tdd>
    <tdd>Javascript,7.0</tdd>
    <tdd>AWK,7.0</tdd>
    <tdd>R,7.0</tdd>
    <tdd>Shell,7.0</tdd>
    <tdd>Perl,8.0</tdd>
    <tdd>ActionScript,11.0</tdd>
  </trd>
  <trd>
    <tdd>D,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Eiffel,7.0</tdd>
    <tdd>Go,7.0</tdd>
    <tdd>Ada,8.0</tdd>
    <tdd>Coq,9.0</tdd>
    <tdd>Agda,13.0</tdd>
  </trd>
  <trd>
    <tdd>Common Lisp,6.0</tdd>
    <tdd>Lua,6.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Groovy,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
    <tdd>J,8.0</tdd>
    <tdd>Scheme,8.0</tdd>
    <tdd>Mathematica,9.0</tdd>
  </trd>
  <trd>
    <tdd>C,9.0</tdd>
    <tdd>C++,9.0</tdd>
    <tdd>Assembler,12.0</tdd>
  </trd>
  <trd>
    <tdd>Visual Basic,6.0</tdd>
    <tdd>Delphi,6.0</tdd>
    <tdd>Pascal,6.0</tdd>
    <tdd>Fortran,7.0</tdd>
    <tdd>PHP,8.0</tdd>
    <tdd>Matlab,8.0</tdd>
    <tdd>Cobol,9.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,6.0</tdd>
    <tdd>Prolog,7.0</tdd>
    <tdd>Io,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>Forth,8.0</tdd>
    <tdd>APL,8.0</tdd>
    <tdd>REBOL,11.0</tdd>
  </trd>
  <trd>
    <tdd>C#,4.0</tdd>
    <tdd>Java,6.0</tdd>
    <tdd>Objective C,7.0</tdd>
  </trd>
  <trd>
    <tdd>F#,5.0</tdd>
    <tdd>Clojure,5.0</tdd>
    <tdd>O'Caml,5.0</tdd>
    <tdd>Scala,6.0</tdd>
    <tdd>Haskell,7.0</tdd>
    <tdd>Erlang,8.0</tdd>
  </trd>
</tabled>
<div class="support" id="support9">
<ul>
<li>36 (0%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supPos">78 (0%) This language is expressive</li>
<li>25 (0%) This language has an annoying syntax</li>
<li class="supPos">77 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>56 (0%) This language is large</li>
<li>60 (0%) There are many good commercial tools for this language</li>
<li>73 (0%) Learning this language improved my ability as a programmer</li>
<li class="supPos">78 (0%) This language encourages writing reusable code.</li>
<li>29 (0%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">83 (0%) This language is best for very small projects</li>
<li class="supNeg">21 (0%) This is a low level language</li>
<li class="supPos">88 (0%) This language would be good for teaching children to write software</li>
<li>68 (0%) I still discover new features of this language on a fairly regular basis</li>
<li>71 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>40 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>67 (1%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">87 (1%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>52 (2%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">21 (2%) I often feel like I am not smart enough to write this language</li>
<li>63 (2%) This language has a very dogmatic community</li>
<li class="supNeg">15 (2%) This language is unusually bad for beginners</li>
<li class="supPos">96 (2%) I would use this language to write a command-line app</li>
<li>52 (2%) I find it easy to write efficient code in this language</li>
<li>37 (2%) This language is good for distributed computing</li>
<li>43 (2%) Code written in this language tends to be very reliable</li>
<li>48 (2%) Code written in this language tends to be terse</li>
<li>67 (2%) I use many applications written in this language</li>
<li>28 (2%) This language has a niche in which it is great</li>
<li>59 (2%) This language excels at symbolic manipulation</li>
<li>64 (2%) I find code written in this language very elegant</li>
<li>33 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">75 (2%) Libraries in this language tend to be well documented.</li>
<li>71 (2%) I know this language well</li>
<li class="supPos">82 (2%) This language has a good community</li>
<li>61 (3%) This language is best for very large projects</li>
<li class="supPos">80 (3%) This language excels at text processing</li>
<li>62 (3%) This language has many features which feel "tacked on"</li>
<li class="supPos">75 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supPos">95 (3%) I find this language easy to prototype in</li>
<li>33 (3%) This language is built on a small core of orthogonal features</li>
<li>65 (3%) I usually use this language on solo projects</li>
<li>65 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>45 (3%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>51 (3%) I would like to write more of this language than I currently do</li>
<li class="supPos">96 (3%) This language has a good library distribution mechanism.</li>
<li class="supPos">84 (3%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>51 (3%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">14 (4%) This language has a strong static type system</li>
<li class="supPos">83 (4%) This is a high level language</li>
<li>73 (4%) I know many other people who use this language</li>
<li class="supNeg">4 (4%) Writing code in this language is a lot of work</li>
<li>63 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">76 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">88 (4%) There is a wide variety of open source code written in this language</li>
<li>28 (4%) I learned this language early in my career as a programmer</li>
<li>68 (4%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>73 (4%) This is a mainstream language</li>
<li>31 (4%) Code written in this language tends to be verbose</li>
<li class="supPos">94 (5%) The resources for learning this language are of high quality</li>
<li class="supPos">94 (5%) I would use this language for a web project</li>
<li>38 (5%) This language is suitable for real-time applications</li>
<li>62 (5%) I usually use this language on projects with many other members</li>
<li>27 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>46 (5%) I enjoy using this language</li>
<li>64 (5%) I would use this language for writing server programs</li>
<li class="supPos">94 (5%) I would use this language for casual scripting</li>
<li>64 (5%) It is easy to debug programs written in this language when it goes wrong</li>
<li>60 (6%) I regularly use this language</li>
<li>36 (6%) This language is minimal</li>
<li class="supPos">77 (6%) I would use this language for a desktop GUI project</li>
<li>70 (6%) Programs written in this language tend to play well with others</li>
<li>32 (6%) When I write code in this language I can be very sure it is correct</li>
<li>28 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>28 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>41 (7%) This language matches it's problem domain particularly well.</li>
<li class="supPos">92 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>44 (7%) Programs written in this language will usually work in future versions of the language</li>
<li class="supNeg">24 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">91 (7%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>27 (7%) This language excels at concurrency</li>
<li class="supPos">76 (7%) I would list this language on my resume</li>
<li class="supPos">82 (7%) There are many good open-source tools for this language</li>
<li>74 (7%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">91 (8%) I use this language out of choice</li>
<li class="supNeg">21 (8%) This language has a very rigid idea of how things should be done</li>
<li>27 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>40 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>28 (8%) I would use this language for writing embedded programs</li>
<li>29 (8%) I am reluctant to admit to knowing this language</li>
<li>51 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>67 (8%) I would use this language for mobile applications</li>
<li>63 (9%) This language has a very coherent design</li>
<li class="supPos">86 (9%) This language is well documented</li>
<li>66 (9%) There are many good tools for this language</li>
</ul>
<ul>
<li class="supNeg">20 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>29 (5%) This is a low level language</li>
<li class="supNeg">22 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>27 (6%) I can imagine using this language in my day job</li>
<li>58 (7%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">17 (7%) When I write code in this language I can be very sure it is correct</li>
<li>30 (7%) Learning this language significantly changed how I use other languages.</li>
<li>42 (7%) Code written in this language tends to be terse</li>
<li>33 (7%) Writing code in this language is a lot of work</li>
<li>42 (7%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">13 (7%) This language is good for distributed computing</li>
<li class="supNeg">14 (8%) This language has a strong static type system</li>
<li class="supNeg">20 (8%) This language excels at concurrency</li>
<li>55 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li>45 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>58 (8%) This language is likely to be around for a very long time</li>
<li>46 (9%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supNeg">20 (9%) Programs written in this language tend to be efficient</li>
<li>30 (9%) This language is good for beginners</li>
<li>47 (9%) Code written in this language is very readable</li>
<li>46 (9%) I usually use this language on solo projects</li>
<li class="supPos">77 (9%) I find this language easy to prototype in</li>
<li>53 (9%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>41 (9%) This language has a very dogmatic community</li>
<li class="supNeg">21 (9%) I enjoy using this language</li>
<li>51 (9%) The resources for learning this language are of high quality</li>
<li>29 (9%) This language has unusual features that I often miss when using other languages</li>
<li>74 (9%) This is a high level language</li>
<li>47 (9%) I would use this language as a scripting language embedded inside a larger application</li>
<li>33 (9%) This language has a very coherent design</li>
<li>53 (9%) This language makes it easy to shoot yourself in the foot</li>
</ul>
<ul>
<li>57 (5%) This language is good for scientific computing</li>
<li>26 (6%) There is a wide variety of open source code written in this language</li>
<li>43 (6%) This language has an annoying syntax</li>
<li>27 (6%) I can imagine using this language in my day job</li>
<li class="supNeg">24 (7%) I regularly use this language</li>
<li>32 (7%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">22 (7%) I know many other people who use this language</li>
<li>59 (8%) Code written in this language is very readable</li>
<li>32 (9%) This language is likely to be around for a very long time</li>
<li class="supPos">77 (9%) This language encourages writing reusable code.</li>
<li>28 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">23 (9%) I use many applications written in this language</li>
<li>30 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>41 (9%) I would use this language for mobile applications</li>
</ul>
<ul>
<li class="supPos">85 (4%) I find this language easy to prototype in</li>
<li>26 (5%) When I write code in this language I can be very sure it is correct</li>
<li>38 (5%) I use many applications written in this language</li>
<li>29 (6%) This language excels at concurrency</li>
<li class="supPos">82 (6%) This is a high level language</li>
<li class="supNeg">22 (6%) This is a low level language</li>
<li>68 (7%) I use this language out of choice</li>
<li>40 (7%) Programs written in this language tend to be efficient</li>
<li>43 (7%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>58 (7%) This language has a good community</li>
<li>37 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>26 (7%) This language is good for distributed computing</li>
<li>37 (8%) This is a mainstream language</li>
<li>46 (8%) I usually use this language on solo projects</li>
<li class="supNeg">24 (8%) Writing code in this language is a lot of work</li>
<li>38 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>37 (8%) I know many other people who use this language</li>
<li>44 (8%) Libraries in this language tend to be well documented.</li>
<li>44 (9%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>53 (9%) I would use this language for a desktop GUI project</li>
<li>50 (9%) There are many good commercial tools for this language</li>
<li class="supNeg">24 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>40 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>65 (9%) Code written in this language is very readable</li>
</ul>
<ul>
<li>37 (2%) I would like to write more of this language than I currently do</li>
<li>38 (3%) This language has a very coherent design</li>
<li class="supPos">96 (3%) This language is suitable for real-time applications</li>
<li>50 (4%) I often feel like I am not smart enough to write this language</li>
<li class="supPos">95 (4%) I find it easy to write efficient code in this language</li>
<li>63 (5%) Code written in this language tends to be verbose</li>
<li class="supPos">91 (6%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">22 (6%) I enjoy using this language</li>
<li>43 (6%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">81 (6%) I learned this language early in my career as a programmer</li>
<li>60 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>31 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">12 (6%) I am reluctant to admit to knowing this language</li>
<li>60 (6%) I often get angry when writing code in this language</li>
<li>25 (6%) This language excels at concurrency</li>
<li>38 (7%) This language has a very dogmatic community</li>
<li class="supPos">89 (7%) Programs written in this language tend to be efficient</li>
<li>34 (7%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">23 (8%) I find code written in this language very elegant</li>
<li class="supNeg">12 (8%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">22 (9%) This language excels at symbolic manipulation</li>
<li class="supNeg">12 (9%) I often write things in this language with the intent of rewriting them in something else later</li>
</ul>
<ul>
<li>54 (3%) Code written in this language is very readable</li>
<li>37 (5%) This language has a very dogmatic community</li>
<li class="supNeg">7 (6%) I enjoy using this language</li>
<li>52 (6%) It is easy to tell at a glance what code in this language does</li>
<li>32 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supNeg">15 (7%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">16 (7%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">15 (7%) This language is good for distributed computing</li>
<li>43 (7%) There are many good tools for this language</li>
<li>49 (8%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">20 (8%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">15 (8%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">19 (8%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">13 (8%) I can imagine using this language in my day job</li>
<li>31 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>50 (8%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">23 (8%) This language excels at concurrency</li>
<li>55 (9%) I know this language well</li>
<li class="supNeg">10 (9%) This language has unusual features that I often miss when using other languages</li>
<li>48 (9%) This language is large</li>
<li>54 (9%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">24 (9%) This language is expressive</li>
<li class="supNeg">13 (9%) I would use this language for writing programs for an embedded hardware platform</li>
<li>38 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>59 (9%) There are many good commercial tools for this language</li>
<li>33 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
</ul>
<ul>
<li class="supNeg">15 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>35 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">10 (6%) I know many other people who use this language</li>
<li>37 (6%) This language has many features which feel "tacked on"</li>
<li class="supNeg">17 (6%) This is a mainstream language</li>
<li>61 (6%) I use this language out of choice</li>
<li>30 (6%) There are many good commercial tools for this language</li>
<li>25 (7%) There are many good open-source tools for this language</li>
<li>41 (7%) Code written in this language is very readable</li>
<li class="supNeg">23 (7%) There is a wide variety of open source code written in this language</li>
<li>67 (7%) I find this language easy to prototype in</li>
<li>38 (7%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">23 (8%) When I write code in this language I can be very sure it is correct</li>
<li>37 (8%) This language is well documented</li>
<li class="supPos">85 (8%) I enjoy playing with this language but would never use it for "real code"</li>
<li>51 (8%) This language makes it easy to shoot yourself in the foot</li>
<li>25 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>65 (8%) This language is expressive</li>
<li class="supNeg">10 (9%) I can imagine using this language in my day job</li>
<li>49 (9%) I know this language well</li>
<li class="supNeg">14 (9%) I usually use this language on projects with many other members</li>
<li>47 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>44 (9%) This language is likely to have a strong influence on future languages</li>
<li>29 (9%) This language excels at concurrency</li>
<li class="supNeg">21 (9%) This language has a strong static type system</li>
<li class="supPos">75 (9%) This language has a very coherent design</li>
</ul>
<ul>
<li>61 (0%) There is a lot of accidental complexity when writing code in this language</li>
<li>35 (1%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>37 (1%) Learning this language improved my ability as a programmer</li>
<li>47 (1%) This language is likely to have a strong influence on future languages</li>
<li>55 (2%) This language is good for scientific computing</li>
<li>64 (2%) This is a high level language</li>
<li>54 (3%) I still discover new features of this language on a fairly regular basis</li>
<li class="supPos">86 (3%) This language encourages writing reusable code.</li>
<li>38 (3%) This language is very flexible</li>
<li class="supPos">79 (3%) I use many applications written in this language</li>
<li>40 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>37 (3%) This language excels at symbolic manipulation</li>
<li>67 (4%) This language has a good community</li>
<li>54 (4%) This language has a very coherent design</li>
<li>55 (4%) Code written in this language is very readable</li>
<li>45 (4%) This language is expressive</li>
<li>43 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>27 (4%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supPos">80 (4%) I find it easy to write efficient code in this language</li>
<li>33 (4%) This language has unusual features that I often miss when using other languages</li>
<li>41 (4%) I would like to write more of this language than I currently do</li>
<li>48 (4%) I can imagine this will be a popular language in twenty years time</li>
<li>50 (4%) Programs written in this language tend to be efficient</li>
<li>30 (4%) This language excels at concurrency</li>
<li>71 (5%) Developers who primarily use this language often burn out after a few years</li>
<li>38 (5%) This language matches it's problem domain particularly well.</li>
<li>39 (5%) I find code written in this language very elegant</li>
<li>60 (5%) This language has a strong static type system</li>
<li class="supNeg">19 (5%) This language is minimal</li>
<li>30 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">92 (5%) I would use this language for mobile applications</li>
<li>41 (5%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>60 (5%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">15 (6%) This language is best for very small projects</li>
<li>43 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>49 (7%) I would use this language for casual scripting</li>
<li>30 (7%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">91 (7%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>26 (7%) Code written in this language tends to be terse</li>
<li>54 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>43 (7%) This is a low level language</li>
<li>45 (7%) I would use this language for writing embedded programs</li>
<li>51 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>42 (8%) Writing code in this language is a lot of work</li>
<li>45 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>45 (8%) This language is good for distributed computing</li>
<li>55 (8%) This language is suitable for real-time applications</li>
<li class="supPos">83 (8%) I would use this language for a desktop GUI project</li>
<li class="supPos">75 (8%) This language has many features which feel "tacked on"</li>
<li>61 (8%) This language has a good library distribution mechanism.</li>
<li>39 (8%) This language excels at text processing</li>
<li>48 (8%) I can imagine using this language in my day job</li>
<li>51 (8%) This language has an annoying syntax</li>
<li class="supPos">89 (9%) This language has a high quality implementation</li>
<li class="supPos">81 (9%) It is easy to tell at a glance what code in this language does</li>
<li>26 (9%) This language is built on a small core of orthogonal features</li>
<li>30 (9%) Learning this language significantly changed how I use other languages.</li>
<li>73 (9%) I find this language easy to prototype in</li>
<li>68 (9%) Programs written in this language tend to play well with others</li>
<li>59 (9%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
</ul>
<ul>
<li>73 (3%) This language has a very coherent design</li>
<li class="supPos">81 (4%) This language is likely to have a strong influence on future languages</li>
<li>38 (4%) This language is good for beginners</li>
<li>40 (4%) I use many applications written in this language</li>
<li class="supNeg">8 (4%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>38 (5%) This is a mainstream language</li>
<li class="supNeg">21 (5%) This is a low level language</li>
<li class="supNeg">18 (5%) There is a lot of accidental complexity when writing code in this language</li>
<li>30 (5%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">24 (5%) This language makes it easy to shoot yourself in the foot</li>
<li>40 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">23 (6%) Writing code in this language is a lot of work</li>
<li>33 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>25 (6%) Code written in this language tends to be verbose</li>
<li class="supPos">88 (6%) This is a high level language</li>
<li>44 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>74 (6%) This language has a high quality implementation</li>
<li class="supPos">92 (7%) This language encourages writing reusable code.</li>
<li>49 (7%) This language is likely to be around for a very long time</li>
<li>57 (7%) Code written in this language tends to be terse</li>
<li>67 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>47 (7%) I regularly use this language</li>
<li>26 (7%) I often get angry when writing code in this language</li>
<li>27 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>73 (7%) This language excels at symbolic manipulation</li>
<li>64 (7%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>60 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li>62 (7%) Programs written in this language tend to play well with others</li>
<li>64 (8%) Code written in this language is very readable</li>
<li class="supPos">83 (8%) I find this language easy to prototype in</li>
<li>65 (8%) I would use this language for casual scripting</li>
<li>61 (8%) This language has a good library distribution mechanism.</li>
<li>40 (8%) I know many other people who use this language</li>
<li>52 (8%) There are many good tools for this language</li>
<li>42 (9%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>62 (9%) This language is suitable for real-time applications</li>
<li class="supNeg">22 (9%) I learned this language early in my career as a programmer</li>
<li class="supPos">82 (9%) This language encourages writing code that is easy to maintain.</li>
<li>39 (9%) This language is well documented</li>
<li class="supPos">75 (9%) This language has unusual features that I often miss when using other languages</li>
<li>55 (9%) This language is unusually bad for beginners</li>
<li>42 (9%) There is a wide variety of open source code written in this language</li>
</ul>
</div>
k-means with k = 10
<tabled class="data" id="clusters10">
  <trd>
    <tdd>Fortran,5.0</tdd>
    <tdd>Pascal,6.0</tdd>
    <tdd>Delphi,7.0</tdd>
    <tdd>Cobol,8.0</tdd>
    <tdd>Assembler,12.0</tdd>
  </trd>
  <trd>
    <tdd>C#,7.0</tdd>
    <tdd>Java,7.0</tdd>
    <tdd>C++,8.0</tdd>
    <tdd>C,10.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,6.0</tdd>
    <tdd>Standard ML,8.0</tdd>
    <tdd>Agda,9.0</tdd>
  </trd>
  <trd>
    <tdd>Lua,6.0</tdd>
    <tdd>Smalltalk,6.0</tdd>
    <tdd>Groovy,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>Scheme,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
    <tdd>Ruby,8.0</tdd>
    <tdd>Io,8.0</tdd>
    <tdd>Mozart-Oz,8.0</tdd>
    <tdd>Erlang,10.0</tdd>
    <tdd>Python,10.0</tdd>
    <tdd>REBOL,12.0</tdd>
  </trd>
  <trd>
    <tdd>PHP,4.0</tdd>
    <tdd>Visual Basic,4.0</tdd>
  </trd>
  <trd>
    <tdd>APL,5.0</tdd>
    <tdd>Prolog,5.0</tdd>
    <tdd>Forth,7.0</tdd>
  </trd>
  <trd>
    <tdd>F#,5.0</tdd>
    <tdd>Clojure,5.0</tdd>
    <tdd>Scala,6.0</tdd>
    <tdd>O'Caml,6.0</tdd>
    <tdd>Haskell,7.0</tdd>
  </trd>
  <trd>
    <tdd>D,5.0</tdd>
    <tdd>Ada,6.0</tdd>
    <tdd>Objective C,6.0</tdd>
    <tdd>Eiffel,6.0</tdd>
    <tdd>Go,6.0</tdd>
  </trd>
  <trd>
    <tdd>ELisp,6.0</tdd>
    <tdd>TCL,6.0</tdd>
    <tdd>R,6.0</tdd>
    <tdd>Javascript,7.0</tdd>
    <tdd>Shell,7.0</tdd>
    <tdd>Matlab,7.0</tdd>
    <tdd>Perl,8.0</tdd>
    <tdd>AWK,8.0</tdd>
    <tdd>Mathematica,8.0</tdd>
    <tdd>ActionScript,11.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,5.0</tdd>
    <tdd>J,5.0</tdd>
  </trd>
</tabled>
<div class="support" id="support10">
<ul>
<li>45 (2%) This language has a very coherent design</li>
<li class="supNeg">12 (3%) I can imagine this will be a popular language in twenty years time</li>
<li>26 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">12 (5%) I would use this language for writing server programs</li>
<li>45 (5%) This is a mainstream language</li>
<li>41 (5%) The resources for learning this language are of high quality</li>
<li>37 (5%) This language has a very dogmatic community</li>
<li>69 (5%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">6 (5%) I still discover new features of this language on a fairly regular basis</li>
<li>33 (6%) I use many applications written in this language</li>
<li>52 (6%) There are many good commercial tools for this language</li>
<li class="supNeg">10 (6%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">16 (6%) This language excels at symbolic manipulation</li>
<li class="supNeg">10 (7%) I can imagine using this language in my day job</li>
<li class="supNeg">11 (7%) This language has unusual features that I often miss when using other languages</li>
<li>57 (7%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">11 (7%) I enjoy using this language</li>
<li>36 (8%) I know many other people who use this language</li>
<li>65 (8%) I often get angry when writing code in this language</li>
<li>43 (8%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>58 (8%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">12 (8%) This language is good for distributed computing</li>
<li class="supNeg">11 (9%) This language excels at text processing</li>
<li>51 (9%) This language has a high quality implementation</li>
<li class="supPos">82 (9%) I learned this language early in my career as a programmer</li>
<li class="supNeg">16 (9%) This language is best for very small projects</li>
</ul>
<ul>
<li>54 (1%) I can imagine this will be a popular language in twenty years time</li>
<li>39 (3%) I would like to write more of this language than I currently do</li>
<li class="supNeg">4 (3%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">94 (3%) This language has a high quality implementation</li>
<li>60 (4%) This language has a strong static type system</li>
<li>34 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">94 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supPos">91 (5%) This is a mainstream language</li>
<li class="supPos">83 (5%) The resources for learning this language are of high quality</li>
<li>28 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li>32 (5%) I find code written in this language very elegant</li>
<li class="supPos">91 (5%) There are many good commercial tools for this language</li>
<li>33 (6%) This language excels at symbolic manipulation</li>
<li>39 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>26 (7%) This language excels at concurrency</li>
<li class="supPos">91 (7%) I know many other people who use this language</li>
<li>55 (7%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supPos">75 (7%) I know this language well</li>
<li class="supPos">81 (7%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">91 (7%) I find it easy to write efficient code in this language</li>
<li>46 (7%) I would use this language for casual scripting</li>
<li>51 (8%) Code written in this language is very readable</li>
<li>61 (8%) This language is good for scientific computing</li>
<li class="supNeg">24 (8%) This language has a niche outside of which I would not use it</li>
<li>64 (8%) This language is good for numeric computing</li>
<li>26 (8%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">89 (8%) I use many applications written in this language</li>
<li>26 (8%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">23 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>57 (9%) This is a high level language</li>
<li>72 (9%) I would use this language to write a command-line app</li>
<li class="supPos">83 (9%) There are many good tools for this language</li>
<li class="supPos">82 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
</ul>
<ul>
<li>35 (0%) I would use this language for writing embedded programs</li>
<li class="supNeg">21 (1%) I can imagine using this language in my day job</li>
<li>53 (2%) I enjoy using this language</li>
<li>56 (2%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supNeg">18 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">94 (3%) This language has a strong static type system</li>
<li class="supPos">83 (4%) This language has a very coherent design</li>
<li>55 (4%) Code written in this language is very readable</li>
<li class="supNeg">23 (4%) This language excels at concurrency</li>
<li>58 (4%) This language is likely to be a passing fad</li>
<li class="supPos">79 (4%) I use this language out of choice</li>
<li>59 (5%) This language is good for scientific computing</li>
<li>61 (5%) I would like to write more of this language than I currently do</li>
<li>25 (5%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">21 (5%) There are many good tools for this language</li>
<li class="supPos">86 (6%) This is a high level language</li>
<li class="supPos">79 (6%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>36 (6%) This language is large</li>
<li>70 (6%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">24 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li>43 (7%) This language has an annoying syntax</li>
<li class="supPos">84 (7%) This language is expressive</li>
<li class="supPos">82 (7%) I find code written in this language very elegant</li>
<li class="supNeg">15 (7%) I use many applications written in this language</li>
<li class="supNeg">20 (7%) This language is good for distributed computing</li>
<li>71 (7%) This language encourages writing reusable code.</li>
<li>57 (7%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">9 (7%) This is a low level language</li>
<li>25 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">5 (7%) This is a mainstream language</li>
<li class="supPos">91 (8%) Learning this language improved my ability as a programmer</li>
<li class="supNeg">19 (8%) Libraries in this language tend to be well documented.</li>
<li>25 (8%) There is a wide variety of open source code written in this language</li>
<li>63 (8%) The semantics of this language are much different than other languages I know.</li>
<li>28 (8%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>45 (8%) Code written in this language tends to be terse</li>
<li>33 (9%) This language has a good library distribution mechanism.</li>
<li>31 (9%) This language is likely to be around for a very long time</li>
<li>26 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>51 (9%) This language is minimal</li>
<li class="supNeg">12 (9%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>68 (9%) This language excels at symbolic manipulation</li>
<li>47 (9%) Writing code in this language is a lot of work</li>
<li>53 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">23 (9%) I regularly use this language</li>
</ul>
<ul>
<li class="supNeg">24 (4%) This is a low level language</li>
<li class="supPos">80 (4%) This is a high level language</li>
<li>27 (5%) When I write code in this language I can be very sure it is correct</li>
<li>28 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>40 (8%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">17 (9%) Writing code in this language is a lot of work</li>
<li>69 (9%) This language is expressive</li>
<li>32 (9%) I would use this language for writing embedded programs</li>
<li class="supNeg">22 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
</ul>
<ul>
<li class="supNeg">0 (0%) Learning this language significantly changed how I use other languages.</li>
<li>37 (0%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">20 (0%) This language excels at concurrency</li>
<li>54 (0%) Libraries in this language tend to be well documented.</li>
<li>44 (0%) I find it easy to write efficient code in this language</li>
<li class="supNeg">8 (0%) This language is built on a small core of orthogonal features</li>
<li>71 (0%) This language has an annoying syntax</li>
<li>55 (0%) Code written in this language is very readable</li>
<li>31 (0%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">3 (0%) I enjoy using this language</li>
<li>30 (0%) This language has a very dogmatic community</li>
<li>35 (0%) This language encourages writing reusable code.</li>
<li>35 (0%) Writing code in this language is a lot of work</li>
<li>30 (1%) This language is best for very large projects</li>
<li class="supNeg">11 (1%) Programs written in this language tend to be efficient</li>
<li class="supNeg">21 (1%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>30 (1%) Programs written in this language will usually work in future versions of the language</li>
<li class="supNeg">21 (1%) This language is good for numeric computing</li>
<li>65 (1%) I find this language easy to prototype in</li>
<li>27 (1%) This language is suitable for real-time applications</li>
<li>26 (1%) This language is expressive</li>
<li class="supNeg">14 (2%) I can imagine using this language in my day job</li>
<li>35 (2%) This is a low level language</li>
<li class="supPos">92 (2%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">12 (2%) This language is good for distributed computing</li>
<li class="supNeg">4 (2%) I would use this language for writing programs for an embedded hardware platform</li>
<li>25 (2%) I would use this language as a scripting language embedded inside a larger application</li>
<li>32 (2%) I would use this language to write a command-line app</li>
<li class="supPos">83 (2%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">4 (2%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">5 (2%) Learning this language improved my ability as a programmer</li>
<li class="supNeg">5 (2%) This language has unusual features that I often miss when using other languages</li>
<li>59 (2%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">8 (3%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">16 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>37 (3%) This language is likely to be around for a very long time</li>
<li>48 (3%) This language is good for beginners</li>
<li>62 (3%) I know this language well</li>
<li>64 (3%) There is a lot of accidental complexity when writing code in this language</li>
<li>44 (3%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">79 (3%) This language has many features which feel "tacked on"</li>
<li class="supNeg">10 (3%) I often feel like I am not smart enough to write this language</li>
<li>30 (3%) I would use this language for mobile applications</li>
<li>61 (3%) It is easy to tell at a glance what code in this language does</li>
<li>33 (4%) This language has a high quality implementation</li>
<li>52 (4%) This language is large</li>
<li>66 (4%) This is a high level language</li>
<li class="supNeg">4 (4%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>39 (4%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">16 (4%) This language is likely to have a strong influence on future languages</li>
<li>54 (4%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">14 (4%) I would use this language for writing embedded programs</li>
<li class="supNeg">4 (4%) Code written in this language tends to be very reliable</li>
<li>37 (5%) Programs written in this language tend to play well with others</li>
<li>69 (5%) There are many good commercial tools for this language</li>
<li>61 (5%) The resources for learning this language are of high quality</li>
<li>50 (5%) There are many good tools for this language</li>
<li class="supNeg">12 (5%) The semantics of this language are much different than other languages I know.</li>
<li>48 (5%) This language has a good library distribution mechanism.</li>
<li>62 (5%) This language is likely to be a passing fad</li>
<li class="supNeg">24 (5%) This language excels at symbolic manipulation</li>
<li>34 (5%) I use this language out of choice</li>
<li class="supNeg">18 (6%) Code written in this language tends to be terse</li>
<li>48 (6%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">20 (6%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>45 (6%) This language encourages writing code that is easy to maintain.</li>
<li>53 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li>38 (6%) This language is best for very small projects</li>
<li>59 (7%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">87 (7%) I often get angry when writing code in this language</li>
<li>48 (7%) This language excels at text processing</li>
<li class="supNeg">7 (7%) I would like to write more of this language than I currently do</li>
<li>45 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">88 (8%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supNeg">20 (8%) This language is good for scientific computing</li>
<li class="supNeg">12 (8%) I find code written in this language very elegant</li>
<li class="supPos">91 (8%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">15 (8%) I can imagine this will be a popular language in twenty years time</li>
<li>62 (9%) Code written in this language tends to be verbose</li>
<li class="supNeg">9 (9%) This language has a very coherent design</li>
<li>55 (9%) I would use this language for casual scripting</li>
<li class="supNeg">21 (9%) This language has a strong static type system</li>
<li>52 (9%) This language would be good for teaching children to write software</li>
</ul>
<ul>
<li>55 (0%) I use this language out of choice</li>
<li class="supNeg">17 (1%) I know many other people who use this language</li>
<li>64 (1%) This language is unusually bad for beginners</li>
<li class="supNeg">23 (1%) I usually use this language on solo projects</li>
<li class="supNeg">20 (1%) I use many applications written in this language</li>
<li>33 (1%) This language has many features which feel "tacked on"</li>
<li class="supNeg">17 (1%) This language is good for distributed computing</li>
<li>27 (2%) This language is good for beginners</li>
<li>45 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">22 (2%) This language excels at concurrency</li>
<li class="supNeg">9 (2%) It is easy to tell at a glance what code in this language does</li>
<li>46 (2%) It's unusual for me to discover unfamiliar features</li>
<li>38 (3%) Code written in this language is very readable</li>
<li class="supNeg">2 (3%) I can imagine using this language in my day job</li>
<li class="supNeg">4 (3%) I can imagine this will be a popular language in twenty years time</li>
<li>51 (3%) I often get angry when writing code in this language</li>
<li>37 (3%) There are many good commercial tools for this language</li>
<li>28 (3%) I would use this language for a web project</li>
<li class="supNeg">16 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>70 (3%) This language has a very coherent design</li>
<li>37 (4%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">15 (4%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">19 (4%) This language is best for very large projects</li>
<li>36 (4%) Code written in this language tends to be very reliable</li>
<li>55 (4%) This language has a niche in which it is great</li>
<li>34 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">20 (5%) There is a wide variety of open source code written in this language</li>
<li>36 (5%) This language has a good community</li>
<li>42 (5%) This language has a very dogmatic community</li>
<li>43 (5%) This language encourages writing code that is easy to maintain.</li>
<li>42 (5%) This language is likely to have a strong influence on future languages</li>
<li>56 (5%) Developers who primarily use this language often burn out after a few years</li>
<li>27 (5%) I would use this language to write a command-line app</li>
<li>31 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>47 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li>45 (5%) This language has unusual features that I often miss when using other languages</li>
<li>59 (5%) This language is expressive</li>
<li class="supPos">79 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">23 (6%) I would use this language for a desktop GUI project</li>
<li>54 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">19 (6%) This is a mainstream language</li>
<li class="supNeg">19 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>34 (6%) I regularly use this language</li>
<li>65 (6%) This language is built on a small core of orthogonal features</li>
<li>44 (6%) The resources for learning this language are of high quality</li>
<li>67 (6%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">21 (7%) There are many good open-source tools for this language</li>
<li class="supNeg">19 (7%) I still discover new features of this language on a fairly regular basis</li>
<li>60 (7%) I find code written in this language very elegant</li>
<li>44 (7%) I would use this language for casual scripting</li>
<li>27 (7%) There are many good tools for this language</li>
<li>30 (7%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">7 (7%) Libraries in this language tend to be well documented.</li>
<li>27 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>37 (7%) I enjoy using this language</li>
<li>39 (7%) This language is well documented</li>
<li class="supNeg">15 (8%) Code written in this language tends to be verbose</li>
<li>37 (8%) Writing code in this language is a lot of work</li>
<li>46 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>40 (8%) This language is likely to be around for a very long time</li>
<li>46 (8%) I would like to write more of this language than I currently do</li>
<li>45 (8%) This language has a very rigid idea of how things should be done</li>
<li>37 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>47 (9%) This language encourages writing reusable code.</li>
<li class="supNeg">18 (9%) Programs written in this language tend to play well with others</li>
<li>27 (9%) This language has a good library distribution mechanism.</li>
<li class="supNeg">16 (9%) This language excels at text processing</li>
<li>48 (9%) I know this language well</li>
<li>65 (9%) I often feel like I am not smart enough to write this language</li>
<li>67 (9%) Learning this language improved my ability as a programmer</li>
<li>51 (9%) This language excels at symbolic manipulation</li>
<li>31 (9%) I would use this language for mobile applications</li>
<li>34 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
</ul>
<ul>
<li class="supPos">95 (2%) This language encourages writing reusable code.</li>
<li>58 (3%) This language matches it's problem domain particularly well.</li>
<li>56 (3%) This language excels at text processing</li>
<li>73 (4%) This language has a very coherent design</li>
<li class="supPos">87 (4%) I find this language easy to prototype in</li>
<li class="supNeg">19 (4%) This is a low level language</li>
<li>41 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">81 (4%) This language is likely to have a strong influence on future languages</li>
<li>39 (4%) This language is good for beginners</li>
<li>40 (4%) I use many applications written in this language</li>
<li>32 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>68 (5%) I would use this language for casual scripting</li>
<li class="supNeg">8 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">23 (5%) Code written in this language tends to be verbose</li>
<li>39 (5%) This is a mainstream language</li>
<li class="supNeg">23 (5%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">21 (5%) Writing code in this language is a lot of work</li>
<li>39 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supPos">90 (5%) This is a high level language</li>
<li>67 (6%) Code written in this language is very readable</li>
<li class="supNeg">18 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li>59 (6%) Code written in this language tends to be terse</li>
<li>32 (6%) Developers who primarily use this language often burn out after a few years</li>
<li>32 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">91 (6%) I use this language out of choice</li>
<li>43 (6%) I know many other people who use this language</li>
<li>58 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li>69 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>64 (7%) Programs written in this language tend to play well with others</li>
<li class="supPos">75 (7%) This language has a high quality implementation</li>
<li>45 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>68 (7%) I enjoy using this language</li>
<li>59 (7%) This language is suitable for real-time applications</li>
<li class="supPos">88 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>63 (7%) This language has a good library distribution mechanism.</li>
<li class="supNeg">11 (7%) I am reluctant to admit to knowing this language</li>
<li>74 (7%) This language excels at symbolic manipulation</li>
<li>54 (7%) There are many good tools for this language</li>
<li class="supPos">90 (7%) This language is expressive</li>
<li>46 (8%) I regularly use this language</li>
<li>41 (8%) This language is well documented</li>
<li>49 (8%) This language is likely to be around for a very long time</li>
<li>27 (8%) I often get angry when writing code in this language</li>
<li>27 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>64 (8%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supPos">83 (8%) I would use this language to write a command-line app</li>
<li>45 (9%) This language is best for very small projects</li>
<li class="supPos">82 (9%) I find code written in this language very elegant</li>
<li>58 (9%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">14 (9%) It's unusual for me to discover unfamiliar features</li>
<li>71 (9%) This language is good for numeric computing</li>
<li>55 (9%) This language is good for distributed computing</li>
<li class="supPos">87 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">18 (9%) This language has a niche outside of which I would not use it</li>
<li>44 (9%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">23 (9%) I learned this language early in my career as a programmer</li>
<li>47 (9%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">83 (9%) This language encourages writing code that is easy to maintain.</li>
</ul>
<ul>
<li>63 (4%) This is a high level language</li>
<li>56 (4%) This language is good for scientific computing</li>
<li>29 (4%) The semantics of this language are much different than other languages I know.</li>
<li>37 (4%) Learning this language significantly changed how I use other languages.</li>
<li>39 (4%) This language excels at symbolic manipulation</li>
<li>32 (4%) I enjoy using this language</li>
<li>34 (5%) I can imagine using this language in my day job</li>
<li>44 (5%) I know this language well</li>
<li>44 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>70 (5%) This language is best for very large projects</li>
<li>39 (5%) I would use this language for a web project</li>
<li>55 (5%) Programs written in this language tend to play well with others</li>
<li>31 (5%) This language is good for beginners</li>
<li>62 (6%) This language has a strong static type system</li>
<li>44 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>34 (6%) This language is good for distributed computing</li>
<li>48 (6%) This language has a good library distribution mechanism.</li>
<li class="supNeg">24 (6%) I would use this language as a scripting language embedded inside a larger application</li>
<li>64 (6%) I use this language out of choice</li>
<li>49 (6%) I find code written in this language very elegant</li>
<li>54 (6%) This language has a very dogmatic community</li>
<li>44 (7%) This language is very flexible</li>
<li>27 (7%) Code written in this language tends to be terse</li>
<li>56 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>53 (7%) This language is expressive</li>
<li>50 (7%) This language is likely to have a strong influence on future languages</li>
<li>40 (7%) I usually use this language on projects with many other members</li>
<li>45 (7%) This language has an annoying syntax</li>
<li>35 (7%) This language excels at text processing</li>
<li>36 (7%) I am reluctant to admit to knowing this language</li>
<li>29 (7%) I often feel like I am not smart enough to write this language</li>
<li>48 (7%) This is a low level language</li>
<li>31 (7%) There are many good open-source tools for this language</li>
<li>39 (7%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>38 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">83 (8%) This language encourages writing reusable code.</li>
<li>33 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>57 (8%) This language has many features which feel "tacked on"</li>
<li>45 (8%) This language has unusual features that I often miss when using other languages</li>
<li>31 (8%) There is a wide variety of open source code written in this language</li>
<li>70 (8%) This language is suitable for real-time applications</li>
<li>68 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>29 (9%) This language is minimal</li>
<li>57 (9%) The resources for learning this language are of high quality</li>
<li>60 (9%) Code written in this language is very readable</li>
<li>74 (9%) I find it easy to write efficient code in this language</li>
<li>37 (9%) This language is built on a small core of orthogonal features</li>
<li>34 (9%) This language is likely to be around for a very long time</li>
<li>62 (9%) Programs written in this language tend to be efficient</li>
<li class="supNeg">18 (9%) This language has a niche in which it is great</li>
</ul>
<ul>
<li class="supNeg">23 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>26 (6%) I can imagine using this language in my day job</li>
<li>42 (7%) Code written in this language tends to be terse</li>
<li>27 (7%) This is a low level language</li>
<li class="supNeg">18 (7%) When I write code in this language I can be very sure it is correct</li>
<li>32 (7%) Writing code in this language is a lot of work</li>
<li class="supNeg">14 (7%) This language is good for distributed computing</li>
<li>28 (7%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">16 (7%) This language has a strong static type system</li>
<li class="supNeg">21 (8%) This language excels at concurrency</li>
<li>57 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>44 (8%) The semantics of this language are much different than other languages I know.</li>
<li>47 (8%) Code written in this language is very readable</li>
<li class="supNeg">19 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>46 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>54 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">79 (8%) I find this language easy to prototype in</li>
<li>46 (9%) I usually use this language on solo projects</li>
<li>30 (9%) This language has unusual features that I often miss when using other languages</li>
<li>42 (9%) This language has a very dogmatic community</li>
<li class="supNeg">22 (9%) Programs written in this language tend to be efficient</li>
<li>51 (9%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">20 (9%) I enjoy using this language</li>
<li>34 (9%) This language has a very coherent design</li>
<li>47 (9%) I find it easy to write efficient code in this language</li>
</ul>
<ul>
<li>45 (0%) The resources for learning this language are of high quality</li>
<li>63 (0%) I would use this language for casual scripting</li>
<li>30 (0%) This language has a very rigid idea of how things should be done</li>
<li>55 (0%) This language excels at symbolic manipulation</li>
<li class="supNeg">11 (0%) I can imagine using this language in my day job</li>
<li class="supPos">75 (0%) This is a high level language</li>
<li>70 (0%) I find code written in this language very elegant</li>
<li>29 (0%) This language has a strong static type system</li>
<li>38 (0%) This language has many features which feel "tacked on"</li>
<li>52 (0%) Programs written in this language tend to be efficient</li>
<li>54 (1%) I usually use this language on solo projects</li>
<li>56 (1%) I would use this language for writing embedded programs</li>
<li>46 (1%) I would use this language to write a command-line app</li>
<li>72 (1%) This language has a very coherent design</li>
<li>32 (1%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>46 (1%) This language is suitable for real-time applications</li>
<li class="supNeg">22 (1%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">11 (1%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>44 (2%) I often get angry when writing code in this language</li>
<li class="supPos">97 (2%) The semantics of this language are much different than other languages I know.</li>
<li>60 (2%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>61 (2%) This language is unusually bad for beginners</li>
<li>38 (2%) Writing code in this language is a lot of work</li>
<li>45 (2%) This language has a good library distribution mechanism.</li>
<li>47 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>53 (3%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">96 (3%) I enjoy playing with this language but would never use it for "real code"</li>
<li>35 (3%) Libraries in this language tend to be well documented.</li>
<li>43 (3%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supNeg">14 (3%) This is a mainstream language</li>
<li>46 (3%) This language is good for beginners</li>
<li>37 (3%) This language excels at concurrency</li>
<li>37 (3%) This language is likely to have a strong influence on future languages</li>
<li>50 (3%) This language would be good for teaching children to write software</li>
<li>34 (3%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">80 (4%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">23 (4%) I would use this language for a web project</li>
<li>35 (4%) I regularly use this language</li>
<li>38 (4%) This language is likely to be around for a very long time</li>
<li class="supNeg">4 (4%) Code written in this language tends to be verbose</li>
<li>29 (4%) It is easy to debug programs written in this language when it goes wrong</li>
<li>58 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li>51 (5%) I would like to write more of this language than I currently do</li>
<li class="supPos">75 (5%) This language is expressive</li>
<li>38 (5%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>46 (5%) This language is built on a small core of orthogonal features</li>
<li class="supNeg">21 (5%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>33 (5%) There are many good open-source tools for this language</li>
<li>56 (5%) This language has a good community</li>
<li>38 (6%) I would use this language for mobile applications</li>
<li>29 (6%) It is easy to tell at a glance what code in this language does</li>
<li class="supPos">75 (6%) I find this language easy to prototype in</li>
<li class="supPos">76 (6%) Learning this language improved my ability as a programmer</li>
<li>47 (6%) This language has a niche outside of which I would not use it</li>
<li>47 (6%) Programs written in this language tend to play well with others</li>
<li>52 (6%) Programs written in this language will usually work in future versions of the language</li>
<li>60 (6%) I still discover new features of this language on a fairly regular basis</li>
<li>70 (6%) I use this language out of choice</li>
<li>50 (6%) This language has an annoying syntax</li>
<li class="supNeg">12 (6%) I usually use this language on projects with many other members</li>
<li class="supNeg">20 (7%) I would list this language on my resume</li>
<li>36 (7%) Developers who primarily use this language often burn out after a few years</li>
<li class="supPos">78 (7%) This language has a high quality implementation</li>
<li>35 (7%) This language has a very dogmatic community</li>
<li>26 (7%) This language is good for distributed computing</li>
<li>43 (7%) I would use this language for a desktop GUI project</li>
<li>39 (7%) This language is well documented</li>
<li>28 (7%) There are many good tools for this language</li>
<li class="supNeg">15 (7%) I know many other people who use this language</li>
<li>39 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">18 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">21 (8%) I am reluctant to admit to knowing this language</li>
<li>33 (8%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>65 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">16 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>30 (9%) There are many good commercial tools for this language</li>
<li>62 (9%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">10 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li>50 (9%) I know this language well</li>
<li>27 (9%) I would use this language for writing server programs</li>
</ul>
</div>
k-means with k = 11
<tabled class="data" id="clusters11">
  <trd>
    <tdd>APL,5.0</tdd>
    <tdd>Prolog,5.0</tdd>
    <tdd>Mathematica,6.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,7.0</tdd>
    <tdd>Agda,7.0</tdd>
  </trd>
  <trd>
    <tdd>Visual Basic,5.0</tdd>
    <tdd>Delphi,5.0</tdd>
    <tdd>Pascal,6.0</tdd>
    <tdd>PHP,7.0</tdd>
  </trd>
  <trd>
    <tdd>Python,5.0</tdd>
    <tdd>Ruby,5.0</tdd>
    <tdd>C#,7.0</tdd>
  </trd>
  <trd>
    <tdd>F#,5.0</tdd>
    <tdd>Scala,5.0</tdd>
    <tdd>Clojure,5.0</tdd>
    <tdd>Haskell,7.0</tdd>
  </trd>
  <trd>
    <tdd>Fortran,6.0</tdd>
    <tdd>Cobol,8.0</tdd>
    <tdd>Assembler,10.0</tdd>
  </trd>
  <trd>
    <tdd>Go,5.0</tdd>
    <tdd>D,6.0</tdd>
    <tdd>Lua,7.0</tdd>
    <tdd>Groovy,7.0</tdd>
    <tdd>O'Caml,7.0</tdd>
    <tdd>Eiffel,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
    <tdd>Ada,8.0</tdd>
    <tdd>Erlang,8.0</tdd>
    <tdd>Smalltalk,8.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Io,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>J,8.0</tdd>
    <tdd>Scheme,8.0</tdd>
    <tdd>Forth,9.0</tdd>
  </trd>
  <trd>
    <tdd>Objective C,7.0</tdd>
    <tdd>C++,8.0</tdd>
    <tdd>Javascript,8.0</tdd>
    <tdd>Java,9.0</tdd>
    <tdd>Perl,9.0</tdd>
    <tdd>C,11.0</tdd>
  </trd>
  <trd>
    <tdd>REBOL,0.0</tdd>
  </trd>
  <trd>
    <tdd>ELisp,6.0</tdd>
    <tdd>TCL,6.0</tdd>
    <tdd>R,6.0</tdd>
    <tdd>AWK,7.0</tdd>
    <tdd>Shell,7.0</tdd>
    <tdd>Matlab,7.0</tdd>
    <tdd>ActionScript,10.0</tdd>
  </trd>
</tabled>
<div class="support" id="support11">
<ul>
<li class="supPos">90 (0%) This language has a niche outside of which I would not use it</li>
<li>43 (0%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">16 (1%) This language is good for distributed computing</li>
<li>55 (1%) I use this language out of choice</li>
<li>53 (1%) I often get angry when writing code in this language</li>
<li class="supPos">84 (1%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">20 (1%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>38 (2%) Code written in this language tends to be very reliable</li>
<li>43 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">19 (2%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">21 (2%) This language excels at concurrency</li>
<li>62 (2%) This language is unusually bad for beginners</li>
<li class="supNeg">18 (3%) This language is best for very large projects</li>
<li class="supNeg">11 (3%) I would use this language for writing programs for an embedded hardware platform</li>
<li>36 (3%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">20 (4%) I would use this language to write a command-line app</li>
<li>25 (4%) I would use this language for a web project</li>
<li>33 (4%) This language is likely to be a passing fad</li>
<li>33 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>45 (4%) I find it easy to write efficient code in this language</li>
<li>41 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>33 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>49 (4%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">14 (4%) This is a low level language</li>
<li class="supNeg">22 (4%) I use many applications written in this language</li>
<li>45 (4%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">18 (4%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>69 (4%) I often feel like I am not smart enough to write this language</li>
<li>39 (4%) I am reluctant to admit to knowing this language</li>
<li>31 (4%) I enjoy using this language</li>
<li>31 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li>26 (5%) I would list this language on my resume</li>
<li>48 (5%) This language has a very dogmatic community</li>
<li>41 (5%) This language has a good community</li>
<li>31 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>43 (6%) Code written in this language is very readable</li>
<li>47 (6%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">22 (6%) There is a wide variety of open source code written in this language</li>
<li>44 (6%) This language has unusual features that I often miss when using other languages</li>
<li>27 (7%) This language is very flexible</li>
<li class="supNeg">21 (7%) This language has a strong static type system</li>
<li>45 (7%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">19 (7%) I would use this language for mobile applications</li>
<li>41 (7%) I would like to write more of this language than I currently do</li>
<li class="supNeg">5 (7%) I can imagine using this language in my day job</li>
<li>32 (7%) This language is likely to be around for a very long time</li>
<li class="supNeg">24 (7%) This language is suitable for real-time applications</li>
<li>45 (7%) I would use this language for casual scripting</li>
<li>25 (7%) I would use this language for a desktop GUI project</li>
<li class="supNeg">18 (8%) Programs written in this language tend to play well with others</li>
<li>58 (8%) This language is built on a small core of orthogonal features</li>
<li>69 (8%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>51 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>45 (8%) This language encourages writing reusable code.</li>
<li class="supNeg">15 (8%) This language excels at text processing</li>
<li class="supNeg">11 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>27 (8%) When I write code in this language I can be very sure it is correct</li>
<li>49 (8%) There is a lot of accidental complexity when writing code in this language</li>
<li>34 (9%) Writing code in this language is a lot of work</li>
<li class="supPos">76 (9%) I find this language easy to prototype in</li>
<li>43 (9%) This language is best for very small projects</li>
<li>48 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>29 (9%) This is a mainstream language</li>
<li>51 (9%) Programs written in this language will usually work in future versions of the language</li>
</ul>
<ul>
<li>35 (0%) I would use this language for writing embedded programs</li>
<li class="supNeg">0 (0%) This is a mainstream language</li>
<li>69 (0%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">20 (0%) This language excels at concurrency</li>
<li class="supNeg">20 (1%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">21 (1%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">20 (1%) I can imagine using this language in my day job</li>
<li>52 (1%) Code written in this language is very readable</li>
<li>58 (1%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>68 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>61 (1%) This language excels at symbolic manipulation</li>
<li class="supPos">79 (1%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">97 (2%) Learning this language improved my ability as a programmer</li>
<li>47 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">83 (2%) I use this language out of choice</li>
<li>30 (2%) This language is best for very large projects</li>
<li class="supPos">97 (2%) I often feel like I am not smart enough to write this language</li>
<li>53 (2%) I enjoy using this language</li>
<li>54 (2%) Writing code in this language is a lot of work</li>
<li class="supNeg">15 (3%) This language is good for distributed computing</li>
<li class="supNeg">16 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">17 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">23 (3%) This language is good for numeric computing</li>
<li class="supPos">81 (3%) This language has a very coherent design</li>
<li>32 (3%) This language is large</li>
<li class="supPos">95 (4%) When I write code in this language I can be very sure it is correct</li>
<li>29 (4%) I regularly use this language</li>
<li class="supPos">95 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">4 (4%) Programs written in this language tend to be efficient</li>
<li>40 (4%) This language is well documented</li>
<li class="supPos">95 (4%) This language has a strong static type system</li>
<li class="supPos">82 (4%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>64 (4%) I would like to write more of this language than I currently do</li>
<li class="supNeg">15 (4%) Programs written in this language tend to play well with others</li>
<li class="supPos">94 (5%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">81 (5%) This language has a niche outside of which I would not use it</li>
<li class="supNeg">5 (5%) This is a low level language</li>
<li class="supNeg">5 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>58 (5%) This language is likely to be a passing fad</li>
<li>57 (5%) This language is good for scientific computing</li>
<li>39 (5%) This language has a good library distribution mechanism.</li>
<li>74 (5%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">89 (5%) This is a high level language</li>
<li class="supNeg">19 (5%) There are many good tools for this language</li>
<li>67 (6%) This language encourages writing reusable code.</li>
<li>58 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li>46 (6%) This language has an annoying syntax</li>
<li class="supNeg">8 (6%) I often get angry when writing code in this language</li>
<li class="supNeg">22 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">7 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">80 (8%) I find code written in this language very elegant</li>
<li class="supNeg">13 (8%) I use many applications written in this language</li>
<li>55 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>44 (8%) Code written in this language tends to be verbose</li>
<li class="supPos">84 (8%) This language is expressive</li>
<li class="supNeg">9 (9%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">24 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">22 (9%) Libraries in this language tend to be well documented.</li>
<li>49 (9%) I know this language well</li>
<li class="supNeg">10 (9%) I would use this language for writing server programs</li>
</ul>
<ul>
<li>35 (1%) Writing code in this language is a lot of work</li>
<li>55 (1%) Code written in this language is very readable</li>
<li>69 (2%) This language has an annoying syntax</li>
<li>44 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">2 (2%) I still discover new features of this language on a fairly regular basis</li>
<li>32 (2%) I would use this language for mobile applications</li>
<li>63 (2%) I find this language easy to prototype in</li>
<li>57 (3%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">11 (3%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">21 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li>52 (4%) This language is good for beginners</li>
<li class="supNeg">7 (4%) This language has unusual features that I often miss when using other languages</li>
<li>32 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">24 (4%) This language excels at symbolic manipulation</li>
<li class="supNeg">15 (4%) This language is good for distributed computing</li>
<li class="supNeg">15 (5%) The semantics of this language are much different than other languages I know.</li>
<li>58 (5%) I know this language well</li>
<li>38 (5%) This language has a high quality implementation</li>
<li>51 (5%) Libraries in this language tend to be well documented.</li>
<li>30 (6%) This language is expressive</li>
<li>37 (6%) This language is likely to be around for a very long time</li>
<li class="supNeg">24 (6%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>36 (6%) This language has a very dogmatic community</li>
<li>61 (6%) This is a high level language</li>
<li class="supNeg">12 (6%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">9 (7%) I enjoy using this language</li>
<li class="supNeg">22 (7%) Code written in this language tends to be terse</li>
<li>47 (7%) There are many good tools for this language</li>
<li>47 (7%) This language is large</li>
<li>41 (7%) This is a low level language</li>
<li>30 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>51 (7%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">12 (7%) I can imagine using this language in my day job</li>
<li>45 (8%) This language has a good library distribution mechanism.</li>
<li class="supNeg">23 (8%) This language is likely to have a strong influence on future languages</li>
<li>40 (8%) I would use this language to write a command-line app</li>
<li>43 (8%) This language encourages writing reusable code.</li>
<li>37 (8%) This language is best for very large projects</li>
<li>66 (8%) Code written in this language tends to be verbose</li>
<li class="supNeg">23 (8%) This language excels at concurrency</li>
<li>53 (8%) It is easy to tell at a glance what code in this language does</li>
<li>49 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">11 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>52 (8%) This language makes it easy to shoot yourself in the foot</li>
<li>39 (8%) I use this language out of choice</li>
<li>49 (9%) This language is unusually bad for beginners</li>
<li>39 (9%) Programs written in this language tend to play well with others</li>
<li>53 (9%) The resources for learning this language are of high quality</li>
<li class="supNeg">17 (9%) When I write code in this language I can be very sure it is correct</li>
</ul>
<ul>
<li class="supPos">80 (2%) This language encourages writing reusable code.</li>
<li>34 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>65 (3%) This language has a very dogmatic community</li>
<li class="supPos">84 (3%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>70 (3%) I know this language well</li>
<li>42 (3%) This language makes it easy to shoot yourself in the foot</li>
<li>39 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>43 (4%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>48 (4%) I would like to write more of this language than I currently do</li>
<li>47 (4%) I enjoy using this language</li>
<li>65 (4%) I still discover new features of this language on a fairly regular basis</li>
<li class="supPos">92 (5%) The resources for learning this language are of high quality</li>
<li class="supPos">78 (5%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">18 (5%) I often feel like I am not smart enough to write this language</li>
<li>40 (5%) This language is suitable for real-time applications</li>
<li>71 (5%) I use many applications written in this language</li>
<li>48 (5%) Learning this language significantly changed how I use other languages.</li>
<li>41 (5%) This language is good for distributed computing</li>
<li>62 (5%) I usually use this language on solo projects</li>
<li>31 (5%) When I write code in this language I can be very sure it is correct</li>
<li>66 (5%) This language has many features which feel "tacked on"</li>
<li>41 (5%) This language matches it's problem domain particularly well.</li>
<li>44 (6%) Code written in this language tends to be terse</li>
<li>66 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>29 (6%) This language has an annoying syntax</li>
<li>67 (6%) I would use this language for writing server programs</li>
<li>30 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">90 (6%) I find this language easy to prototype in</li>
<li>73 (6%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>57 (6%) I regularly use this language</li>
<li class="supPos">77 (6%) I would list this language on my resume</li>
<li>73 (6%) Programs written in this language tend to play well with others</li>
<li class="supNeg">20 (6%) This language has a very rigid idea of how things should be done</li>
<li>51 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>66 (7%) I usually use this language on projects with many other members</li>
<li class="supPos">90 (7%) I would use this language for a web project</li>
<li>30 (7%) I would use this language for writing embedded programs</li>
<li>27 (7%) This is a low level language</li>
<li class="supPos">77 (7%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">86 (7%) This language is well documented</li>
<li>29 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>30 (8%) This language excels at concurrency</li>
<li>28 (8%) This language is built on a small core of orthogonal features</li>
<li>59 (8%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>53 (8%) This language excels at symbolic manipulation</li>
<li class="supPos">77 (8%) This is a high level language</li>
<li>61 (8%) This language is likely to have a strong influence on future languages</li>
<li>46 (8%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">23 (9%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">79 (9%) This is a mainstream language</li>
<li class="supPos">89 (9%) I would use this language to write a command-line app</li>
<li>59 (9%) This language has a very coherent design</li>
<li class="supPos">86 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>33 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">83 (9%) I would use this language for a desktop GUI project</li>
<li>34 (9%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supPos">82 (9%) Libraries in this language tend to be well documented.</li>
</ul>
<ul>
<li class="supPos">96 (2%) This language encourages writing reusable code.</li>
<li>71 (2%) I would use this language for casual scripting</li>
<li class="supNeg">17 (2%) This is a low level language</li>
<li class="supNeg">18 (2%) I learned this language early in my career as a programmer</li>
<li class="supNeg">10 (3%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">94 (3%) I use this language out of choice</li>
<li>58 (3%) This language matches it's problem domain particularly well.</li>
<li class="supPos">83 (3%) This language is likely to have a strong influence on future languages</li>
<li>66 (3%) This language has a good library distribution mechanism.</li>
<li>25 (3%) Code written in this language tends to be verbose</li>
<li>69 (3%) Code written in this language is very readable</li>
<li class="supNeg">15 (3%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">88 (3%) I find this language easy to prototype in</li>
<li>45 (3%) This language is well documented</li>
<li>56 (3%) This language excels at text processing</li>
<li>74 (4%) This language has a very coherent design</li>
<li class="supPos">91 (4%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">19 (4%) Writing code in this language is a lot of work</li>
<li>42 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>56 (4%) This language is suitable for real-time applications</li>
<li>40 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>41 (5%) I use many applications written in this language</li>
<li>33 (5%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">92 (5%) This is a high level language</li>
<li>39 (5%) This language is good for beginners</li>
<li>66 (5%) Programs written in this language tend to play well with others</li>
<li>40 (5%) This is a mainstream language</li>
<li>53 (5%) Programs written in this language tend to be efficient</li>
<li>30 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">23 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>47 (6%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>41 (6%) I know many other people who use this language</li>
<li class="supPos">91 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>69 (6%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">24 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>60 (7%) Code written in this language tends to be terse</li>
<li>58 (7%) This language is good for distributed computing</li>
<li>33 (7%) Developers who primarily use this language often burn out after a few years</li>
<li class="supPos">90 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>51 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li>70 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>34 (7%) I would use this language for writing embedded programs</li>
<li>59 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">76 (7%) This language has a high quality implementation</li>
<li>68 (8%) I enjoy using this language</li>
<li class="supNeg">11 (8%) I am reluctant to admit to knowing this language</li>
<li>60 (8%) Libraries in this language tend to be well documented.</li>
<li>48 (8%) I regularly use this language</li>
<li>73 (8%) This language excels at symbolic manipulation</li>
<li>56 (8%) There are many good tools for this language</li>
<li>42 (8%) This language has a very dogmatic community</li>
<li class="supPos">89 (8%) This language is expressive</li>
<li>51 (8%) This language would be good for teaching children to write software</li>
<li>47 (8%) This language is best for very small projects</li>
<li>49 (8%) This language is likely to be around for a very long time</li>
<li class="supPos">85 (9%) I would use this language to write a command-line app</li>
<li>26 (9%) I often get angry when writing code in this language</li>
<li class="supNeg">15 (9%) This language has a niche outside of which I would not use it</li>
<li>66 (9%) I would use this language for a desktop GUI project</li>
<li>65 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>47 (9%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supPos">78 (9%) This language has unusual features that I often miss when using other languages</li>
</ul>
<ul>
<li class="supPos">80 (0%) I learned this language early in my career as a programmer</li>
<li>43 (1%) This language has a very coherent design</li>
<li class="supNeg">11 (2%) This language excels at symbolic manipulation</li>
<li>31 (2%) I know many other people who use this language</li>
<li>52 (2%) There are many good commercial tools for this language</li>
<li class="supNeg">13 (2%) I can imagine this will be a popular language in twenty years time</li>
<li>28 (2%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>71 (3%) This language is likely to be around for a very long time</li>
<li class="supNeg">10 (3%) I can imagine using this language in my day job</li>
<li>38 (3%) The resources for learning this language are of high quality</li>
<li>51 (3%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">78 (3%) This language is unusually bad for beginners</li>
<li class="supNeg">5 (3%) I would use this language as a scripting language embedded inside a larger application</li>
<li>71 (3%) I often get angry when writing code in this language</li>
<li>45 (4%) This is a mainstream language</li>
<li>34 (4%) This language has a very dogmatic community</li>
<li class="supNeg">10 (4%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">9 (4%) I would use this language for writing server programs</li>
<li class="supNeg">5 (5%) This language excels at text processing</li>
<li>68 (5%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supNeg">5 (5%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">7 (5%) This language is expressive</li>
<li>31 (5%) I use many applications written in this language</li>
<li class="supNeg">8 (5%) This language is likely to have a strong influence on future languages</li>
<li>30 (5%) I would list this language on my resume</li>
<li>25 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">18 (6%) This language would be good for teaching children to write software</li>
<li>70 (6%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">15 (7%) This language is likely to be a passing fad</li>
<li class="supNeg">17 (7%) I usually use this language on projects with many other members</li>
<li>38 (7%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>57 (7%) This language has a high quality implementation</li>
<li class="supNeg">10 (7%) I would use this language for a desktop GUI project</li>
<li class="supNeg">9 (8%) I enjoy using this language</li>
<li>41 (8%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">9 (8%) When I write code in this language I can be very sure it is correct</li>
<li>71 (8%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">8 (8%) This language is good for distributed computing</li>
<li class="supNeg">12 (8%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">22 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">10 (9%) This language has a good community</li>
</ul>
<ul>
<li>37 (5%) This is a mainstream language</li>
<li>43 (6%) Libraries in this language tend to be well documented.</li>
<li>36 (7%) I use many applications written in this language</li>
<li>36 (7%) I can imagine using this language in my day job</li>
<li>56 (7%) The resources for learning this language are of high quality</li>
<li>67 (7%) I use this language out of choice</li>
<li>48 (7%) I would list this language on my resume</li>
<li>37 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>44 (8%) There are many good commercial tools for this language</li>
<li>73 (8%) This is a high level language</li>
<li>39 (8%) This language is frequently used for applications it isn't suitable for</li>
<li>42 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">75 (9%) This language encourages writing code that is easy to maintain.</li>
<li>54 (9%) This language has a good library distribution mechanism.</li>
<li>40 (9%) I usually use this language on projects with many other members</li>
<li>48 (9%) This language is good for scientific computing</li>
</ul>
<ul>
<li class="supPos">77 (5%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>35 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>32 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>66 (6%) I use this language out of choice</li>
<li class="supNeg">15 (6%) I can imagine using this language in my day job</li>
<li>31 (7%) This language has a very rigid idea of how things should be done</li>
<li>33 (8%) This language excels at concurrency</li>
<li>43 (8%) I would use this language for a desktop GUI project</li>
<li>43 (8%) I enjoy using this language</li>
<li>57 (8%) I would like to write more of this language than I currently do</li>
<li>42 (8%) Programs written in this language tend to play well with others</li>
<li>39 (8%) This language has many features which feel "tacked on"</li>
<li class="supNeg">21 (9%) This is a mainstream language</li>
<li>40 (9%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">21 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">84 (9%) I enjoy playing with this language but would never use it for "real code"</li>
<li>43 (9%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">22 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>58 (9%) I would use this language for casual scripting</li>
<li>36 (9%) There are many good commercial tools for this language</li>
</ul>
<ul>
<li class="supNeg">24 (3%) This language excels at concurrency</li>
<li>34 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>42 (4%) I would like to write more of this language than I currently do</li>
<li>57 (5%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>61 (5%) I often get angry when writing code in this language</li>
<li>53 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>34 (8%) Learning this language significantly changed how I use other languages.</li>
<li>34 (8%) I find code written in this language very elegant</li>
<li>44 (8%) Code written in this language is very readable</li>
<li>54 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">20 (9%) When I write code in this language I can be very sure it is correct</li>
</ul>
<ul></ul>
<ul>
<li>41 (3%) Code written in this language tends to be terse</li>
<li class="supNeg">22 (5%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>26 (5%) I can imagine using this language in my day job</li>
<li>32 (5%) Writing code in this language is a lot of work</li>
<li>28 (5%) This is a low level language</li>
<li>50 (6%) Code written in this language is very readable</li>
<li class="supNeg">21 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>48 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">12 (7%) This language is good for distributed computing</li>
<li class="supNeg">18 (7%) When I write code in this language I can be very sure it is correct</li>
<li>26 (7%) Learning this language significantly changed how I use other languages.</li>
<li>59 (7%) Developers who primarily use this language often burn out after a few years</li>
<li>26 (7%) This language has unusual features that I often miss when using other languages</li>
<li>46 (7%) The semantics of this language are much different than other languages I know.</li>
<li>44 (7%) I usually use this language on solo projects</li>
<li>29 (8%) This language is good for beginners</li>
<li class="supNeg">18 (8%) Programs written in this language tend to be efficient</li>
<li>27 (8%) This language is built on a small core of orthogonal features</li>
<li>50 (8%) I use many applications written in this language</li>
<li>43 (8%) This is a mainstream language</li>
<li class="supNeg">13 (8%) I would use this language for writing server programs</li>
<li class="supNeg">17 (8%) This language has a strong static type system</li>
<li>38 (8%) This language has a very dogmatic community</li>
<li>55 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">19 (9%) This language excels at concurrency</li>
<li>42 (9%) I would use this language as a scripting language embedded inside a larger application</li>
<li>26 (9%) This language is likely to have a strong influence on future languages</li>
<li>35 (9%) This language has a very coherent design</li>
<li>32 (9%) Code written in this language tends to be very reliable</li>
<li>51 (9%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>45 (9%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>52 (9%) This language is unusually bad for beginners</li>
<li>52 (9%) This language has many features which feel "tacked on"</li>
</ul>
</div>
k-means with k = 12
<tabled class="data" id="clusters12">
  <trd>
    <tdd>Io,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>Factor,7.0</tdd>
    <tdd>Lua,7.0</tdd>
    <tdd>Scheme,7.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>REBOL,11.0</tdd>
  </trd>
  <trd>
    <tdd>Python,4.0</tdd>
    <tdd>Ruby,4.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,0.0</tdd>
  </trd>
  <trd>
    <tdd>C#,6.0</tdd>
    <tdd>Objective C,6.0</tdd>
    <tdd>Java,7.0</tdd>
    <tdd>Ada,8.0</tdd>
  </trd>
  <trd>
    <tdd>F#,5.0</tdd>
    <tdd>O'Caml,5.0</tdd>
    <tdd>Clojure,6.0</tdd>
    <tdd>Go,6.0</tdd>
    <tdd>D,7.0</tdd>
    <tdd>Erlang,8.0</tdd>
    <tdd>Scala,8.0</tdd>
    <tdd>Haxe,8.0</tdd>
    <tdd>Haskell,9.0</tdd>
    <tdd>Eiffel,9.0</tdd>
  </trd>
  <trd>
    <tdd>C,6.0</tdd>
    <tdd>C++,6.0</tdd>
  </trd>
  <trd>
    <tdd>TCL,6.0</tdd>
    <tdd>ELisp,7.0</tdd>
    <tdd>Javascript,7.0</tdd>
    <tdd>Perl,7.0</tdd>
    <tdd>Groovy,7.0</tdd>
    <tdd>Shell,7.0</tdd>
    <tdd>PHP,8.0</tdd>
    <tdd>AWK,8.0</tdd>
    <tdd>ActionScript,11.0</tdd>
  </trd>
  <trd>
    <tdd>Pascal,5.0</tdd>
    <tdd>Fortran,6.0</tdd>
    <tdd>Delphi,6.0</tdd>
    <tdd>Cobol,7.0</tdd>
    <tdd>Visual Basic,7.0</tdd>
  </trd>
  <trd>
    <tdd>Forth,6.0</tdd>
    <tdd>APL,8.0</tdd>
    <tdd>Assembler,10.0</tdd>
  </trd>
  <trd>
    <tdd>R,5.0</tdd>
    <tdd>Mathematica,5.0</tdd>
    <tdd>Matlab,6.0</tdd>
    <tdd>Prolog,7.0</tdd>
    <tdd>J,8.0</tdd>
  </trd>
  <trd>
    <tdd>Agda,0.0</tdd>
  </trd>
</tabled>
<div class="support" id="support12">
<ul>
<li>35 (5%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">79 (5%) This is a high level language</li>
<li>68 (5%) I use this language out of choice</li>
<li>28 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>25 (6%) This is a low level language</li>
<li>42 (6%) Developers who primarily use this language often burn out after a few years</li>
<li class="supPos">77 (7%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>45 (7%) This language is suitable for real-time applications</li>
<li class="supNeg">20 (7%) I can imagine using this language in my day job</li>
<li>60 (7%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">21 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>31 (8%) This language excels at concurrency</li>
<li>72 (8%) This language is expressive</li>
<li>38 (8%) This language has many features which feel "tacked on"</li>
<li>56 (9%) This language has a good community</li>
<li>37 (9%) I would use this language for writing server programs</li>
<li>37 (9%) There are many good open-source tools for this language</li>
<li>61 (9%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">24 (9%) I usually use this language on projects with many other members</li>
<li class="supNeg">21 (9%) Writing code in this language is a lot of work</li>
<li>35 (9%) Libraries in this language tend to be well documented.</li>
<li>48 (9%) I would use this language for a desktop GUI project</li>
</ul>
<ul>
<li>36 (0%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supPos">78 (0%) This language is expressive</li>
<li>25 (0%) This language has an annoying syntax</li>
<li class="supPos">77 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>56 (0%) This language is large</li>
<li>60 (0%) There are many good commercial tools for this language</li>
<li>73 (0%) Learning this language improved my ability as a programmer</li>
<li class="supPos">78 (0%) This language encourages writing reusable code.</li>
<li>29 (0%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">83 (0%) This language is best for very small projects</li>
<li class="supNeg">21 (0%) This is a low level language</li>
<li class="supPos">88 (0%) This language would be good for teaching children to write software</li>
<li>68 (0%) I still discover new features of this language on a fairly regular basis</li>
<li>71 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>40 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>67 (1%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">87 (1%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>52 (2%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">21 (2%) I often feel like I am not smart enough to write this language</li>
<li>63 (2%) This language has a very dogmatic community</li>
<li class="supNeg">15 (2%) This language is unusually bad for beginners</li>
<li class="supPos">96 (2%) I would use this language to write a command-line app</li>
<li>52 (2%) I find it easy to write efficient code in this language</li>
<li>37 (2%) This language is good for distributed computing</li>
<li>43 (2%) Code written in this language tends to be very reliable</li>
<li>48 (2%) Code written in this language tends to be terse</li>
<li>67 (2%) I use many applications written in this language</li>
<li>28 (2%) This language has a niche in which it is great</li>
<li>59 (2%) This language excels at symbolic manipulation</li>
<li>64 (2%) I find code written in this language very elegant</li>
<li>33 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">75 (2%) Libraries in this language tend to be well documented.</li>
<li>71 (2%) I know this language well</li>
<li class="supPos">82 (2%) This language has a good community</li>
<li>61 (3%) This language is best for very large projects</li>
<li class="supPos">80 (3%) This language excels at text processing</li>
<li>62 (3%) This language has many features which feel "tacked on"</li>
<li class="supPos">75 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supPos">95 (3%) I find this language easy to prototype in</li>
<li>33 (3%) This language is built on a small core of orthogonal features</li>
<li>65 (3%) I usually use this language on solo projects</li>
<li>65 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>45 (3%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>51 (3%) I would like to write more of this language than I currently do</li>
<li class="supPos">96 (3%) This language has a good library distribution mechanism.</li>
<li class="supPos">84 (3%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>51 (3%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">14 (4%) This language has a strong static type system</li>
<li class="supPos">83 (4%) This is a high level language</li>
<li>73 (4%) I know many other people who use this language</li>
<li class="supNeg">4 (4%) Writing code in this language is a lot of work</li>
<li>63 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">76 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">88 (4%) There is a wide variety of open source code written in this language</li>
<li>28 (4%) I learned this language early in my career as a programmer</li>
<li>68 (4%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>73 (4%) This is a mainstream language</li>
<li>31 (4%) Code written in this language tends to be verbose</li>
<li class="supPos">94 (5%) The resources for learning this language are of high quality</li>
<li class="supPos">94 (5%) I would use this language for a web project</li>
<li>38 (5%) This language is suitable for real-time applications</li>
<li>62 (5%) I usually use this language on projects with many other members</li>
<li>27 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>46 (5%) I enjoy using this language</li>
<li>64 (5%) I would use this language for writing server programs</li>
<li class="supPos">94 (5%) I would use this language for casual scripting</li>
<li>64 (5%) It is easy to debug programs written in this language when it goes wrong</li>
<li>60 (6%) I regularly use this language</li>
<li>36 (6%) This language is minimal</li>
<li class="supPos">77 (6%) I would use this language for a desktop GUI project</li>
<li>70 (6%) Programs written in this language tend to play well with others</li>
<li>32 (6%) When I write code in this language I can be very sure it is correct</li>
<li>28 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>28 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>41 (7%) This language matches it's problem domain particularly well.</li>
<li class="supPos">92 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>44 (7%) Programs written in this language will usually work in future versions of the language</li>
<li class="supNeg">24 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">91 (7%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>27 (7%) This language excels at concurrency</li>
<li class="supPos">76 (7%) I would list this language on my resume</li>
<li class="supPos">82 (7%) There are many good open-source tools for this language</li>
<li>74 (7%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">91 (8%) I use this language out of choice</li>
<li class="supNeg">21 (8%) This language has a very rigid idea of how things should be done</li>
<li>27 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>40 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>28 (8%) I would use this language for writing embedded programs</li>
<li>29 (8%) I am reluctant to admit to knowing this language</li>
<li>51 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>67 (8%) I would use this language for mobile applications</li>
<li>63 (9%) This language has a very coherent design</li>
<li class="supPos">86 (9%) This language is well documented</li>
<li>66 (9%) There are many good tools for this language</li>
</ul>
<ul></ul>
<ul>
<li>56 (1%) This language is good for scientific computing</li>
<li>34 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>65 (2%) This is a high level language</li>
<li>38 (2%) This language is very flexible</li>
<li>37 (3%) This language excels at symbolic manipulation</li>
<li class="supPos">84 (3%) This language encourages writing reusable code.</li>
<li>63 (3%) There is a lot of accidental complexity when writing code in this language</li>
<li>45 (3%) This language is likely to have a strong influence on future languages</li>
<li>56 (4%) Code written in this language is very readable</li>
<li>33 (4%) This language has unusual features that I often miss when using other languages</li>
<li>42 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>52 (4%) This language has a very coherent design</li>
<li>70 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>39 (4%) I find code written in this language very elegant</li>
<li class="supNeg">18 (4%) This language is minimal</li>
<li class="supPos">78 (5%) I find it easy to write efficient code in this language</li>
<li>47 (5%) This language is expressive</li>
<li>32 (5%) This language excels at concurrency</li>
<li class="supNeg">14 (5%) This language is best for very small projects</li>
<li>44 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>63 (6%) This language has a strong static type system</li>
<li>53 (6%) Programs written in this language tend to be efficient</li>
<li>39 (6%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>43 (6%) This is a low level language</li>
<li>27 (6%) I would use this language as a scripting language embedded inside a larger application</li>
<li>41 (6%) This language matches it's problem domain particularly well.</li>
<li class="supNeg">24 (6%) Code written in this language tends to be terse</li>
<li>45 (7%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>53 (7%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>57 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>43 (7%) This language is good for distributed computing</li>
<li class="supPos">89 (8%) This language has a high quality implementation</li>
<li>45 (8%) I would like to write more of this language than I currently do</li>
<li>48 (8%) This language has an annoying syntax</li>
<li>48 (9%) I would use this language for writing embedded programs</li>
<li class="supPos">76 (9%) Code written in this language tends to be verbose</li>
<li class="supPos">87 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>45 (9%) Writing code in this language is a lot of work</li>
<li class="supNeg">22 (9%) I often feel like I am not smart enough to write this language</li>
<li>66 (9%) This language has a very dogmatic community</li>
<li>36 (9%) This language excels at text processing</li>
</ul>
<ul>
<li>36 (5%) This is a mainstream language</li>
<li>36 (6%) This language is good for beginners</li>
<li>42 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>37 (7%) I use many applications written in this language</li>
<li>25 (7%) Writing code in this language is a lot of work</li>
<li>37 (7%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>42 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>35 (8%) This language is frequently used for applications it isn't suitable for</li>
<li>59 (8%) Programs written in this language tend to play well with others</li>
<li>52 (8%) This language is unusually bad for beginners</li>
<li class="supPos">89 (9%) This language encourages writing reusable code.</li>
<li>43 (9%) There are many good commercial tools for this language</li>
<li>37 (9%) I usually use this language on projects with many other members</li>
<li>70 (9%) This language has a very coherent design</li>
<li>65 (9%) Code written in this language is very readable</li>
<li>37 (9%) This language is minimal</li>
</ul>
<ul>
<li>55 (0%) I can imagine this will be a popular language in twenty years time</li>
<li>73 (0%) This language is good for numeric computing</li>
<li class="supNeg">18 (0%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">78 (0%) I usually use this language on projects with many other members</li>
<li>43 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>39 (0%) I would like to write more of this language than I currently do</li>
<li>55 (0%) Libraries in this language tend to be well documented.</li>
<li class="supPos">77 (0%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">87 (0%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">82 (0%) There are many good open-source tools for this language</li>
<li class="supPos">98 (1%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supPos">98 (1%) I find it easy to write efficient code in this language</li>
<li class="supNeg">4 (1%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">86 (1%) There are many good commercial tools for this language</li>
<li class="supPos">76 (1%) There are many good tools for this language</li>
<li class="supPos">88 (1%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>47 (2%) I often feel like I am not smart enough to write this language</li>
<li>56 (2%) This language has a strong static type system</li>
<li class="supPos">97 (2%) I use many applications written in this language</li>
<li class="supPos">93 (2%) This language has a high quality implementation</li>
<li>39 (2%) I would use this language for casual scripting</li>
<li>44 (2%) I find this language easy to prototype in</li>
<li class="supPos">87 (2%) This is a mainstream language</li>
<li class="supNeg">7 (2%) I am reluctant to admit to knowing this language</li>
<li>36 (2%) This language has a very coherent design</li>
<li>43 (3%) This language has a very dogmatic community</li>
<li class="supPos">85 (3%) I know many other people who use this language</li>
<li>31 (3%) This language has a niche outside of which I would not use it</li>
<li class="supPos">84 (3%) Programs written in this language tend to be efficient</li>
<li>33 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>60 (3%) I would use this language for mobile applications</li>
<li class="supPos">92 (3%) Learning this language improved my ability as a programmer</li>
<li>47 (3%) This language has a good library distribution mechanism.</li>
<li class="supNeg">21 (3%) This language excels at concurrency</li>
<li>37 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">78 (4%) The resources for learning this language are of high quality</li>
<li class="supPos">95 (4%) This language is suitable for real-time applications</li>
<li>33 (4%) This language is well suited for an agile development approach using short iterations.</li>
<li>29 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">75 (4%) I know this language well</li>
<li>28 (4%) I find code written in this language very elegant</li>
<li>62 (4%) Writing code in this language is a lot of work</li>
<li class="supPos">95 (4%) Programs written in this language will usually work in future versions of the language</li>
<li>40 (4%) Learning this language significantly changed how I use other languages.</li>
<li>61 (4%) Code written in this language tends to be verbose</li>
<li>56 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>38 (4%) This language has a good community</li>
<li>28 (4%) This language excels at symbolic manipulation</li>
<li>41 (4%) It is easy to tell at a glance what code in this language does</li>
<li>36 (5%) I would use this language for a web project</li>
<li class="supNeg">19 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">5 (5%) I use this language out of choice</li>
<li>49 (5%) This language encourages writing code that is easy to maintain.</li>
<li>49 (6%) This is a high level language</li>
<li>69 (6%) This language is best for very large projects</li>
<li class="supPos">78 (6%) I would use this language to write a command-line app</li>
<li class="supPos">93 (6%) There is a wide variety of open source code written in this language</li>
<li>45 (6%) Code written in this language is very readable</li>
<li>57 (6%) I often get angry when writing code in this language</li>
<li>68 (6%) This language is good for scientific computing</li>
<li>34 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (7%) I enjoy using this language</li>
<li>34 (7%) Code written in this language tends to be very reliable</li>
<li class="supPos">82 (7%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>73 (8%) This language is very flexible</li>
<li>69 (8%) This is a low level language</li>
<li>31 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">91 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>27 (8%) This language excels at text processing</li>
<li>41 (8%) Code written in this language tends to be terse</li>
<li>46 (8%) I would use this language for writing server programs</li>
<li class="supPos">83 (9%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">90 (9%) This language is likely to be around for a very long time</li>
</ul>
<ul>
<li>30 (4%) This is a low level language</li>
<li class="supNeg">21 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">23 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">15 (5%) When I write code in this language I can be very sure it is correct</li>
<li>43 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>32 (7%) Writing code in this language is a lot of work</li>
<li>52 (8%) The resources for learning this language are of high quality</li>
<li>27 (8%) I can imagine using this language in my day job</li>
<li class="supNeg">21 (9%) This language excels at concurrency</li>
<li class="supNeg">15 (9%) This language has a strong static type system</li>
<li>47 (9%) I usually use this language on solo projects</li>
<li>72 (9%) This is a high level language</li>
<li>40 (9%) Code written in this language tends to be terse</li>
<li>56 (9%) This language makes it easy to shoot yourself in the foot</li>
<li>46 (9%) I find it easy to write efficient code in this language</li>
<li class="supNeg">19 (9%) Programs written in this language tend to be efficient</li>
<li>38 (9%) This language has a very dogmatic community</li>
</ul>
<ul>
<li>48 (3%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">11 (3%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">13 (4%) I would use this language for writing server programs</li>
<li>54 (4%) Code written in this language is very readable</li>
<li>28 (5%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>38 (5%) This language has a very dogmatic community</li>
<li class="supNeg">14 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">7 (5%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">8 (5%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">18 (5%) This language excels at symbolic manipulation</li>
<li>40 (6%) There are many good tools for this language</li>
<li>56 (6%) I know this language well</li>
<li class="supNeg">14 (6%) This language is very flexible</li>
<li>28 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">8 (6%) I enjoy using this language</li>
<li class="supNeg">10 (6%) I can imagine using this language in my day job</li>
<li class="supNeg">13 (7%) I usually use this language on solo projects</li>
<li>37 (7%) This language is best for very large projects</li>
<li>48 (7%) This is a mainstream language</li>
<li>50 (7%) This language encourages writing code that is easy to maintain.</li>
<li>56 (7%) It's unusual for me to discover unfamiliar features</li>
<li>44 (7%) This is a low level language</li>
<li>51 (7%) It is easy to tell at a glance what code in this language does</li>
<li>35 (7%) I use many applications written in this language</li>
<li>46 (7%) This language has a high quality implementation</li>
<li class="supNeg">15 (8%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">13 (8%) This language is good for distributed computing</li>
<li>32 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>29 (9%) I usually use this language on projects with many other members</li>
<li class="supNeg">19 (9%) This language is likely to have a strong influence on future languages</li>
<li>56 (9%) This is a high level language</li>
<li class="supNeg">16 (9%) There are many good open-source tools for this language</li>
<li class="supPos">82 (9%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (9%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">15 (9%) I regularly use this language</li>
<li>67 (9%) I enjoy playing with this language but would never use it for "real code"</li>
</ul>
<ul>
<li class="supNeg">1 (1%) Libraries in this language tend to be well documented.</li>
<li>53 (1%) I use this language out of choice</li>
<li class="supNeg">8 (2%) I can imagine this will be a popular language in twenty years time</li>
<li>41 (2%) The resources for learning this language are of high quality</li>
<li>59 (3%) Learning this language improved my ability as a programmer</li>
<li>63 (3%) Developers who primarily use this language often burn out after a few years</li>
<li>26 (3%) I usually use this language on solo projects</li>
<li class="supNeg">5 (4%) It is easy to tell at a glance what code in this language does</li>
<li class="supNeg">19 (4%) There are many good tools for this language</li>
<li>55 (4%) This language has a niche in which it is great</li>
<li class="supNeg">21 (5%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">6 (5%) This language has a strong static type system</li>
<li class="supNeg">13 (5%) This language is good for distributed computing</li>
<li class="supNeg">7 (5%) I can imagine using this language in my day job</li>
<li>42 (5%) There are many good commercial tools for this language</li>
<li class="supPos">79 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li>26 (6%) This language excels at concurrency</li>
<li>30 (6%) I am reluctant to admit to knowing this language</li>
<li class="supPos">75 (6%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>33 (6%) I regularly use this language</li>
<li>33 (6%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">18 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>68 (7%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">23 (7%) I know many other people who use this language</li>
<li>27 (7%) I use many applications written in this language</li>
<li>63 (7%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>55 (8%) I often get angry when writing code in this language</li>
<li class="supNeg">9 (8%) It is easy to debug programs written in this language when it goes wrong</li>
<li>39 (8%) This language is frequently used for applications it isn't suitable for</li>
<li>53 (8%) Learning this language significantly changed how I use other languages.</li>
<li>38 (8%) I know this language well</li>
<li>58 (8%) This language has an annoying syntax</li>
<li>38 (8%) This language has a very dogmatic community</li>
<li class="supNeg">10 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">23 (8%) I would use this language to write a command-line app</li>
<li class="supNeg">19 (8%) Programs written in this language tend to play well with others</li>
<li>71 (8%) This language is unusually bad for beginners</li>
<li>36 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (9%) There are many good open-source tools for this language</li>
<li>40 (9%) I would like to write more of this language than I currently do</li>
<li>31 (9%) I would use this language for mobile applications</li>
<li class="supNeg">10 (9%) I would use this language for writing server programs</li>
<li>27 (9%) This language has many features which feel "tacked on"</li>
<li>52 (9%) It's unusual for me to discover unfamiliar features</li>
<li>61 (9%) I often feel like I am not smart enough to write this language</li>
<li>34 (9%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">8 (9%) This language excels at text processing</li>
</ul>
<ul>
<li class="supNeg">19 (1%) This language is good for distributed computing</li>
<li>45 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">24 (4%) This language has a strong static type system</li>
<li class="supNeg">15 (4%) This is a low level language</li>
<li class="supNeg">19 (4%) This language excels at text processing</li>
<li class="supPos">84 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">9 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">23 (5%) I would use this language for a web project</li>
<li>52 (5%) Code written in this language is very readable</li>
<li>33 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li>44 (5%) This language is best for very small projects</li>
<li>34 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>50 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li>56 (6%) This language is unusually bad for beginners</li>
<li>44 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>28 (6%) This language excels at concurrency</li>
<li>39 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>36 (7%) This language is likely to have a strong influence on future languages</li>
<li>46 (7%) I would like to write more of this language than I currently do</li>
<li>58 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>48 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>35 (7%) Writing code in this language is a lot of work</li>
<li>43 (7%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">24 (8%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">77 (8%) I find this language easy to prototype in</li>
<li>45 (8%) This language is likely to be a passing fad</li>
<li>52 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>41 (8%) This language has a very dogmatic community</li>
<li>38 (8%) I learned this language early in my career as a programmer</li>
<li>57 (8%) This language has an annoying syntax</li>
<li class="supPos">86 (9%) This is a high level language</li>
<li>39 (9%) This language would be good for teaching children to write software</li>
<li>70 (9%) This language has a niche in which it is great</li>
<li>33 (9%) I would list this language on my resume</li>
<li>32 (9%) There is a wide variety of open source code written in this language</li>
<li>38 (9%) This language is good for beginners</li>
<li class="supNeg">18 (9%) I would use this language for mobile applications</li>
<li>25 (9%) I enjoy using this language</li>
<li class="supNeg">11 (9%) I would use this language for writing server programs</li>
<li>45 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>38 (9%) This language is likely to be around for a very long time</li>
<li>52 (9%) I would use this language for casual scripting</li>
<li>48 (9%) This language encourages writing reusable code.</li>
</ul>
<ul></ul>
<ul></ul>
</div>
k-means with k = 13
<tabled class="data" id="clusters13">
  <trd>
    <tdd>C#,5.0</tdd>
    <tdd>Objective C,5.0</tdd>
  </trd>
  <trd>
    <tdd>R,5.0</tdd>
    <tdd>Mathematica,5.0</tdd>
    <tdd>Matlab,6.0</tdd>
    <tdd>J,8.0</tdd>
  </trd>
  <trd>
    <tdd>Delphi,5.0</tdd>
    <tdd>Pascal,5.0</tdd>
    <tdd>Fortran,6.0</tdd>
    <tdd>Ada,8.0</tdd>
    <tdd>Cobol,8.0</tdd>
  </trd>
  <trd>
    <tdd>Go,5.0</tdd>
    <tdd>D,6.0</tdd>
    <tdd>Groovy,6.0</tdd>
    <tdd>Haxe,6.0</tdd>
    <tdd>Lua,7.0</tdd>
    <tdd>Eiffel,8.0</tdd>
    <tdd>Io,8.0</tdd>
    <tdd>Erlang,9.0</tdd>
  </trd>
  <trd>
    <tdd>Assembler,0.0</tdd>
  </trd>
  <trd>
    <tdd>PHP,6.0</tdd>
    <tdd>TCL,6.0</tdd>
    <tdd>Javascript,7.0</tdd>
    <tdd>Perl,7.0</tdd>
    <tdd>Shell,7.0</tdd>
    <tdd>Visual Basic,8.0</tdd>
  </trd>
  <trd>
    <tdd>Prolog,6.0</tdd>
    <tdd>ELisp,7.0</tdd>
    <tdd>Factor,7.0</tdd>
    <tdd>APL,7.0</tdd>
    <tdd>Forth,8.0</tdd>
    <tdd>Mozart-Oz,8.0</tdd>
    <tdd>AWK,9.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,7.0</tdd>
    <tdd>Agda,7.0</tdd>
  </trd>
  <trd>
    <tdd>Java,0.0</tdd>
  </trd>
  <trd>
    <tdd>Clojure,5.0</tdd>
    <tdd>F#,6.0</tdd>
    <tdd>Scala,6.0</tdd>
    <tdd>Python,7.0</tdd>
    <tdd>Ruby,7.0</tdd>
  </trd>
  <trd>
    <tdd>ActionScript,0.0</tdd>
  </trd>
  <trd>
    <tdd>Common Lisp,6.0</tdd>
    <tdd>Smalltalk,6.0</tdd>
    <tdd>O'Caml,6.0</tdd>
    <tdd>Scheme,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Haskell,9.0</tdd>
    <tdd>REBOL,12.0</tdd>
  </trd>
  <trd>
    <tdd>C,6.0</tdd>
    <tdd>C++,6.0</tdd>
  </trd>
</tabled>
<div class="support" id="support13">
<ul>
<li>51 (0%) This language has a very coherent design</li>
<li>26 (0%) I would use this language as a scripting language embedded inside a larger application</li>
<li>72 (0%) I use this language out of choice</li>
<li>47 (0%) There is a wide variety of open source code written in this language</li>
<li>36 (0%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>57 (0%) This language is good for scientific computing</li>
<li>46 (0%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>50 (0%) I regularly use this language</li>
<li>48 (0%) This language is likely to have a strong influence on future languages</li>
<li>61 (1%) There is a lot of accidental complexity when writing code in this language</li>
<li>46 (1%) I am reluctant to admit to knowing this language</li>
<li>40 (1%) This language is very flexible</li>
<li>45 (1%) I would like to write more of this language than I currently do</li>
<li>42 (1%) This language matches it's problem domain particularly well.</li>
<li class="supPos">76 (1%) I use many applications written in this language</li>
<li class="supNeg">24 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>36 (1%) This language has unusual features that I often miss when using other languages</li>
<li>36 (1%) Learning this language improved my ability as a programmer</li>
<li>68 (2%) Code written in this language tends to be verbose</li>
<li class="supPos">89 (2%) I would use this language for mobile applications</li>
<li>42 (2%) I find code written in this language very elegant</li>
<li>25 (2%) When I write code in this language I can be very sure it is correct</li>
<li>63 (3%) This is a high level language</li>
<li>55 (3%) I still discover new features of this language on a fairly regular basis</li>
<li>65 (3%) This language has a good community</li>
<li class="supPos">86 (3%) This language encourages writing reusable code.</li>
<li>51 (3%) I usually use this language on solo projects</li>
<li>53 (4%) Programs written in this language tend to be efficient</li>
<li>69 (4%) This language has many features which feel "tacked on"</li>
<li>39 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>37 (4%) This language excels at symbolic manipulation</li>
<li>39 (4%) I would use this language for writing programs for an embedded hardware platform</li>
<li>57 (4%) Code written in this language is very readable</li>
<li>41 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>58 (4%) This language has a strong static type system</li>
<li>32 (4%) This language excels at concurrency</li>
<li>68 (5%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>44 (5%) This language is expressive</li>
<li>47 (5%) I can imagine this will be a popular language in twenty years time</li>
<li>36 (5%) Learning this language significantly changed how I use other languages.</li>
<li>44 (5%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>73 (5%) I would list this language on my resume</li>
<li>30 (5%) Code written in this language tends to be terse</li>
<li>38 (5%) There are many good open-source tools for this language</li>
<li>40 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">21 (5%) This language is minimal</li>
<li>58 (5%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>66 (5%) Programs written in this language will usually work in future versions of the language</li>
<li class="supPos">80 (5%) I find it easy to write efficient code in this language</li>
<li>70 (6%) Developers who primarily use this language often burn out after a few years</li>
<li class="supPos">78 (6%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supPos">87 (7%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>41 (7%) This language is good for distributed computing</li>
<li class="supPos">88 (7%) I would use this language for a desktop GUI project</li>
<li class="supNeg">17 (7%) This language is best for very small projects</li>
<li>46 (7%) This is a low level language</li>
<li>71 (8%) There are many good tools for this language</li>
<li>60 (8%) This language has a very dogmatic community</li>
<li>40 (8%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>48 (8%) I would use this language for casual scripting</li>
<li>47 (8%) This language has an annoying syntax</li>
<li>56 (9%) This language makes it easy to shoot yourself in the foot</li>
<li>53 (9%) This language is suitable for real-time applications</li>
<li>44 (9%) I would use this language for writing embedded programs</li>
<li>40 (9%) Writing code in this language is a lot of work</li>
<li>50 (9%) I can imagine using this language in my day job</li>
</ul>
<ul>
<li class="supNeg">20 (1%) This language is good for distributed computing</li>
<li>46 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>54 (3%) Code written in this language is very readable</li>
<li>52 (3%) This language is large</li>
<li>61 (3%) This language has an annoying syntax</li>
<li class="supNeg">23 (4%) This language has a strong static type system</li>
<li class="supNeg">21 (4%) I would use this language for a web project</li>
<li class="supPos">80 (4%) I find this language easy to prototype in</li>
<li class="supNeg">16 (4%) This is a low level language</li>
<li class="supNeg">18 (5%) This language excels at text processing</li>
<li class="supPos">90 (5%) This language is good for numeric computing</li>
<li>32 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">85 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li>56 (5%) I would use this language for casual scripting</li>
<li class="supNeg">8 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li>56 (5%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>32 (5%) Writing code in this language is a lot of work</li>
<li>51 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li>45 (6%) This language is best for very small projects</li>
<li>41 (6%) This language has a very rigid idea of how things should be done</li>
<li>48 (6%) I usually use this language on solo projects</li>
<li>55 (6%) This language is unusually bad for beginners</li>
<li>30 (6%) This language excels at concurrency</li>
<li class="supPos">89 (6%) This language is good for scientific computing</li>
<li>34 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>42 (6%) This language is good for beginners</li>
<li>37 (6%) I use many applications written in this language</li>
<li>39 (7%) I can imagine this will be a popular language in twenty years time</li>
<li>44 (7%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">8 (7%) I would use this language for writing server programs</li>
<li>41 (7%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">83 (7%) This is a high level language</li>
<li>48 (7%) This language is likely to be a passing fad</li>
<li>31 (7%) I usually use this language on projects with many other members</li>
<li class="supPos">87 (7%) This language matches it's problem domain particularly well.</li>
<li>35 (7%) This language is likely to have a strong influence on future languages</li>
<li>26 (7%) When I write code in this language I can be very sure it is correct</li>
<li>44 (7%) I would like to write more of this language than I currently do</li>
<li>52 (7%) This language encourages writing reusable code.</li>
<li>42 (8%) This language would be good for teaching children to write software</li>
<li class="supNeg">22 (8%) I enjoy using this language</li>
<li>50 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>59 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>36 (8%) I learned this language early in my career as a programmer</li>
<li>53 (8%) This language has many features which feel "tacked on"</li>
<li>53 (9%) This language has a good community</li>
<li>36 (9%) I would list this language on my resume</li>
<li class="supNeg">22 (9%) I can imagine using this language in my day job</li>
<li>71 (9%) This language has a niche in which it is great</li>
<li>35 (9%) Programs written in this language tend to be efficient</li>
<li>41 (9%) This language has a very dogmatic community</li>
<li>61 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>33 (9%) There is a wide variety of open source code written in this language</li>
</ul>
<ul>
<li>46 (2%) This language has a very coherent design</li>
<li>49 (4%) It is easy to tell at a glance what code in this language does</li>
<li>28 (4%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">14 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li>54 (4%) Code written in this language is very readable</li>
<li class="supNeg">14 (5%) I can imagine this will be a popular language in twenty years time</li>
<li>27 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>32 (5%) I use many applications written in this language</li>
<li>69 (5%) Developers who primarily use this language often burn out after a few years</li>
<li>44 (5%) This is a mainstream language</li>
<li>39 (5%) There are many good tools for this language</li>
<li class="supNeg">24 (6%) I would use this language for casual scripting</li>
<li>45 (6%) This is a low level language</li>
<li class="supNeg">10 (6%) I usually use this language on solo projects</li>
<li>54 (6%) I know this language well</li>
<li>56 (6%) This language has many features which feel "tacked on"</li>
<li class="supNeg">18 (7%) I often feel like I am not smart enough to write this language</li>
<li>51 (7%) There are many good commercial tools for this language</li>
<li class="supNeg">13 (7%) This language is best for very small projects</li>
<li class="supNeg">10 (7%) I still discover new features of this language on a fairly regular basis</li>
<li>65 (8%) I often get angry when writing code in this language</li>
<li>55 (8%) This is a high level language</li>
<li class="supNeg">17 (8%) This language excels at text processing</li>
<li>62 (8%) Programs written in this language will usually work in future versions of the language</li>
<li>41 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>28 (9%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">22 (9%) This language excels at symbolic manipulation</li>
<li>34 (9%) I know many other people who use this language</li>
<li class="supNeg">12 (9%) I can imagine using this language in my day job</li>
<li>41 (9%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">12 (9%) I enjoy using this language</li>
</ul>
<ul>
<li>59 (3%) This language is expressive</li>
<li>59 (5%) I find code written in this language very elegant</li>
<li>67 (6%) I use this language out of choice</li>
<li>37 (6%) I can imagine using this language in my day job</li>
<li>28 (6%) Writing code in this language is a lot of work</li>
<li>53 (7%) I would use this language for a desktop GUI project</li>
<li>36 (7%) I enjoy using this language</li>
<li>34 (8%) I am reluctant to admit to knowing this language</li>
<li>34 (8%) This is a mainstream language</li>
<li>72 (8%) This is a high level language</li>
<li>39 (8%) Libraries in this language tend to be well documented.</li>
<li>57 (8%) Programs written in this language tend to play well with others</li>
<li>54 (8%) The resources for learning this language are of high quality</li>
<li>70 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>27 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>40 (9%) This language is frequently used for applications it isn't suitable for</li>
<li>35 (9%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>39 (9%) This language makes it easy to shoot yourself in the foot</li>
<li>44 (9%) This language is unusually bad for beginners</li>
<li>41 (9%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>60 (9%) This language has a good community</li>
<li>38 (9%) Code written in this language tends to be terse</li>
<li>26 (9%) I often feel like I am not smart enough to write this language</li>
<li>43 (9%) This language excels at text processing</li>
<li>48 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">76 (9%) I find this language easy to prototype in</li>
<li>40 (9%) There are many good commercial tools for this language</li>
</ul>
<ul></ul>
<ul>
<li class="supNeg">20 (2%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>33 (2%) This is a low level language</li>
<li>32 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>37 (3%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (3%) This language excels at concurrency</li>
<li>68 (4%) This is a high level language</li>
<li class="supNeg">11 (4%) When I write code in this language I can be very sure it is correct</li>
<li>29 (4%) This language is suitable for real-time applications</li>
<li>42 (5%) I find it easy to write efficient code in this language</li>
<li class="supNeg">15 (6%) This language is good for distributed computing</li>
<li>60 (6%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">21 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>72 (6%) I find this language easy to prototype in</li>
<li>62 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li>35 (7%) Writing code in this language is a lot of work</li>
<li>58 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">22 (8%) I can imagine using this language in my day job</li>
<li class="supNeg">14 (8%) This language has a strong static type system</li>
<li>38 (8%) This language encourages writing reusable code.</li>
<li>37 (8%) This language has a very dogmatic community</li>
<li>43 (9%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">15 (9%) Code written in this language tends to be very reliable</li>
<li>46 (9%) This language has a high quality implementation</li>
<li>40 (9%) This language is good for beginners</li>
<li>51 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">18 (9%) This language is good for numeric computing</li>
</ul>
<ul>
<li>58 (3%) I use this language out of choice</li>
<li>38 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>28 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>41 (6%) Code written in this language is very readable</li>
<li>45 (6%) I often get angry when writing code in this language</li>
<li>45 (6%) The resources for learning this language are of high quality</li>
<li>31 (6%) There are many good commercial tools for this language</li>
<li class="supNeg">17 (7%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>41 (7%) This language is well documented</li>
<li>39 (7%) This language has many features which feel "tacked on"</li>
<li class="supNeg">12 (7%) I can imagine this will be a popular language in twenty years time</li>
<li>40 (7%) This language has a very dogmatic community</li>
<li>67 (8%) I find this language easy to prototype in</li>
<li class="supNeg">20 (8%) When I write code in this language I can be very sure it is correct</li>
<li>39 (8%) I am reluctant to admit to knowing this language</li>
<li>41 (8%) I would use this language as a scripting language embedded inside a larger application</li>
<li>40 (8%) Code written in this language tends to be very reliable</li>
<li>31 (8%) I would use this language for a web project</li>
<li>52 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>30 (8%) I would use this language for mobile applications</li>
<li>29 (8%) This language is good for beginners</li>
<li>47 (9%) I would like to write more of this language than I currently do</li>
<li>50 (9%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">10 (9%) I can imagine using this language in my day job</li>
<li>38 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">20 (9%) This language is best for very large projects</li>
</ul>
<ul>
<li>35 (0%) I would use this language for writing embedded programs</li>
<li class="supNeg">0 (0%) This is a mainstream language</li>
<li>69 (0%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">20 (0%) This language excels at concurrency</li>
<li class="supNeg">20 (1%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">21 (1%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">20 (1%) I can imagine using this language in my day job</li>
<li>52 (1%) Code written in this language is very readable</li>
<li>58 (1%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>68 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>61 (1%) This language excels at symbolic manipulation</li>
<li class="supPos">79 (1%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">97 (2%) Learning this language improved my ability as a programmer</li>
<li>47 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">83 (2%) I use this language out of choice</li>
<li>30 (2%) This language is best for very large projects</li>
<li class="supPos">97 (2%) I often feel like I am not smart enough to write this language</li>
<li>53 (2%) I enjoy using this language</li>
<li>54 (2%) Writing code in this language is a lot of work</li>
<li class="supNeg">15 (3%) This language is good for distributed computing</li>
<li class="supNeg">16 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">17 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">23 (3%) This language is good for numeric computing</li>
<li class="supPos">81 (3%) This language has a very coherent design</li>
<li>32 (3%) This language is large</li>
<li class="supPos">95 (4%) When I write code in this language I can be very sure it is correct</li>
<li>29 (4%) I regularly use this language</li>
<li class="supPos">95 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">4 (4%) Programs written in this language tend to be efficient</li>
<li>40 (4%) This language is well documented</li>
<li class="supPos">95 (4%) This language has a strong static type system</li>
<li class="supPos">82 (4%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>64 (4%) I would like to write more of this language than I currently do</li>
<li class="supNeg">15 (4%) Programs written in this language tend to play well with others</li>
<li class="supPos">94 (5%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">81 (5%) This language has a niche outside of which I would not use it</li>
<li class="supNeg">5 (5%) This is a low level language</li>
<li class="supNeg">5 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>58 (5%) This language is likely to be a passing fad</li>
<li>57 (5%) This language is good for scientific computing</li>
<li>39 (5%) This language has a good library distribution mechanism.</li>
<li>74 (5%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">89 (5%) This is a high level language</li>
<li class="supNeg">19 (5%) There are many good tools for this language</li>
<li>67 (6%) This language encourages writing reusable code.</li>
<li>58 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li>46 (6%) This language has an annoying syntax</li>
<li class="supNeg">8 (6%) I often get angry when writing code in this language</li>
<li class="supNeg">22 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">7 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">80 (8%) I find code written in this language very elegant</li>
<li class="supNeg">13 (8%) I use many applications written in this language</li>
<li>55 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>44 (8%) Code written in this language tends to be verbose</li>
<li class="supPos">84 (8%) This language is expressive</li>
<li class="supNeg">9 (9%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">24 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">22 (9%) Libraries in this language tend to be well documented.</li>
<li>49 (9%) I know this language well</li>
<li class="supNeg">10 (9%) I would use this language for writing server programs</li>
</ul>
<ul></ul>
<ul>
<li class="supNeg">19 (2%) This is a low level language</li>
<li class="supPos">89 (4%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">87 (4%) This is a high level language</li>
<li>52 (4%) Learning this language significantly changed how I use other languages.</li>
<li>74 (5%) I would use this language for a desktop GUI project</li>
<li class="supPos">91 (5%) I find this language easy to prototype in</li>
<li>27 (5%) Code written in this language tends to be verbose</li>
<li>38 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>27 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>31 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">94 (5%) I use this language out of choice</li>
<li class="supNeg">21 (6%) I learned this language early in my career as a programmer</li>
<li class="supNeg">23 (6%) This language has a niche in which it is great</li>
<li>68 (6%) Programs written in this language tend to play well with others</li>
<li>54 (6%) Code written in this language tends to be terse</li>
<li>72 (6%) I find code written in this language very elegant</li>
<li class="supNeg">19 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">75 (7%) This language is likely to have a strong influence on future languages</li>
<li>32 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>50 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">77 (7%) This language encourages writing code that is easy to maintain.</li>
<li>69 (7%) This language has a very coherent design</li>
<li>37 (8%) Developers who primarily use this language often burn out after a few years</li>
<li class="supPos">86 (8%) I would use this language to write a command-line app</li>
<li class="supPos">88 (8%) This language encourages writing reusable code.</li>
<li class="supNeg">18 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>56 (8%) There are many good commercial tools for this language</li>
<li class="supNeg">13 (8%) Writing code in this language is a lot of work</li>
<li>31 (8%) I would use this language for writing embedded programs</li>
<li class="supPos">84 (8%) This language is expressive</li>
<li class="supPos">85 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">21 (9%) I am reluctant to admit to knowing this language</li>
<li>68 (9%) I would use this language for mobile applications</li>
<li>67 (9%) This language excels at symbolic manipulation</li>
<li>61 (9%) There are many good tools for this language</li>
<li>71 (9%) I still discover new features of this language on a fairly regular basis</li>
<li>37 (9%) When I write code in this language I can be very sure it is correct</li>
<li>51 (9%) This language matches it's problem domain particularly well.</li>
<li class="supPos">76 (9%) I would list this language on my resume</li>
</ul>
<ul></ul>
<ul>
<li>32 (3%) This language excels at concurrency</li>
<li class="supNeg">21 (4%) This is a low level language</li>
<li>30 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>30 (5%) I usually use this language on projects with many other members</li>
<li>35 (6%) I use many applications written in this language</li>
<li>34 (7%) This language is good for distributed computing</li>
<li class="supPos">84 (7%) This is a high level language</li>
<li>57 (7%) I would use this language for casual scripting</li>
<li>39 (7%) There is a wide variety of open source code written in this language</li>
<li class="supPos">78 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">21 (7%) Writing code in this language is a lot of work</li>
<li>74 (7%) I use this language out of choice</li>
<li>25 (8%) I can imagine using this language in my day job</li>
<li class="supNeg">13 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>42 (8%) I would use this language for writing server programs</li>
<li>27 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>41 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>59 (9%) The semantics of this language are much different than other languages I know.</li>
<li>48 (9%) There are many good open-source tools for this language</li>
<li>68 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li>40 (9%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supNeg">20 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li>69 (9%) This language has unusual features that I often miss when using other languages</li>
<li class="supPos">82 (9%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>37 (9%) I would use this language for writing embedded programs</li>
<li class="supPos">82 (9%) This language is expressive</li>
<li>49 (9%) I would use this language for a desktop GUI project</li>
<li class="supPos">80 (9%) I find this language easy to prototype in</li>
<li class="supPos">82 (9%) I find code written in this language very elegant</li>
<li>36 (9%) This language has many features which feel "tacked on"</li>
</ul>
<ul>
<li>55 (0%) I can imagine this will be a popular language in twenty years time</li>
<li>73 (0%) This language is good for numeric computing</li>
<li class="supNeg">18 (0%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">78 (0%) I usually use this language on projects with many other members</li>
<li>43 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>39 (0%) I would like to write more of this language than I currently do</li>
<li>55 (0%) Libraries in this language tend to be well documented.</li>
<li class="supPos">77 (0%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">87 (0%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">82 (0%) There are many good open-source tools for this language</li>
<li class="supPos">98 (1%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supPos">98 (1%) I find it easy to write efficient code in this language</li>
<li class="supNeg">4 (1%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">86 (1%) There are many good commercial tools for this language</li>
<li class="supPos">76 (1%) There are many good tools for this language</li>
<li class="supPos">88 (1%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>47 (2%) I often feel like I am not smart enough to write this language</li>
<li>56 (2%) This language has a strong static type system</li>
<li class="supPos">97 (2%) I use many applications written in this language</li>
<li class="supPos">93 (2%) This language has a high quality implementation</li>
<li>39 (2%) I would use this language for casual scripting</li>
<li>44 (2%) I find this language easy to prototype in</li>
<li class="supPos">87 (2%) This is a mainstream language</li>
<li class="supNeg">7 (2%) I am reluctant to admit to knowing this language</li>
<li>36 (2%) This language has a very coherent design</li>
<li>43 (3%) This language has a very dogmatic community</li>
<li class="supPos">85 (3%) I know many other people who use this language</li>
<li>31 (3%) This language has a niche outside of which I would not use it</li>
<li class="supPos">84 (3%) Programs written in this language tend to be efficient</li>
<li>33 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>60 (3%) I would use this language for mobile applications</li>
<li class="supPos">92 (3%) Learning this language improved my ability as a programmer</li>
<li>47 (3%) This language has a good library distribution mechanism.</li>
<li class="supNeg">21 (3%) This language excels at concurrency</li>
<li>37 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">78 (4%) The resources for learning this language are of high quality</li>
<li class="supPos">95 (4%) This language is suitable for real-time applications</li>
<li>33 (4%) This language is well suited for an agile development approach using short iterations.</li>
<li>29 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">75 (4%) I know this language well</li>
<li>28 (4%) I find code written in this language very elegant</li>
<li>62 (4%) Writing code in this language is a lot of work</li>
<li class="supPos">95 (4%) Programs written in this language will usually work in future versions of the language</li>
<li>40 (4%) Learning this language significantly changed how I use other languages.</li>
<li>61 (4%) Code written in this language tends to be verbose</li>
<li>56 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>38 (4%) This language has a good community</li>
<li>28 (4%) This language excels at symbolic manipulation</li>
<li>41 (4%) It is easy to tell at a glance what code in this language does</li>
<li>36 (5%) I would use this language for a web project</li>
<li class="supNeg">19 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">5 (5%) I use this language out of choice</li>
<li>49 (5%) This language encourages writing code that is easy to maintain.</li>
<li>49 (6%) This is a high level language</li>
<li>69 (6%) This language is best for very large projects</li>
<li class="supPos">78 (6%) I would use this language to write a command-line app</li>
<li class="supPos">93 (6%) There is a wide variety of open source code written in this language</li>
<li>45 (6%) Code written in this language is very readable</li>
<li>57 (6%) I often get angry when writing code in this language</li>
<li>68 (6%) This language is good for scientific computing</li>
<li>34 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (7%) I enjoy using this language</li>
<li>34 (7%) Code written in this language tends to be very reliable</li>
<li class="supPos">82 (7%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>73 (8%) This language is very flexible</li>
<li>69 (8%) This is a low level language</li>
<li>31 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">91 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>27 (8%) This language excels at text processing</li>
<li>41 (8%) Code written in this language tends to be terse</li>
<li>46 (8%) I would use this language for writing server programs</li>
<li class="supPos">83 (9%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">90 (9%) This language is likely to be around for a very long time</li>
</ul>
</div>
k-means with k = 14
<tabled class="data" id="clusters14">
  <trd>
    <tdd>F#,5.0</tdd>
    <tdd>Scala,5.0</tdd>
    <tdd>Clojure,5.0</tdd>
    <tdd>Haskell,7.0</tdd>
  </trd>
  <trd>
    <tdd>Io,6.0</tdd>
    <tdd>Scheme,7.0</tdd>
    <tdd>REBOL,8.0</tdd>
  </trd>
  <trd>
    <tdd>C#,4.0</tdd>
    <tdd>Java,6.0</tdd>
    <tdd>Python,8.0</tdd>
  </trd>
  <trd>
    <tdd>Fortran,5.0</tdd>
    <tdd>Pascal,7.0</tdd>
    <tdd>Cobol,8.0</tdd>
    <tdd>Assembler,11.0</tdd>
  </trd>
  <trd>
    <tdd>PHP,4.0</tdd>
    <tdd>Visual Basic,4.0</tdd>
  </trd>
  <trd>
    <tdd>C,6.0</tdd>
    <tdd>C++,6.0</tdd>
  </trd>
  <trd>
    <tdd>O'Caml,6.0</tdd>
    <tdd>Go,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>D,7.0</tdd>
    <tdd>Factor,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>Erlang,8.0</tdd>
    <tdd>J,8.0</tdd>
  </trd>
  <trd>
    <tdd>Objective C,6.0</tdd>
    <tdd>Delphi,6.0</tdd>
    <tdd>Ada,7.0</tdd>
    <tdd>Eiffel,7.0</tdd>
    <tdd>ActionScript,10.0</tdd>
  </trd>
  <trd>
    <tdd>Groovy,5.0</tdd>
    <tdd>Javascript,7.0</tdd>
    <tdd>Lua,7.0</tdd>
    <tdd>Ruby,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
    <tdd>Perl,8.0</tdd>
  </trd>
  <trd>
    <tdd>Smalltalk,0.0</tdd>
  </trd>
  <trd>
    <tdd>APL,5.0</tdd>
    <tdd>Prolog,5.0</tdd>
    <tdd>Forth,7.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,7.0</tdd>
    <tdd>Agda,7.0</tdd>
  </trd>
  <trd>
    <tdd>ELisp,6.0</tdd>
    <tdd>TCL,6.0</tdd>
    <tdd>R,6.0</tdd>
    <tdd>Matlab,6.0</tdd>
    <tdd>AWK,7.0</tdd>
    <tdd>Shell,8.0</tdd>
    <tdd>Mathematica,8.0</tdd>
  </trd>
</tabled>
<div class="support" id="support14">
<ul>
<li class="supPos">96 (2%) This language encourages writing reusable code.</li>
<li>71 (2%) I would use this language for casual scripting</li>
<li class="supNeg">17 (2%) This is a low level language</li>
<li class="supNeg">18 (2%) I learned this language early in my career as a programmer</li>
<li class="supNeg">10 (3%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">94 (3%) I use this language out of choice</li>
<li>58 (3%) This language matches it's problem domain particularly well.</li>
<li class="supPos">83 (3%) This language is likely to have a strong influence on future languages</li>
<li>66 (3%) This language has a good library distribution mechanism.</li>
<li>25 (3%) Code written in this language tends to be verbose</li>
<li>69 (3%) Code written in this language is very readable</li>
<li class="supNeg">15 (3%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">88 (3%) I find this language easy to prototype in</li>
<li>45 (3%) This language is well documented</li>
<li>56 (3%) This language excels at text processing</li>
<li>74 (4%) This language has a very coherent design</li>
<li class="supPos">91 (4%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">19 (4%) Writing code in this language is a lot of work</li>
<li>42 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>56 (4%) This language is suitable for real-time applications</li>
<li>40 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>41 (5%) I use many applications written in this language</li>
<li>33 (5%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">92 (5%) This is a high level language</li>
<li>39 (5%) This language is good for beginners</li>
<li>66 (5%) Programs written in this language tend to play well with others</li>
<li>40 (5%) This is a mainstream language</li>
<li>53 (5%) Programs written in this language tend to be efficient</li>
<li>30 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">23 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>47 (6%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>41 (6%) I know many other people who use this language</li>
<li class="supPos">91 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>69 (6%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">24 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>60 (7%) Code written in this language tends to be terse</li>
<li>58 (7%) This language is good for distributed computing</li>
<li>33 (7%) Developers who primarily use this language often burn out after a few years</li>
<li class="supPos">90 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>51 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li>70 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>34 (7%) I would use this language for writing embedded programs</li>
<li>59 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">76 (7%) This language has a high quality implementation</li>
<li>68 (8%) I enjoy using this language</li>
<li class="supNeg">11 (8%) I am reluctant to admit to knowing this language</li>
<li>60 (8%) Libraries in this language tend to be well documented.</li>
<li>48 (8%) I regularly use this language</li>
<li>73 (8%) This language excels at symbolic manipulation</li>
<li>56 (8%) There are many good tools for this language</li>
<li>42 (8%) This language has a very dogmatic community</li>
<li class="supPos">89 (8%) This language is expressive</li>
<li>51 (8%) This language would be good for teaching children to write software</li>
<li>47 (8%) This language is best for very small projects</li>
<li>49 (8%) This language is likely to be around for a very long time</li>
<li class="supPos">85 (9%) I would use this language to write a command-line app</li>
<li>26 (9%) I often get angry when writing code in this language</li>
<li class="supNeg">15 (9%) This language has a niche outside of which I would not use it</li>
<li>66 (9%) I would use this language for a desktop GUI project</li>
<li>65 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>47 (9%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supPos">78 (9%) This language has unusual features that I often miss when using other languages</li>
</ul>
<ul>
<li>34 (2%) This language is frequently used for applications it isn't suitable for</li>
<li>67 (2%) I would use this language to write a command-line app</li>
<li>33 (2%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>27 (2%) This language is good for distributed computing</li>
<li>49 (2%) I would use this language for a desktop GUI project</li>
<li>28 (2%) This language excels at concurrency</li>
<li>38 (2%) I would use this language for writing embedded programs</li>
<li>55 (3%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>48 (3%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supNeg">21 (3%) I can imagine using this language in my day job</li>
<li class="supNeg">17 (3%) This language has a strong static type system</li>
<li>46 (3%) This language is good for numeric computing</li>
<li>27 (3%) When I write code in this language I can be very sure it is correct</li>
<li>74 (4%) I find this language easy to prototype in</li>
<li>61 (4%) This language has a good community</li>
<li>69 (4%) I use this language out of choice</li>
<li class="supPos">93 (4%) This language has a very coherent design</li>
<li class="supNeg">21 (4%) This is a low level language</li>
<li class="supNeg">16 (4%) Writing code in this language is a lot of work</li>
<li class="supPos">79 (4%) This is a high level language</li>
<li>36 (5%) There is a wide variety of open source code written in this language</li>
<li>32 (5%) Libraries in this language tend to be well documented.</li>
<li>53 (5%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>39 (5%) This language has a good library distribution mechanism.</li>
<li class="supNeg">20 (6%) Code written in this language tends to be verbose</li>
<li class="supNeg">22 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supPos">87 (6%) This language is very flexible</li>
<li class="supNeg">23 (6%) I usually use this language on projects with many other members</li>
<li>73 (6%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supPos">88 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li>43 (6%) Programs written in this language will usually work in future versions of the language</li>
<li>34 (6%) This language is well documented</li>
<li>34 (6%) This language has many features which feel "tacked on"</li>
<li class="supNeg">9 (6%) I often get angry when writing code in this language</li>
<li class="supPos">79 (6%) I find code written in this language very elegant</li>
<li>42 (6%) Developers who primarily use this language often burn out after a few years</li>
<li>59 (7%) The semantics of this language are much different than other languages I know.</li>
<li>65 (7%) I would use this language for casual scripting</li>
<li>28 (7%) I learned this language early in my career as a programmer</li>
<li>27 (8%) I would list this language on my resume</li>
<li>63 (8%) It is easy to tell at a glance what code in this language does</li>
<li>52 (8%) This language encourages writing code that is easy to maintain.</li>
<li>36 (8%) There are many good open-source tools for this language</li>
<li>28 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>43 (9%) This language is good for scientific computing</li>
<li>32 (9%) I would use this language for writing server programs</li>
<li>36 (9%) I often feel like I am not smart enough to write this language</li>
<li>31 (9%) There are many good commercial tools for this language</li>
<li>53 (9%) I know this language well</li>
<li class="supNeg">20 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>39 (9%) This language is suitable for real-time applications</li>
<li>74 (9%) This language is expressive</li>
<li>44 (9%) This language makes it easy to shoot yourself in the foot</li>
</ul>
<ul>
<li class="supPos">81 (1%) This language encourages writing code that is easy to maintain.</li>
<li>33 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>39 (2%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>70 (2%) This language is likely to be around for a very long time</li>
<li class="supPos">82 (2%) This language encourages writing reusable code.</li>
<li>73 (3%) I would use this language for writing server programs</li>
<li>37 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">16 (3%) I often feel like I am not smart enough to write this language</li>
<li>52 (3%) I enjoy using this language</li>
<li class="supPos">75 (4%) Programs written in this language tend to play well with others</li>
<li>49 (4%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>59 (4%) This language is good for numeric computing</li>
<li>38 (4%) This language is likely to be a passing fad</li>
<li>32 (4%) This language excels at concurrency</li>
<li>44 (4%) Programs written in this language tend to be efficient</li>
<li>45 (5%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">23 (5%) This language is built on a small core of orthogonal features</li>
<li>42 (5%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>42 (5%) I would like to write more of this language than I currently do</li>
<li>35 (5%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">92 (5%) This language has a high quality implementation</li>
<li class="supPos">77 (5%) I use many applications written in this language</li>
<li>39 (5%) I would use this language for writing embedded programs</li>
<li>47 (5%) This language is good for distributed computing</li>
<li class="supPos">94 (5%) This language is well documented</li>
<li class="supPos">92 (5%) The resources for learning this language are of high quality</li>
<li class="supPos">83 (5%) I find this language easy to prototype in</li>
<li>70 (6%) This is a high level language</li>
<li>69 (6%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>60 (6%) I still discover new features of this language on a fairly regular basis</li>
<li>40 (7%) This language matches it's problem domain particularly well.</li>
<li class="supPos">91 (7%) It is easy to tell at a glance what code in this language does</li>
<li class="supPos">87 (7%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>30 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li>49 (7%) This language is suitable for real-time applications</li>
<li>69 (7%) This language has a very dogmatic community</li>
<li>32 (7%) This is a low level language</li>
<li>40 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">75 (7%) I know this language well</li>
<li>56 (8%) Code written in this language tends to be very reliable</li>
<li class="supPos">84 (8%) I would use this language for a desktop GUI project</li>
<li>60 (8%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">90 (8%) This is a mainstream language</li>
<li>69 (8%) It's unusual for me to discover unfamiliar features</li>
<li class="supPos">87 (8%) I would list this language on my resume</li>
<li class="supNeg">12 (8%) This language has a niche outside of which I would not use it</li>
<li>61 (9%) This language has a very coherent design</li>
<li class="supPos">79 (9%) I would use this language for a web project</li>
<li class="supPos">91 (9%) Libraries in this language tend to be well documented.</li>
<li class="supPos">87 (9%) I would use this language for mobile applications</li>
<li>72 (9%) This language has a good community</li>
</ul>
<ul>
<li class="supNeg">12 (2%) I can imagine this will be a popular language in twenty years time</li>
<li>45 (2%) This language has a very coherent design</li>
<li>39 (3%) The resources for learning this language are of high quality</li>
<li>32 (3%) I know many other people who use this language</li>
<li>43 (4%) This is a mainstream language</li>
<li class="supNeg">14 (4%) This language excels at symbolic manipulation</li>
<li class="supNeg">10 (4%) I would use this language for writing server programs</li>
<li>49 (4%) There are many good commercial tools for this language</li>
<li>31 (4%) I use many applications written in this language</li>
<li class="supNeg">7 (5%) I can imagine using this language in my day job</li>
<li>25 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>66 (5%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>68 (5%) I often get angry when writing code in this language</li>
<li class="supNeg">8 (5%) I still discover new features of this language on a fairly regular basis</li>
<li>71 (5%) Developers who primarily use this language often burn out after a few years</li>
<li>37 (6%) This language has a very dogmatic community</li>
<li class="supNeg">8 (6%) I would use this language as a scripting language embedded inside a larger application</li>
<li>54 (6%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">8 (7%) I enjoy using this language</li>
<li class="supNeg">9 (7%) This language is good for distributed computing</li>
<li class="supNeg">8 (7%) This language excels at text processing</li>
<li class="supNeg">10 (8%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">11 (8%) This language has a good community</li>
<li>41 (8%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supPos">85 (8%) I learned this language early in my career as a programmer</li>
<li>54 (8%) This language has a high quality implementation</li>
<li>59 (8%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">21 (9%) I usually use this language on projects with many other members</li>
<li>30 (9%) There are many good tools for this language</li>
<li>74 (9%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">12 (9%) This language is expressive</li>
</ul>
<ul>
<li class="supNeg">0 (0%) Learning this language significantly changed how I use other languages.</li>
<li>37 (0%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">20 (0%) This language excels at concurrency</li>
<li>54 (0%) Libraries in this language tend to be well documented.</li>
<li>44 (0%) I find it easy to write efficient code in this language</li>
<li class="supNeg">8 (0%) This language is built on a small core of orthogonal features</li>
<li>71 (0%) This language has an annoying syntax</li>
<li>55 (0%) Code written in this language is very readable</li>
<li>31 (0%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">3 (0%) I enjoy using this language</li>
<li>30 (0%) This language has a very dogmatic community</li>
<li>35 (0%) This language encourages writing reusable code.</li>
<li>35 (0%) Writing code in this language is a lot of work</li>
<li>30 (1%) This language is best for very large projects</li>
<li class="supNeg">11 (1%) Programs written in this language tend to be efficient</li>
<li class="supNeg">21 (1%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>30 (1%) Programs written in this language will usually work in future versions of the language</li>
<li class="supNeg">21 (1%) This language is good for numeric computing</li>
<li>65 (1%) I find this language easy to prototype in</li>
<li>27 (1%) This language is suitable for real-time applications</li>
<li>26 (1%) This language is expressive</li>
<li class="supNeg">14 (2%) I can imagine using this language in my day job</li>
<li>35 (2%) This is a low level language</li>
<li class="supPos">92 (2%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">12 (2%) This language is good for distributed computing</li>
<li class="supNeg">4 (2%) I would use this language for writing programs for an embedded hardware platform</li>
<li>25 (2%) I would use this language as a scripting language embedded inside a larger application</li>
<li>32 (2%) I would use this language to write a command-line app</li>
<li class="supPos">83 (2%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">4 (2%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">5 (2%) Learning this language improved my ability as a programmer</li>
<li class="supNeg">5 (2%) This language has unusual features that I often miss when using other languages</li>
<li>59 (2%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">8 (3%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">16 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>37 (3%) This language is likely to be around for a very long time</li>
<li>48 (3%) This language is good for beginners</li>
<li>62 (3%) I know this language well</li>
<li>64 (3%) There is a lot of accidental complexity when writing code in this language</li>
<li>44 (3%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">79 (3%) This language has many features which feel "tacked on"</li>
<li class="supNeg">10 (3%) I often feel like I am not smart enough to write this language</li>
<li>30 (3%) I would use this language for mobile applications</li>
<li>61 (3%) It is easy to tell at a glance what code in this language does</li>
<li>33 (4%) This language has a high quality implementation</li>
<li>52 (4%) This language is large</li>
<li>66 (4%) This is a high level language</li>
<li class="supNeg">4 (4%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>39 (4%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">16 (4%) This language is likely to have a strong influence on future languages</li>
<li>54 (4%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">14 (4%) I would use this language for writing embedded programs</li>
<li class="supNeg">4 (4%) Code written in this language tends to be very reliable</li>
<li>37 (5%) Programs written in this language tend to play well with others</li>
<li>69 (5%) There are many good commercial tools for this language</li>
<li>61 (5%) The resources for learning this language are of high quality</li>
<li>50 (5%) There are many good tools for this language</li>
<li class="supNeg">12 (5%) The semantics of this language are much different than other languages I know.</li>
<li>48 (5%) This language has a good library distribution mechanism.</li>
<li>62 (5%) This language is likely to be a passing fad</li>
<li class="supNeg">24 (5%) This language excels at symbolic manipulation</li>
<li>34 (5%) I use this language out of choice</li>
<li class="supNeg">18 (6%) Code written in this language tends to be terse</li>
<li>48 (6%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">20 (6%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>45 (6%) This language encourages writing code that is easy to maintain.</li>
<li>53 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li>38 (6%) This language is best for very small projects</li>
<li>59 (7%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">87 (7%) I often get angry when writing code in this language</li>
<li>48 (7%) This language excels at text processing</li>
<li class="supNeg">7 (7%) I would like to write more of this language than I currently do</li>
<li>45 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">88 (8%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supNeg">20 (8%) This language is good for scientific computing</li>
<li class="supNeg">12 (8%) I find code written in this language very elegant</li>
<li class="supPos">91 (8%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">15 (8%) I can imagine this will be a popular language in twenty years time</li>
<li>62 (9%) Code written in this language tends to be verbose</li>
<li class="supNeg">9 (9%) This language has a very coherent design</li>
<li>55 (9%) I would use this language for casual scripting</li>
<li class="supNeg">21 (9%) This language has a strong static type system</li>
<li>52 (9%) This language would be good for teaching children to write software</li>
</ul>
<ul>
<li>55 (0%) I can imagine this will be a popular language in twenty years time</li>
<li>73 (0%) This language is good for numeric computing</li>
<li class="supNeg">18 (0%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">78 (0%) I usually use this language on projects with many other members</li>
<li>43 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>39 (0%) I would like to write more of this language than I currently do</li>
<li>55 (0%) Libraries in this language tend to be well documented.</li>
<li class="supPos">77 (0%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">87 (0%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">82 (0%) There are many good open-source tools for this language</li>
<li class="supPos">98 (1%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supPos">98 (1%) I find it easy to write efficient code in this language</li>
<li class="supNeg">4 (1%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">86 (1%) There are many good commercial tools for this language</li>
<li class="supPos">76 (1%) There are many good tools for this language</li>
<li class="supPos">88 (1%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>47 (2%) I often feel like I am not smart enough to write this language</li>
<li>56 (2%) This language has a strong static type system</li>
<li class="supPos">97 (2%) I use many applications written in this language</li>
<li class="supPos">93 (2%) This language has a high quality implementation</li>
<li>39 (2%) I would use this language for casual scripting</li>
<li>44 (2%) I find this language easy to prototype in</li>
<li class="supPos">87 (2%) This is a mainstream language</li>
<li class="supNeg">7 (2%) I am reluctant to admit to knowing this language</li>
<li>36 (2%) This language has a very coherent design</li>
<li>43 (3%) This language has a very dogmatic community</li>
<li class="supPos">85 (3%) I know many other people who use this language</li>
<li>31 (3%) This language has a niche outside of which I would not use it</li>
<li class="supPos">84 (3%) Programs written in this language tend to be efficient</li>
<li>33 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>60 (3%) I would use this language for mobile applications</li>
<li class="supPos">92 (3%) Learning this language improved my ability as a programmer</li>
<li>47 (3%) This language has a good library distribution mechanism.</li>
<li class="supNeg">21 (3%) This language excels at concurrency</li>
<li>37 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">78 (4%) The resources for learning this language are of high quality</li>
<li class="supPos">95 (4%) This language is suitable for real-time applications</li>
<li>33 (4%) This language is well suited for an agile development approach using short iterations.</li>
<li>29 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">75 (4%) I know this language well</li>
<li>28 (4%) I find code written in this language very elegant</li>
<li>62 (4%) Writing code in this language is a lot of work</li>
<li class="supPos">95 (4%) Programs written in this language will usually work in future versions of the language</li>
<li>40 (4%) Learning this language significantly changed how I use other languages.</li>
<li>61 (4%) Code written in this language tends to be verbose</li>
<li>56 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>38 (4%) This language has a good community</li>
<li>28 (4%) This language excels at symbolic manipulation</li>
<li>41 (4%) It is easy to tell at a glance what code in this language does</li>
<li>36 (5%) I would use this language for a web project</li>
<li class="supNeg">19 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">5 (5%) I use this language out of choice</li>
<li>49 (5%) This language encourages writing code that is easy to maintain.</li>
<li>49 (6%) This is a high level language</li>
<li>69 (6%) This language is best for very large projects</li>
<li class="supPos">78 (6%) I would use this language to write a command-line app</li>
<li class="supPos">93 (6%) There is a wide variety of open source code written in this language</li>
<li>45 (6%) Code written in this language is very readable</li>
<li>57 (6%) I often get angry when writing code in this language</li>
<li>68 (6%) This language is good for scientific computing</li>
<li>34 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (7%) I enjoy using this language</li>
<li>34 (7%) Code written in this language tends to be very reliable</li>
<li class="supPos">82 (7%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>73 (8%) This language is very flexible</li>
<li>69 (8%) This is a low level language</li>
<li>31 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">91 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>27 (8%) This language excels at text processing</li>
<li>41 (8%) Code written in this language tends to be terse</li>
<li>46 (8%) I would use this language for writing server programs</li>
<li class="supPos">83 (9%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">90 (9%) This language is likely to be around for a very long time</li>
</ul>
<ul>
<li>64 (4%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>69 (6%) I use this language out of choice</li>
<li>34 (6%) This language has a very rigid idea of how things should be done</li>
<li>35 (6%) I often get angry when writing code in this language</li>
<li>36 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>71 (6%) This language has a very coherent design</li>
<li>55 (6%) I would use this language for casual scripting</li>
<li>34 (6%) I would use this language as a scripting language embedded inside a larger application</li>
<li>34 (7%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">79 (7%) This language encourages writing reusable code.</li>
<li>61 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li>64 (8%) This language has unusual features that I often miss when using other languages</li>
<li>35 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>36 (8%) There are many good commercial tools for this language</li>
<li>48 (8%) I usually use this language on solo projects</li>
<li>29 (8%) Writing code in this language is a lot of work</li>
<li>45 (9%) This language would be good for teaching children to write software</li>
<li>73 (9%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>47 (9%) I would use this language for a desktop GUI project</li>
<li class="supPos">75 (9%) This is a high level language</li>
<li>44 (9%) This language is minimal</li>
<li>37 (9%) There are many good open-source tools for this language</li>
<li class="supNeg">17 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>52 (9%) This language is unusually bad for beginners</li>
<li>43 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>53 (9%) Code written in this language is very readable</li>
<li>74 (9%) I find this language easy to prototype in</li>
<li>35 (9%) Libraries in this language tend to be well documented.</li>
</ul>
<ul>
<li>53 (1%) Programs written in this language tend to play well with others</li>
<li>27 (4%) This language excels at text processing</li>
<li>73 (4%) Code written in this language tends to be verbose</li>
<li>38 (5%) I would use this language for a web project</li>
<li>28 (5%) I enjoy using this language</li>
<li>37 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>37 (6%) This language is built on a small core of orthogonal features</li>
<li>41 (6%) This is a low level language</li>
<li>31 (6%) I can imagine using this language in my day job</li>
<li>25 (7%) Code written in this language tends to be terse</li>
<li>53 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>49 (7%) This language is expressive</li>
<li>45 (7%) This language has a good library distribution mechanism.</li>
<li>31 (8%) There is a wide variety of open source code written in this language</li>
<li>32 (8%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">23 (8%) I would use this language as a scripting language embedded inside a larger application</li>
<li>32 (8%) This language excels at concurrency</li>
<li>43 (8%) Writing code in this language is a lot of work</li>
<li>55 (8%) This language has many features which feel "tacked on"</li>
<li>47 (8%) I know this language well</li>
<li>52 (8%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>26 (8%) This language is good for distributed computing</li>
<li>25 (8%) There are many good open-source tools for this language</li>
<li>51 (8%) This language has a very dogmatic community</li>
<li>67 (8%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>50 (8%) This language is good for numeric computing</li>
<li>56 (9%) The resources for learning this language are of high quality</li>
<li>33 (9%) Learning this language significantly changed how I use other languages.</li>
<li>59 (9%) Code written in this language is very readable</li>
<li>36 (9%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">23 (9%) This language has a niche in which it is great</li>
<li>69 (9%) This language is best for very large projects</li>
<li>48 (9%) This language has a niche outside of which I would not use it</li>
<li>41 (9%) This language is likely to be around for a very long time</li>
<li>54 (9%) This language is large</li>
<li>48 (9%) There are many good tools for this language</li>
</ul>
<ul>
<li>43 (4%) This language has unusual features that I often miss when using other languages</li>
<li>28 (5%) This is a low level language</li>
<li>25 (5%) This language excels at concurrency</li>
<li class="supPos">77 (5%) This is a high level language</li>
<li>67 (5%) This language has a good community</li>
<li>51 (5%) I would like to write more of this language than I currently do</li>
<li>37 (6%) This language is suitable for real-time applications</li>
<li class="supNeg">19 (6%) When I write code in this language I can be very sure it is correct</li>
<li>41 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>59 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">86 (7%) I find this language easy to prototype in</li>
<li>25 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li>27 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>36 (7%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>64 (7%) This language is expressive</li>
<li>42 (7%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supPos">79 (7%) I would use this language for casual scripting</li>
<li>28 (7%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">23 (8%) I often feel like I am not smart enough to write this language</li>
<li>49 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>37 (8%) This language is good for scientific computing</li>
<li>60 (8%) Programs written in this language tend to play well with others</li>
<li>55 (8%) This language excels at symbolic manipulation</li>
<li>26 (8%) This language is good for distributed computing</li>
<li class="supNeg">22 (8%) This language has a very rigid idea of how things should be done</li>
<li>47 (8%) This language is likely to have a strong influence on future languages</li>
<li>32 (9%) I enjoy using this language</li>
<li>52 (9%) There are many good commercial tools for this language</li>
<li>53 (9%) There are many good tools for this language</li>
<li>53 (9%) Programs written in this language will usually work in future versions of the language</li>
<li>42 (9%) Code written in this language tends to be terse</li>
<li>38 (9%) Learning this language significantly changed how I use other languages.</li>
<li>32 (9%) This language is good for numeric computing</li>
</ul>
<ul></ul>
<ul>
<li>55 (0%) I use this language out of choice</li>
<li class="supNeg">17 (1%) I know many other people who use this language</li>
<li>64 (1%) This language is unusually bad for beginners</li>
<li class="supNeg">23 (1%) I usually use this language on solo projects</li>
<li class="supNeg">20 (1%) I use many applications written in this language</li>
<li>33 (1%) This language has many features which feel "tacked on"</li>
<li class="supNeg">17 (1%) This language is good for distributed computing</li>
<li>27 (2%) This language is good for beginners</li>
<li>45 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">22 (2%) This language excels at concurrency</li>
<li class="supNeg">9 (2%) It is easy to tell at a glance what code in this language does</li>
<li>46 (2%) It's unusual for me to discover unfamiliar features</li>
<li>38 (3%) Code written in this language is very readable</li>
<li class="supNeg">2 (3%) I can imagine using this language in my day job</li>
<li class="supNeg">4 (3%) I can imagine this will be a popular language in twenty years time</li>
<li>51 (3%) I often get angry when writing code in this language</li>
<li>37 (3%) There are many good commercial tools for this language</li>
<li>28 (3%) I would use this language for a web project</li>
<li class="supNeg">16 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>70 (3%) This language has a very coherent design</li>
<li>37 (4%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">15 (4%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">19 (4%) This language is best for very large projects</li>
<li>36 (4%) Code written in this language tends to be very reliable</li>
<li>55 (4%) This language has a niche in which it is great</li>
<li>34 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">20 (5%) There is a wide variety of open source code written in this language</li>
<li>36 (5%) This language has a good community</li>
<li>42 (5%) This language has a very dogmatic community</li>
<li>43 (5%) This language encourages writing code that is easy to maintain.</li>
<li>42 (5%) This language is likely to have a strong influence on future languages</li>
<li>56 (5%) Developers who primarily use this language often burn out after a few years</li>
<li>27 (5%) I would use this language to write a command-line app</li>
<li>31 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>47 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li>45 (5%) This language has unusual features that I often miss when using other languages</li>
<li>59 (5%) This language is expressive</li>
<li class="supPos">79 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">23 (6%) I would use this language for a desktop GUI project</li>
<li>54 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">19 (6%) This is a mainstream language</li>
<li class="supNeg">19 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>34 (6%) I regularly use this language</li>
<li>65 (6%) This language is built on a small core of orthogonal features</li>
<li>44 (6%) The resources for learning this language are of high quality</li>
<li>67 (6%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">21 (7%) There are many good open-source tools for this language</li>
<li class="supNeg">19 (7%) I still discover new features of this language on a fairly regular basis</li>
<li>60 (7%) I find code written in this language very elegant</li>
<li>44 (7%) I would use this language for casual scripting</li>
<li>27 (7%) There are many good tools for this language</li>
<li>30 (7%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">7 (7%) Libraries in this language tend to be well documented.</li>
<li>27 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>37 (7%) I enjoy using this language</li>
<li>39 (7%) This language is well documented</li>
<li class="supNeg">15 (8%) Code written in this language tends to be verbose</li>
<li>37 (8%) Writing code in this language is a lot of work</li>
<li>46 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>40 (8%) This language is likely to be around for a very long time</li>
<li>46 (8%) I would like to write more of this language than I currently do</li>
<li>45 (8%) This language has a very rigid idea of how things should be done</li>
<li>37 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>47 (9%) This language encourages writing reusable code.</li>
<li class="supNeg">18 (9%) Programs written in this language tend to play well with others</li>
<li>27 (9%) This language has a good library distribution mechanism.</li>
<li class="supNeg">16 (9%) This language excels at text processing</li>
<li>48 (9%) I know this language well</li>
<li>65 (9%) I often feel like I am not smart enough to write this language</li>
<li>67 (9%) Learning this language improved my ability as a programmer</li>
<li>51 (9%) This language excels at symbolic manipulation</li>
<li>31 (9%) I would use this language for mobile applications</li>
<li>34 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
</ul>
<ul>
<li>35 (0%) I would use this language for writing embedded programs</li>
<li class="supNeg">0 (0%) This is a mainstream language</li>
<li>69 (0%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">20 (0%) This language excels at concurrency</li>
<li class="supNeg">20 (1%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">21 (1%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">20 (1%) I can imagine using this language in my day job</li>
<li>52 (1%) Code written in this language is very readable</li>
<li>58 (1%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>68 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>61 (1%) This language excels at symbolic manipulation</li>
<li class="supPos">79 (1%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">97 (2%) Learning this language improved my ability as a programmer</li>
<li>47 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">83 (2%) I use this language out of choice</li>
<li>30 (2%) This language is best for very large projects</li>
<li class="supPos">97 (2%) I often feel like I am not smart enough to write this language</li>
<li>53 (2%) I enjoy using this language</li>
<li>54 (2%) Writing code in this language is a lot of work</li>
<li class="supNeg">15 (3%) This language is good for distributed computing</li>
<li class="supNeg">16 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">17 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">23 (3%) This language is good for numeric computing</li>
<li class="supPos">81 (3%) This language has a very coherent design</li>
<li>32 (3%) This language is large</li>
<li class="supPos">95 (4%) When I write code in this language I can be very sure it is correct</li>
<li>29 (4%) I regularly use this language</li>
<li class="supPos">95 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">4 (4%) Programs written in this language tend to be efficient</li>
<li>40 (4%) This language is well documented</li>
<li class="supPos">95 (4%) This language has a strong static type system</li>
<li class="supPos">82 (4%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>64 (4%) I would like to write more of this language than I currently do</li>
<li class="supNeg">15 (4%) Programs written in this language tend to play well with others</li>
<li class="supPos">94 (5%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">81 (5%) This language has a niche outside of which I would not use it</li>
<li class="supNeg">5 (5%) This is a low level language</li>
<li class="supNeg">5 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>58 (5%) This language is likely to be a passing fad</li>
<li>57 (5%) This language is good for scientific computing</li>
<li>39 (5%) This language has a good library distribution mechanism.</li>
<li>74 (5%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">89 (5%) This is a high level language</li>
<li class="supNeg">19 (5%) There are many good tools for this language</li>
<li>67 (6%) This language encourages writing reusable code.</li>
<li>58 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li>46 (6%) This language has an annoying syntax</li>
<li class="supNeg">8 (6%) I often get angry when writing code in this language</li>
<li class="supNeg">22 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">7 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">80 (8%) I find code written in this language very elegant</li>
<li class="supNeg">13 (8%) I use many applications written in this language</li>
<li>55 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>44 (8%) Code written in this language tends to be verbose</li>
<li class="supPos">84 (8%) This language is expressive</li>
<li class="supNeg">9 (9%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">24 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">22 (9%) Libraries in this language tend to be well documented.</li>
<li>49 (9%) I know this language well</li>
<li class="supNeg">10 (9%) I would use this language for writing server programs</li>
</ul>
<ul>
<li>42 (3%) Code written in this language tends to be terse</li>
<li>50 (4%) This language is unusually bad for beginners</li>
<li>30 (4%) This language has unusual features that I often miss when using other languages</li>
<li>30 (5%) Writing code in this language is a lot of work</li>
<li class="supNeg">24 (5%) I can imagine using this language in my day job</li>
<li>40 (5%) Code written in this language tends to be verbose</li>
<li class="supPos">75 (5%) I find this language easy to prototype in</li>
<li>40 (5%) This language has a very coherent design</li>
<li>25 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">15 (6%) This language has a strong static type system</li>
<li>39 (6%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>50 (6%) Code written in this language is very readable</li>
<li>30 (6%) Learning this language improved my ability as a programmer</li>
<li>25 (6%) Learning this language significantly changed how I use other languages.</li>
<li>26 (6%) This language is suitable for real-time applications</li>
<li>36 (6%) I find code written in this language very elegant</li>
<li>42 (6%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">18 (7%) When I write code in this language I can be very sure it is correct</li>
<li>58 (7%) I use this language out of choice</li>
<li>50 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">13 (7%) This language is good for distributed computing</li>
<li>25 (7%) This is a low level language</li>
<li>29 (7%) I can imagine this will be a popular language in twenty years time</li>
<li>52 (7%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>31 (8%) Code written in this language tends to be very reliable</li>
<li>46 (8%) The semantics of this language are much different than other languages I know.</li>
<li>54 (8%) This language has a high quality implementation</li>
<li class="supNeg">11 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>43 (8%) This is a mainstream language</li>
<li>45 (8%) I usually use this language on solo projects</li>
<li>52 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">84 (9%) This language has a niche outside of which I would not use it</li>
<li>32 (9%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">20 (9%) This language excels at concurrency</li>
<li>27 (9%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">20 (9%) Programs written in this language tend to be efficient</li>
<li>34 (9%) I usually use this language on projects with many other members</li>
<li class="supNeg">17 (9%) I enjoy using this language</li>
<li>33 (9%) This language is good for beginners</li>
<li class="supNeg">14 (9%) This language is best for very large projects</li>
<li>57 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>53 (9%) This language has many features which feel "tacked on"</li>
<li class="supNeg">18 (9%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">11 (9%) I would use this language for writing server programs</li>
<li>52 (9%) I often get angry when writing code in this language</li>
</ul>
<ul></ul>
</div>
k-means with k = 15
<tabled class="data" id="clusters15">
  <trd>
    <tdd>Javascript,6.0</tdd>
    <tdd>Perl,6.0</tdd>
    <tdd>ELisp,7.0</tdd>
    <tdd>PHP,7.0</tdd>
  </trd>
  <trd>
    <tdd>Cobol,0.0</tdd>
  </trd>
  <trd>
    <tdd>C#,6.0</tdd>
    <tdd>Python,7.0</tdd>
    <tdd>Ruby,7.0</tdd>
    <tdd>Java,8.0</tdd>
  </trd>
  <trd>
    <tdd>Ada,5.0</tdd>
    <tdd>D,5.0</tdd>
    <tdd>Objective C,6.0</tdd>
    <tdd>Eiffel,6.0</tdd>
  </trd>
  <trd>
    <tdd>Delphi,4.0</tdd>
    <tdd>Pascal,5.0</tdd>
    <tdd>Visual Basic,6.0</tdd>
  </trd>
  <trd>
    <tdd>ActionScript,0.0</tdd>
  </trd>
  <trd>
    <tdd>C,6.0</tdd>
    <tdd>C++,6.0</tdd>
  </trd>
  <trd>
    <tdd>Forth,6.0</tdd>
    <tdd>APL,8.0</tdd>
    <tdd>Assembler,10.0</tdd>
  </trd>
  <trd>
    <tdd>Fortran,0.0</tdd>
  </trd>
  <trd>
    <tdd>R,5.0</tdd>
    <tdd>Matlab,6.0</tdd>
    <tdd>Mathematica,6.0</tdd>
    <tdd>J,8.0</tdd>
    <tdd>Groovy,8.0</tdd>
    <tdd>Prolog,8.0</tdd>
    <tdd>Haxe,8.0</tdd>
  </trd>
  <trd>
    <tdd>F#,5.0</tdd>
    <tdd>Clojure,5.0</tdd>
    <tdd>O'Caml,5.0</tdd>
    <tdd>Scala,7.0</tdd>
    <tdd>Go,7.0</tdd>
    <tdd>Erlang,8.0</tdd>
    <tdd>Haskell,8.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,7.0</tdd>
    <tdd>Agda,7.0</tdd>
  </trd>
  <trd>
    <tdd>Io,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>Factor,7.0</tdd>
    <tdd>Lua,7.0</tdd>
    <tdd>Scheme,7.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>REBOL,11.0</tdd>
  </trd>
  <trd>
    <tdd>AWK,5.0</tdd>
    <tdd>TCL,5.0</tdd>
    <tdd>Shell,5.0</tdd>
  </trd>
</tabled>
<div class="support" id="support15">
<ul>
<li class="supNeg">11 (2%) This language has a strong static type system</li>
<li>29 (2%) This language is suitable for real-time applications</li>
<li class="supNeg">21 (2%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>65 (2%) This language has a good community</li>
<li class="supNeg">20 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>39 (3%) It is easy to debug programs written in this language when it goes wrong</li>
<li>26 (3%) This language is best for very large projects</li>
<li class="supNeg">22 (3%) This language excels at concurrency</li>
<li>58 (4%) There are many good tools for this language</li>
<li>30 (4%) This is a low level language</li>
<li>67 (4%) There are many good open-source tools for this language</li>
<li class="supNeg">14 (4%) When I write code in this language I can be very sure it is correct</li>
<li>70 (5%) This is a high level language</li>
<li>43 (5%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>43 (5%) This language encourages writing code that is easy to maintain.</li>
<li>38 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>35 (5%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>51 (5%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">14 (5%) I would use this language for writing embedded programs</li>
<li class="supPos">77 (5%) There is a wide variety of open source code written in this language</li>
<li>61 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">22 (6%) This language is good for numeric computing</li>
<li>41 (6%) I find it easy to write efficient code in this language</li>
<li class="supNeg">17 (6%) This language is good for distributed computing</li>
<li>43 (6%) This language would be good for teaching children to write software</li>
<li>74 (6%) I find this language easy to prototype in</li>
<li class="supPos">85 (6%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>59 (7%) The resources for learning this language are of high quality</li>
<li>59 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>69 (8%) I use many applications written in this language</li>
<li>55 (8%) Libraries in this language tend to be well documented.</li>
<li>25 (8%) I can imagine using this language in my day job</li>
<li>50 (8%) I usually use this language on solo projects</li>
<li>49 (8%) I learned this language early in my career as a programmer</li>
<li>53 (8%) I use this language out of choice</li>
<li>46 (8%) Code written in this language tends to be verbose</li>
<li>45 (8%) This language has a very dogmatic community</li>
<li>35 (8%) Writing code in this language is a lot of work</li>
<li>59 (8%) I regularly use this language</li>
</ul>
<ul></ul>
<ul>
<li>34 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">81 (2%) This language encourages writing reusable code.</li>
<li class="supNeg">18 (4%) I often feel like I am not smart enough to write this language</li>
<li>44 (4%) This language makes it easy to shoot yourself in the foot</li>
<li>41 (4%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supPos">91 (5%) The resources for learning this language are of high quality</li>
<li>49 (5%) I enjoy using this language</li>
<li>72 (6%) Programs written in this language tend to play well with others</li>
<li>33 (6%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">88 (6%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>52 (6%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>71 (6%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>38 (6%) This language matches it's problem domain particularly well.</li>
<li>68 (6%) This language has a very dogmatic community</li>
<li>62 (6%) I still discover new features of this language on a fairly regular basis</li>
<li class="supPos">77 (6%) This language encourages writing code that is easy to maintain.</li>
<li>74 (7%) I use many applications written in this language</li>
<li>69 (7%) I would use this language for writing server programs</li>
<li>29 (7%) This language excels at concurrency</li>
<li>44 (7%) This language is good for distributed computing</li>
<li>45 (7%) I would like to write more of this language than I currently do</li>
<li>60 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>73 (7%) I know this language well</li>
<li>27 (7%) This language is built on a small core of orthogonal features</li>
<li>29 (7%) This is a low level language</li>
<li class="supPos">87 (8%) I find this language easy to prototype in</li>
<li>59 (8%) This language has a very coherent design</li>
<li>33 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>74 (8%) This language has a good community</li>
<li>70 (8%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">89 (8%) This language is well documented</li>
<li>74 (8%) This is a high level language</li>
<li class="supPos">81 (9%) I would use this language for a desktop GUI project</li>
<li>45 (9%) This language is suitable for real-time applications</li>
<li>52 (9%) Code written in this language tends to be very reliable</li>
<li>34 (9%) I would use this language for writing embedded programs</li>
</ul>
<ul>
<li>27 (3%) There are many good open-source tools for this language</li>
<li>41 (3%) This language is very flexible</li>
<li>55 (4%) This language is good for scientific computing</li>
<li class="supNeg">24 (4%) Code written in this language tends to be terse</li>
<li>72 (4%) This language is best for very large projects</li>
<li>38 (4%) Learning this language significantly changed how I use other languages.</li>
<li>35 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>28 (4%) The semantics of this language are much different than other languages I know.</li>
<li>63 (4%) This is a high level language</li>
<li>46 (4%) This language has a good library distribution mechanism.</li>
<li>38 (4%) I would use this language for a web project</li>
<li>40 (5%) This language excels at symbolic manipulation</li>
<li>29 (5%) This language is good for beginners</li>
<li>46 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>43 (5%) I know this language well</li>
<li>31 (5%) I enjoy using this language</li>
<li class="supPos">86 (5%) This language encourages writing reusable code.</li>
<li>64 (5%) It is easy to tell at a glance what code in this language does</li>
<li class="supNeg">22 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li>34 (5%) I can imagine using this language in my day job</li>
<li>44 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>56 (6%) Programs written in this language tend to play well with others</li>
<li>33 (6%) This language is good for distributed computing</li>
<li>63 (6%) This language has a strong static type system</li>
<li>26 (6%) This language is minimal</li>
<li>42 (6%) This language has unusual features that I often miss when using other languages</li>
<li>56 (6%) This language has a very dogmatic community</li>
<li>38 (6%) This language excels at concurrency</li>
<li>37 (7%) I would use this language for casual scripting</li>
<li>42 (7%) I usually use this language on projects with many other members</li>
<li>48 (7%) I find code written in this language very elegant</li>
<li>63 (7%) I use this language out of choice</li>
<li>47 (7%) This language has an annoying syntax</li>
<li>52 (7%) This language is expressive</li>
<li>33 (7%) This language excels at text processing</li>
<li>57 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>48 (7%) This language is likely to have a strong influence on future languages</li>
<li>33 (8%) There is a wide variety of open source code written in this language</li>
<li>50 (8%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>37 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>54 (8%) I would like to write more of this language than I currently do</li>
<li>46 (8%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>36 (8%) I am reluctant to admit to knowing this language</li>
<li>47 (8%) This is a low level language</li>
<li>29 (8%) I often feel like I am not smart enough to write this language</li>
<li>58 (8%) This language is large</li>
<li>31 (8%) This language is likely to be around for a very long time</li>
<li>62 (9%) Code written in this language is very readable</li>
<li>33 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>66 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>49 (9%) There are many good tools for this language</li>
<li>58 (9%) This language has many features which feel "tacked on"</li>
<li>59 (9%) Programs written in this language tend to be efficient</li>
<li>42 (9%) I would use this language for writing server programs</li>
<li>52 (9%) I would list this language on my resume</li>
<li>52 (9%) I would use this language for writing embedded programs</li>
<li>70 (9%) This language is suitable for real-time applications</li>
<li>59 (9%) I find this language easy to prototype in</li>
<li>36 (9%) This language is built on a small core of orthogonal features</li>
</ul>
<ul>
<li>36 (0%) Writing code in this language is a lot of work</li>
<li>55 (1%) It's unusual for me to discover unfamiliar features</li>
<li>26 (1%) There is a wide variety of open source code written in this language</li>
<li>42 (1%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">8 (1%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">18 (1%) The semantics of this language are much different than other languages I know.</li>
<li>35 (1%) I usually use this language on projects with many other members</li>
<li>44 (1%) This language is unusually bad for beginners</li>
<li>68 (1%) This language has an annoying syntax</li>
<li class="supNeg">18 (1%) I usually use this language on solo projects</li>
<li>55 (2%) Code written in this language is very readable</li>
<li>62 (2%) I find this language easy to prototype in</li>
<li class="supNeg">19 (2%) I would use this language as a scripting language embedded inside a larger application</li>
<li>41 (2%) This language has a high quality implementation</li>
<li class="supNeg">15 (2%) I would use this language for writing server programs</li>
<li class="supNeg">3 (3%) I still discover new features of this language on a fairly regular basis</li>
<li>55 (3%) This language encourages writing code that is easy to maintain.</li>
<li>31 (3%) I would use this language for mobile applications</li>
<li>55 (3%) I know this language well</li>
<li>70 (3%) Code written in this language tends to be verbose</li>
<li>47 (3%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">9 (4%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">10 (4%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">22 (4%) This language excels at symbolic manipulation</li>
<li class="supNeg">7 (4%) This language has a niche in which it is great</li>
<li>31 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>52 (4%) This language is good for beginners</li>
<li>28 (5%) I would use this language for a web project</li>
<li>43 (5%) This language is large</li>
<li class="supNeg">15 (5%) This language is good for distributed computing</li>
<li>44 (5%) There are many good tools for this language</li>
<li>32 (5%) This language is expressive</li>
<li>27 (6%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>54 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>50 (6%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">15 (6%) This language is very flexible</li>
<li>55 (6%) This language has a niche outside of which I would not use it</li>
<li>67 (6%) This language would be good for teaching children to write software</li>
<li class="supNeg">22 (6%) This language is best for very small projects</li>
<li>38 (6%) This language has a very dogmatic community</li>
<li>44 (6%) This is a low level language</li>
<li>36 (6%) This language is likely to be around for a very long time</li>
<li>39 (6%) I use many applications written in this language</li>
<li class="supNeg">11 (7%) I enjoy using this language</li>
<li class="supNeg">21 (7%) I regularly use this language</li>
<li class="supNeg">23 (7%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>42 (7%) This language has a good library distribution mechanism.</li>
<li class="supNeg">17 (7%) There are many good open-source tools for this language</li>
<li>50 (7%) This is a mainstream language</li>
<li class="supNeg">15 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li>61 (7%) This is a high level language</li>
<li>47 (7%) I know many other people who use this language</li>
<li>30 (8%) I would use this language for writing embedded programs</li>
<li class="supNeg">21 (8%) Code written in this language tends to be terse</li>
<li>46 (8%) This language encourages writing reusable code.</li>
<li>40 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">11 (8%) I can imagine using this language in my day job</li>
<li>42 (8%) I would use this language to write a command-line app</li>
<li>54 (8%) It is easy to debug programs written in this language when it goes wrong</li>
<li>39 (8%) This language is best for very large projects</li>
<li>34 (8%) I would use this language for casual scripting</li>
<li>42 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>28 (8%) This language excels at text processing</li>
<li class="supNeg">23 (9%) This language is likely to have a strong influence on future languages</li>
<li>51 (9%) It is easy to tell at a glance what code in this language does</li>
<li>48 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>42 (9%) Programs written in this language tend to play well with others</li>
<li class="supNeg">24 (9%) This language excels at concurrency</li>
<li class="supNeg">13 (9%) This language matches it's problem domain particularly well.</li>
</ul>
<ul></ul>
<ul>
<li>55 (0%) I can imagine this will be a popular language in twenty years time</li>
<li>73 (0%) This language is good for numeric computing</li>
<li class="supNeg">18 (0%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">78 (0%) I usually use this language on projects with many other members</li>
<li>43 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>39 (0%) I would like to write more of this language than I currently do</li>
<li>55 (0%) Libraries in this language tend to be well documented.</li>
<li class="supPos">77 (0%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">87 (0%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">82 (0%) There are many good open-source tools for this language</li>
<li class="supPos">98 (1%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supPos">98 (1%) I find it easy to write efficient code in this language</li>
<li class="supNeg">4 (1%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">86 (1%) There are many good commercial tools for this language</li>
<li class="supPos">76 (1%) There are many good tools for this language</li>
<li class="supPos">88 (1%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>47 (2%) I often feel like I am not smart enough to write this language</li>
<li>56 (2%) This language has a strong static type system</li>
<li class="supPos">97 (2%) I use many applications written in this language</li>
<li class="supPos">93 (2%) This language has a high quality implementation</li>
<li>39 (2%) I would use this language for casual scripting</li>
<li>44 (2%) I find this language easy to prototype in</li>
<li class="supPos">87 (2%) This is a mainstream language</li>
<li class="supNeg">7 (2%) I am reluctant to admit to knowing this language</li>
<li>36 (2%) This language has a very coherent design</li>
<li>43 (3%) This language has a very dogmatic community</li>
<li class="supPos">85 (3%) I know many other people who use this language</li>
<li>31 (3%) This language has a niche outside of which I would not use it</li>
<li class="supPos">84 (3%) Programs written in this language tend to be efficient</li>
<li>33 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>60 (3%) I would use this language for mobile applications</li>
<li class="supPos">92 (3%) Learning this language improved my ability as a programmer</li>
<li>47 (3%) This language has a good library distribution mechanism.</li>
<li class="supNeg">21 (3%) This language excels at concurrency</li>
<li>37 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">78 (4%) The resources for learning this language are of high quality</li>
<li class="supPos">95 (4%) This language is suitable for real-time applications</li>
<li>33 (4%) This language is well suited for an agile development approach using short iterations.</li>
<li>29 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">75 (4%) I know this language well</li>
<li>28 (4%) I find code written in this language very elegant</li>
<li>62 (4%) Writing code in this language is a lot of work</li>
<li class="supPos">95 (4%) Programs written in this language will usually work in future versions of the language</li>
<li>40 (4%) Learning this language significantly changed how I use other languages.</li>
<li>61 (4%) Code written in this language tends to be verbose</li>
<li>56 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>38 (4%) This language has a good community</li>
<li>28 (4%) This language excels at symbolic manipulation</li>
<li>41 (4%) It is easy to tell at a glance what code in this language does</li>
<li>36 (5%) I would use this language for a web project</li>
<li class="supNeg">19 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">5 (5%) I use this language out of choice</li>
<li>49 (5%) This language encourages writing code that is easy to maintain.</li>
<li>49 (6%) This is a high level language</li>
<li>69 (6%) This language is best for very large projects</li>
<li class="supPos">78 (6%) I would use this language to write a command-line app</li>
<li class="supPos">93 (6%) There is a wide variety of open source code written in this language</li>
<li>45 (6%) Code written in this language is very readable</li>
<li>57 (6%) I often get angry when writing code in this language</li>
<li>68 (6%) This language is good for scientific computing</li>
<li>34 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (7%) I enjoy using this language</li>
<li>34 (7%) Code written in this language tends to be very reliable</li>
<li class="supPos">82 (7%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>73 (8%) This language is very flexible</li>
<li>69 (8%) This is a low level language</li>
<li>31 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">91 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>27 (8%) This language excels at text processing</li>
<li>41 (8%) Code written in this language tends to be terse</li>
<li>46 (8%) I would use this language for writing server programs</li>
<li class="supPos">83 (9%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">90 (9%) This language is likely to be around for a very long time</li>
</ul>
<ul>
<li class="supNeg">1 (1%) Libraries in this language tend to be well documented.</li>
<li>53 (1%) I use this language out of choice</li>
<li class="supNeg">8 (2%) I can imagine this will be a popular language in twenty years time</li>
<li>41 (2%) The resources for learning this language are of high quality</li>
<li>59 (3%) Learning this language improved my ability as a programmer</li>
<li>63 (3%) Developers who primarily use this language often burn out after a few years</li>
<li>26 (3%) I usually use this language on solo projects</li>
<li class="supNeg">5 (4%) It is easy to tell at a glance what code in this language does</li>
<li class="supNeg">19 (4%) There are many good tools for this language</li>
<li>55 (4%) This language has a niche in which it is great</li>
<li class="supNeg">21 (5%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">6 (5%) This language has a strong static type system</li>
<li class="supNeg">13 (5%) This language is good for distributed computing</li>
<li class="supNeg">7 (5%) I can imagine using this language in my day job</li>
<li>42 (5%) There are many good commercial tools for this language</li>
<li class="supPos">79 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li>26 (6%) This language excels at concurrency</li>
<li>30 (6%) I am reluctant to admit to knowing this language</li>
<li class="supPos">75 (6%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>33 (6%) I regularly use this language</li>
<li>33 (6%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">18 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>68 (7%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">23 (7%) I know many other people who use this language</li>
<li>27 (7%) I use many applications written in this language</li>
<li>63 (7%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>55 (8%) I often get angry when writing code in this language</li>
<li class="supNeg">9 (8%) It is easy to debug programs written in this language when it goes wrong</li>
<li>39 (8%) This language is frequently used for applications it isn't suitable for</li>
<li>53 (8%) Learning this language significantly changed how I use other languages.</li>
<li>38 (8%) I know this language well</li>
<li>58 (8%) This language has an annoying syntax</li>
<li>38 (8%) This language has a very dogmatic community</li>
<li class="supNeg">10 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">23 (8%) I would use this language to write a command-line app</li>
<li class="supNeg">19 (8%) Programs written in this language tend to play well with others</li>
<li>71 (8%) This language is unusually bad for beginners</li>
<li>36 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (9%) There are many good open-source tools for this language</li>
<li>40 (9%) I would like to write more of this language than I currently do</li>
<li>31 (9%) I would use this language for mobile applications</li>
<li class="supNeg">10 (9%) I would use this language for writing server programs</li>
<li>27 (9%) This language has many features which feel "tacked on"</li>
<li>52 (9%) It's unusual for me to discover unfamiliar features</li>
<li>61 (9%) I often feel like I am not smart enough to write this language</li>
<li>34 (9%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">8 (9%) This language excels at text processing</li>
</ul>
<ul></ul>
<ul>
<li>45 (5%) This language is best for very small projects</li>
<li class="supNeg">18 (5%) This is a low level language</li>
<li>29 (6%) This language excels at concurrency</li>
<li>37 (6%) This language is likely to have a strong influence on future languages</li>
<li>44 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>54 (7%) This language is unusually bad for beginners</li>
<li>47 (7%) I would like to write more of this language than I currently do</li>
<li class="supNeg">22 (7%) This language is good for distributed computing</li>
<li class="supNeg">23 (7%) When I write code in this language I can be very sure it is correct</li>
<li>48 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>41 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>50 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supPos">84 (8%) This is a high level language</li>
<li class="supNeg">13 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>40 (8%) This language has a very rigid idea of how things should be done</li>
<li>37 (8%) This language is likely to be around for a very long time</li>
<li>29 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>28 (9%) This language has a strong static type system</li>
<li>36 (9%) I would list this language on my resume</li>
<li>47 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supPos">80 (9%) I find this language easy to prototype in</li>
<li>35 (9%) I use many applications written in this language</li>
<li>37 (9%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>39 (9%) This language is good for beginners</li>
<li>31 (9%) Writing code in this language is a lot of work</li>
<li>54 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>37 (9%) I am reluctant to admit to knowing this language</li>
</ul>
<ul>
<li>72 (4%) This language has a very coherent design</li>
<li>38 (4%) This language is good for beginners</li>
<li>38 (5%) This is a mainstream language</li>
<li class="supNeg">18 (5%) There is a lot of accidental complexity when writing code in this language</li>
<li>31 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>39 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>38 (6%) I use many applications written in this language</li>
<li class="supNeg">24 (6%) Writing code in this language is a lot of work</li>
<li>45 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>49 (7%) This language is likely to be around for a very long time</li>
<li>73 (7%) This language has a high quality implementation</li>
<li>27 (7%) I often get angry when writing code in this language</li>
<li>66 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>27 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>35 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">83 (7%) I find this language easy to prototype in</li>
<li>60 (8%) This language has a good library distribution mechanism.</li>
<li>60 (8%) Programs written in this language tend to play well with others</li>
<li>65 (8%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>64 (8%) I would use this language for casual scripting</li>
<li>62 (8%) Code written in this language is very readable</li>
<li>58 (8%) I enjoy playing with this language but would never use it for "real code"</li>
<li>43 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>38 (8%) This language is well documented</li>
<li class="supNeg">11 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>63 (8%) This language is suitable for real-time applications</li>
<li>28 (9%) Code written in this language tends to be verbose</li>
<li>55 (9%) Code written in this language tends to be terse</li>
<li>29 (9%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>54 (9%) This language is unusually bad for beginners</li>
</ul>
<ul>
<li>35 (0%) I would use this language for writing embedded programs</li>
<li class="supNeg">0 (0%) This is a mainstream language</li>
<li>69 (0%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">20 (0%) This language excels at concurrency</li>
<li class="supNeg">20 (1%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">21 (1%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">20 (1%) I can imagine using this language in my day job</li>
<li>52 (1%) Code written in this language is very readable</li>
<li>58 (1%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>68 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>61 (1%) This language excels at symbolic manipulation</li>
<li class="supPos">79 (1%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">97 (2%) Learning this language improved my ability as a programmer</li>
<li>47 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">83 (2%) I use this language out of choice</li>
<li>30 (2%) This language is best for very large projects</li>
<li class="supPos">97 (2%) I often feel like I am not smart enough to write this language</li>
<li>53 (2%) I enjoy using this language</li>
<li>54 (2%) Writing code in this language is a lot of work</li>
<li class="supNeg">15 (3%) This language is good for distributed computing</li>
<li class="supNeg">16 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">17 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">23 (3%) This language is good for numeric computing</li>
<li class="supPos">81 (3%) This language has a very coherent design</li>
<li>32 (3%) This language is large</li>
<li class="supPos">95 (4%) When I write code in this language I can be very sure it is correct</li>
<li>29 (4%) I regularly use this language</li>
<li class="supPos">95 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">4 (4%) Programs written in this language tend to be efficient</li>
<li>40 (4%) This language is well documented</li>
<li class="supPos">95 (4%) This language has a strong static type system</li>
<li class="supPos">82 (4%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>64 (4%) I would like to write more of this language than I currently do</li>
<li class="supNeg">15 (4%) Programs written in this language tend to play well with others</li>
<li class="supPos">94 (5%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">81 (5%) This language has a niche outside of which I would not use it</li>
<li class="supNeg">5 (5%) This is a low level language</li>
<li class="supNeg">5 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>58 (5%) This language is likely to be a passing fad</li>
<li>57 (5%) This language is good for scientific computing</li>
<li>39 (5%) This language has a good library distribution mechanism.</li>
<li>74 (5%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">89 (5%) This is a high level language</li>
<li class="supNeg">19 (5%) There are many good tools for this language</li>
<li>67 (6%) This language encourages writing reusable code.</li>
<li>58 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li>46 (6%) This language has an annoying syntax</li>
<li class="supNeg">8 (6%) I often get angry when writing code in this language</li>
<li class="supNeg">22 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">7 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">80 (8%) I find code written in this language very elegant</li>
<li class="supNeg">13 (8%) I use many applications written in this language</li>
<li>55 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>44 (8%) Code written in this language tends to be verbose</li>
<li class="supPos">84 (8%) This language is expressive</li>
<li class="supNeg">9 (9%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">24 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">22 (9%) Libraries in this language tend to be well documented.</li>
<li>49 (9%) I know this language well</li>
<li class="supNeg">10 (9%) I would use this language for writing server programs</li>
</ul>
<ul>
<li>35 (5%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">79 (5%) This is a high level language</li>
<li>68 (5%) I use this language out of choice</li>
<li>28 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>25 (6%) This is a low level language</li>
<li>42 (6%) Developers who primarily use this language often burn out after a few years</li>
<li class="supPos">77 (7%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>45 (7%) This language is suitable for real-time applications</li>
<li class="supNeg">20 (7%) I can imagine using this language in my day job</li>
<li>60 (7%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">21 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>31 (8%) This language excels at concurrency</li>
<li>72 (8%) This language is expressive</li>
<li>38 (8%) This language has many features which feel "tacked on"</li>
<li>56 (9%) This language has a good community</li>
<li>37 (9%) I would use this language for writing server programs</li>
<li>37 (9%) There are many good open-source tools for this language</li>
<li>61 (9%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">24 (9%) I usually use this language on projects with many other members</li>
<li class="supNeg">21 (9%) Writing code in this language is a lot of work</li>
<li>35 (9%) Libraries in this language tend to be well documented.</li>
<li>48 (9%) I would use this language for a desktop GUI project</li>
</ul>
<ul>
<li>32 (0%) This is a low level language</li>
<li class="supNeg">21 (0%) This language is good for scientific computing</li>
<li>30 (0%) This language is good for beginners</li>
<li>30 (1%) It is easy to debug programs written in this language when it goes wrong</li>
<li>25 (1%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">22 (1%) I often feel like I am not smart enough to write this language</li>
<li>65 (1%) This is a high level language</li>
<li>56 (1%) I learned this language early in my career as a programmer</li>
<li>30 (1%) Learning this language improved my ability as a programmer</li>
<li class="supNeg">20 (2%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">20 (2%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>35 (2%) There are many good commercial tools for this language</li>
<li>32 (2%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>67 (2%) Developers who primarily use this language often burn out after a few years</li>
<li>47 (2%) This language is unusually bad for beginners</li>
<li class="supNeg">22 (2%) I can imagine using this language in my day job</li>
<li>29 (3%) This language has a very dogmatic community</li>
<li>73 (3%) I find this language easy to prototype in</li>
<li>47 (3%) This language has a high quality implementation</li>
<li class="supNeg">14 (3%) Programs written in this language tend to be efficient</li>
<li class="supNeg">13 (3%) When I write code in this language I can be very sure it is correct</li>
<li>29 (3%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">22 (3%) Learning this language significantly changed how I use other languages.</li>
<li>59 (4%) This language is minimal</li>
<li>57 (4%) I use this language out of choice</li>
<li class="supNeg">21 (4%) I would use this language for writing server programs</li>
<li>47 (4%) This language is well suited for an agile development approach using short iterations.</li>
<li>48 (4%) I use many applications written in this language</li>
<li>46 (4%) The resources for learning this language are of high quality</li>
<li>41 (4%) Code written in this language tends to be terse</li>
<li class="supNeg">10 (4%) This language has a strong static type system</li>
<li>25 (4%) I can imagine this will be a popular language in twenty years time</li>
<li>38 (5%) Code written in this language tends to be verbose</li>
<li class="supNeg">6 (5%) This language is good for distributed computing</li>
<li>25 (5%) This language is expressive</li>
<li>33 (5%) I find code written in this language very elegant</li>
<li>37 (5%) This language excels at symbolic manipulation</li>
<li>27 (5%) This language is built on a small core of orthogonal features</li>
<li>25 (5%) There are many good tools for this language</li>
<li>26 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>62 (6%) Programs written in this language will usually work in future versions of the language</li>
<li>56 (6%) It is easy to tell at a glance what code in this language does</li>
<li>38 (6%) This language has a very coherent design</li>
<li>30 (6%) Writing code in this language is a lot of work</li>
<li>27 (6%) Code written in this language tends to be very reliable</li>
<li>30 (6%) I would use this language for mobile applications</li>
<li>67 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li>31 (7%) This language has a good community</li>
<li>56 (7%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>47 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>47 (7%) I am reluctant to admit to knowing this language</li>
<li>51 (7%) I often get angry when writing code in this language</li>
<li class="supNeg">17 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li>33 (7%) This language is well documented</li>
<li>60 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>29 (7%) This language has a very rigid idea of how things should be done</li>
<li>46 (7%) This is a mainstream language</li>
<li>46 (7%) Code written in this language is very readable</li>
<li class="supNeg">21 (8%) This language is large</li>
<li>26 (8%) This language is suitable for real-time applications</li>
<li class="supNeg">12 (8%) I enjoy using this language</li>
<li>70 (9%) Programs written in this language tend to play well with others</li>
<li class="supPos">81 (9%) I would use this language for casual scripting</li>
<li>40 (9%) I usually use this language on solo projects</li>
<li>55 (9%) This language matches it's problem domain particularly well.</li>
<li class="supNeg">12 (9%) This language is good for numeric computing</li>
<li>35 (9%) This language encourages writing code that is easy to maintain.</li>
<li>70 (9%) This language has an annoying syntax</li>
<li>47 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
</ul>
<ul></ul>
</div>
k-means with k = 16
<tabled class="data" id="clusters16">
  <trd>
    <tdd>D,5.0</tdd>
    <tdd>Go,5.0</tdd>
    <tdd>Objective C,6.0</tdd>
    <tdd>Ada,7.0</tdd>
    <tdd>Groovy,7.0</tdd>
    <tdd>Eiffel,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
  </trd>
  <trd>
    <tdd>C#,7.0</tdd>
    <tdd>Java,7.0</tdd>
    <tdd>C++,8.0</tdd>
    <tdd>C,10.0</tdd>
  </trd>
  <trd>
    <tdd>Python,0.0</tdd>
  </trd>
  <trd>
    <tdd>Assembler,0.0</tdd>
  </trd>
  <trd>
    <tdd>Clojure,5.0</tdd>
    <tdd>Scala,6.0</tdd>
    <tdd>Ruby,7.0</tdd>
  </trd>
  <trd>
    <tdd>Forth,0.0</tdd>
  </trd>
  <trd>
    <tdd>Shell,5.0</tdd>
    <tdd>Javascript,7.0</tdd>
    <tdd>PHP,7.0</tdd>
    <tdd>AWK,7.0</tdd>
  </trd>
  <trd>
    <tdd>R,6.0</tdd>
    <tdd>Matlab,6.0</tdd>
    <tdd>Perl,8.0</tdd>
    <tdd>ActionScript,10.0</tdd>
  </trd>
  <trd>
    <tdd>Mathematica,0.0</tdd>
  </trd>
  <trd>
    <tdd>ELisp,4.0</tdd>
    <tdd>TCL,4.0</tdd>
  </trd>
  <trd>
    <tdd>Scheme,5.0</tdd>
    <tdd>Smalltalk,5.0</tdd>
    <tdd>Common Lisp,6.0</tdd>
    <tdd>Lua,6.0</tdd>
  </trd>
  <trd>
    <tdd>J,0.0</tdd>
  </trd>
  <trd>
    <tdd>F#,5.0</tdd>
    <tdd>O'Caml,5.0</tdd>
    <tdd>Erlang,7.0</tdd>
    <tdd>Haskell,7.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,6.0</tdd>
    <tdd>Io,6.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>REBOL,9.0</tdd>
  </trd>
  <trd>
    <tdd>Pascal,5.0</tdd>
    <tdd>Fortran,6.0</tdd>
    <tdd>Delphi,6.0</tdd>
    <tdd>Cobol,7.0</tdd>
    <tdd>Visual Basic,7.0</tdd>
  </trd>
  <trd>
    <tdd>Prolog,7.0</tdd>
    <tdd>Coq,7.0</tdd>
    <tdd>APL,9.0</tdd>
    <tdd>Agda,11.0</tdd>
  </trd>
</tabled>
<div class="support" id="support16">
<ul>
<li>34 (6%) I enjoy using this language</li>
<li>55 (6%) Programs written in this language tend to play well with others</li>
<li>54 (6%) This language is expressive</li>
<li>37 (6%) I can imagine using this language in my day job</li>
<li>35 (6%) Learning this language significantly changed how I use other languages.</li>
<li>44 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>64 (6%) I use this language out of choice</li>
<li>38 (6%) I am reluctant to admit to knowing this language</li>
<li>52 (7%) I find code written in this language very elegant</li>
<li>32 (7%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>27 (7%) The semantics of this language are much different than other languages I know.</li>
<li>41 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>44 (7%) This language has unusual features that I often miss when using other languages</li>
<li>40 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>47 (7%) This language is likely to have a strong influence on future languages</li>
<li>26 (7%) I often feel like I am not smart enough to write this language</li>
<li>30 (8%) This language is minimal</li>
<li>31 (8%) Code written in this language tends to be terse</li>
<li>67 (8%) This is a high level language</li>
<li>56 (8%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>33 (8%) This language is good for beginners</li>
<li>34 (8%) This language is likely to be around for a very long time</li>
<li>60 (8%) This language has many features which feel "tacked on"</li>
<li>32 (8%) This language is good for distributed computing</li>
<li>46 (8%) I would use this language for writing server programs</li>
<li>58 (8%) The resources for learning this language are of high quality</li>
<li>39 (8%) This is a mainstream language</li>
<li>41 (9%) This language has an annoying syntax</li>
<li>42 (9%) This language has a niche outside of which I would not use it</li>
<li class="supPos">77 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>47 (9%) I would list this language on my resume</li>
<li>46 (9%) This language matches it's problem domain particularly well.</li>
</ul>
<ul>
<li>54 (1%) I can imagine this will be a popular language in twenty years time</li>
<li>39 (3%) I would like to write more of this language than I currently do</li>
<li class="supNeg">4 (3%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">94 (3%) This language has a high quality implementation</li>
<li>60 (4%) This language has a strong static type system</li>
<li>34 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">94 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supPos">91 (5%) This is a mainstream language</li>
<li class="supPos">83 (5%) The resources for learning this language are of high quality</li>
<li>28 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li>32 (5%) I find code written in this language very elegant</li>
<li class="supPos">91 (5%) There are many good commercial tools for this language</li>
<li>33 (6%) This language excels at symbolic manipulation</li>
<li>39 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>26 (7%) This language excels at concurrency</li>
<li class="supPos">91 (7%) I know many other people who use this language</li>
<li>55 (7%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supPos">75 (7%) I know this language well</li>
<li class="supPos">81 (7%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">91 (7%) I find it easy to write efficient code in this language</li>
<li>46 (7%) I would use this language for casual scripting</li>
<li>51 (8%) Code written in this language is very readable</li>
<li>61 (8%) This language is good for scientific computing</li>
<li class="supNeg">24 (8%) This language has a niche outside of which I would not use it</li>
<li>64 (8%) This language is good for numeric computing</li>
<li>26 (8%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">89 (8%) I use many applications written in this language</li>
<li>26 (8%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">23 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>57 (9%) This is a high level language</li>
<li>72 (9%) I would use this language to write a command-line app</li>
<li class="supPos">83 (9%) There are many good tools for this language</li>
<li class="supPos">82 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
</ul>
<ul></ul>
<ul></ul>
<ul>
<li>72 (0%) I would use this language for a desktop GUI project</li>
<li class="supPos">88 (2%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>56 (3%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">88 (3%) This is a high level language</li>
<li class="supNeg">19 (3%) This is a low level language</li>
<li class="supPos">82 (3%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">19 (3%) I learned this language early in my career as a programmer</li>
<li>53 (3%) Code written in this language tends to be terse</li>
<li>70 (3%) Code written in this language is very readable</li>
<li>38 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>73 (4%) I find code written in this language very elegant</li>
<li class="supPos">80 (4%) This language has a good community</li>
<li>31 (4%) When I write code in this language I can be very sure it is correct</li>
<li>29 (4%) Code written in this language tends to be verbose</li>
<li>54 (5%) There are many good tools for this language</li>
<li>26 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>69 (5%) It is easy to tell at a glance what code in this language does</li>
<li class="supPos">92 (5%) I find this language easy to prototype in</li>
<li class="supPos">79 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">92 (5%) This language is very flexible</li>
<li>33 (5%) This language makes it easy to shoot yourself in the foot</li>
<li>65 (6%) Programs written in this language tend to play well with others</li>
<li>51 (6%) There are many good commercial tools for this language</li>
<li>71 (6%) There are many good open-source tools for this language</li>
<li class="supPos">92 (6%) I use this language out of choice</li>
<li>35 (6%) This language has a very rigid idea of how things should be done</li>
<li>74 (6%) This language is likely to be a passing fad</li>
<li>31 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>66 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">89 (7%) This language encourages writing reusable code.</li>
<li class="supNeg">21 (7%) This language has a niche in which it is great</li>
<li class="supNeg">10 (7%) Writing code in this language is a lot of work</li>
<li class="supNeg">22 (7%) This language has an annoying syntax</li>
<li class="supPos">76 (7%) This language is likely to have a strong influence on future languages</li>
<li>62 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">22 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">76 (8%) I would use this language for casual scripting</li>
<li class="supPos">76 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">87 (8%) I would use this language to write a command-line app</li>
<li>46 (8%) I regularly use this language</li>
<li>69 (8%) I would use this language for mobile applications</li>
<li>52 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">88 (8%) This language is expressive</li>
<li>43 (8%) This language is likely to be around for a very long time</li>
<li>74 (9%) This language encourages writing code that is easy to maintain.</li>
<li>49 (9%) I usually use this language on projects with many other members</li>
<li class="supPos">90 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">20 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>40 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>65 (9%) This language has a high quality implementation</li>
<li class="supNeg">11 (9%) It's unusual for me to discover unfamiliar features</li>
<li>31 (9%) I would use this language for writing embedded programs</li>
<li>64 (9%) This language excels at symbolic manipulation</li>
</ul>
<ul></ul>
<ul>
<li class="supNeg">20 (1%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>31 (1%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>31 (2%) This is a low level language</li>
<li>33 (2%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">21 (2%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">12 (2%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">22 (3%) I can imagine using this language in my day job</li>
<li class="supNeg">9 (3%) This language has a strong static type system</li>
<li>52 (3%) The resources for learning this language are of high quality</li>
<li class="supNeg">19 (3%) I often feel like I am not smart enough to write this language</li>
<li>25 (3%) This language is good for scientific computing</li>
<li>66 (4%) This is a high level language</li>
<li class="supNeg">16 (4%) Programs written in this language tend to be efficient</li>
<li class="supNeg">24 (5%) This language is suitable for real-time applications</li>
<li>43 (5%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>35 (5%) This language excels at symbolic manipulation</li>
<li>56 (5%) It is easy to tell at a glance what code in this language does</li>
<li>53 (5%) I learned this language early in my career as a programmer</li>
<li>42 (6%) This language has a niche in which it is great</li>
<li>33 (6%) This language has a very dogmatic community</li>
<li>74 (7%) I find this language easy to prototype in</li>
<li>62 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>45 (7%) Code written in this language is very readable</li>
<li class="supNeg">12 (8%) This language is good for numeric computing</li>
<li>51 (8%) This language is unusually bad for beginners</li>
<li>26 (8%) I would use this language for writing server programs</li>
<li>29 (8%) This language has a very rigid idea of how things should be done</li>
<li>50 (8%) I find it easy to write efficient code in this language</li>
<li>42 (8%) This language is very flexible</li>
<li>55 (8%) I use this language out of choice</li>
<li class="supNeg">19 (9%) Code written in this language tends to be very reliable</li>
<li>44 (9%) This language has a high quality implementation</li>
<li>35 (9%) Code written in this language tends to be terse</li>
<li>58 (9%) I enjoy playing with this language but would never use it for "real code"</li>
<li>25 (9%) This language is likely to have a strong influence on future languages</li>
<li>35 (9%) Writing code in this language is a lot of work</li>
<li>53 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">13 (9%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">15 (9%) This language excels at concurrency</li>
<li>37 (9%) This language encourages writing code that is easy to maintain.</li>
<li>44 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>32 (9%) I find code written in this language very elegant</li>
<li class="supNeg">17 (9%) I enjoy using this language</li>
<li class="supPos">78 (9%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
</ul>
<ul>
<li>43 (2%) I usually use this language on solo projects</li>
<li>53 (3%) This language is well documented</li>
<li>55 (3%) Developers who primarily use this language often burn out after a few years</li>
<li>25 (3%) This language excels at concurrency</li>
<li>33 (3%) I can imagine using this language in my day job</li>
<li class="supNeg">18 (3%) This language is good for distributed computing</li>
<li>52 (4%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">18 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>57 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li>30 (5%) Writing code in this language is a lot of work</li>
<li>47 (5%) This language encourages writing reusable code.</li>
<li>45 (5%) This language has a very dogmatic community</li>
<li>45 (6%) The semantics of this language are much different than other languages I know.</li>
<li>52 (6%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>28 (7%) This is a low level language</li>
<li>38 (7%) I would like to write more of this language than I currently do</li>
<li class="supNeg">22 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>40 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li>41 (7%) This language would be good for teaching children to write software</li>
<li class="supNeg">19 (7%) This language is built on a small core of orthogonal features</li>
<li>47 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>49 (7%) This language is likely to be around for a very long time</li>
<li>29 (7%) Programs written in this language tend to be efficient</li>
<li>45 (7%) Code written in this language tends to be terse</li>
<li class="supPos">82 (8%) This is a high level language</li>
<li>25 (8%) It's unusual for me to discover unfamiliar features</li>
<li>28 (8%) I would use this language for writing embedded programs</li>
<li>38 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>30 (8%) Learning this language significantly changed how I use other languages.</li>
<li>32 (8%) This language is good for beginners</li>
<li>47 (8%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">21 (8%) This language has a strong static type system</li>
<li class="supPos">75 (9%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>47 (9%) There are many good tools for this language</li>
<li class="supNeg">19 (9%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">22 (9%) I enjoy using this language</li>
<li>71 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>73 (9%) I enjoy playing with this language but would never use it for "real code"</li>
<li>49 (9%) I find it easy to write efficient code in this language</li>
<li>51 (9%) I use many applications written in this language</li>
<li>51 (9%) This is a mainstream language</li>
<li>35 (9%) I usually use this language on projects with many other members</li>
</ul>
<ul></ul>
<ul>
<li>36 (0%) I find it easy to write efficient code in this language</li>
<li class="supNeg">24 (0%) I can imagine this will be a popular language in twenty years time</li>
<li>69 (0%) This language is best for very small projects</li>
<li class="supNeg">24 (0%) This language is best for very large projects</li>
<li class="supNeg">20 (0%) This language is good for scientific computing</li>
<li>34 (0%) I know many other people who use this language</li>
<li class="supNeg">23 (0%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">21 (0%) This language is good for numeric computing</li>
<li>53 (0%) Code written in this language is very readable</li>
<li class="supNeg">21 (0%) I usually use this language on projects with many other members</li>
<li>66 (0%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">19 (1%) I would list this language on my resume</li>
<li>38 (1%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">11 (1%) This language is good for distributed computing</li>
<li class="supNeg">9 (1%) Programs written in this language tend to be efficient</li>
<li>42 (1%) Code written in this language tends to be verbose</li>
<li class="supNeg">19 (1%) When I write code in this language I can be very sure it is correct</li>
<li>48 (1%) This language has a good library distribution mechanism.</li>
<li>52 (1%) This language has many features which feel "tacked on"</li>
<li>58 (1%) This language is very flexible</li>
<li>52 (1%) This language is minimal</li>
<li>48 (1%) This language is frequently used for applications it isn't suitable for</li>
<li>31 (1%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">14 (1%) This language has a strong static type system</li>
<li>31 (2%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">21 (2%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>33 (2%) Writing code in this language is a lot of work</li>
<li>50 (2%) This language is unusually bad for beginners</li>
<li>71 (2%) I find this language easy to prototype in</li>
<li>39 (2%) Code written in this language tends to be terse</li>
<li class="supNeg">21 (2%) I can imagine using this language in my day job</li>
<li>53 (2%) This language has a high quality implementation</li>
<li>58 (2%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>40 (3%) I find code written in this language very elegant</li>
<li>60 (3%) I know this language well</li>
<li>66 (3%) I would use this language for casual scripting</li>
<li>55 (3%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>27 (3%) This is a low level language</li>
<li>37 (3%) This language is built on a small core of orthogonal features</li>
<li>39 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>27 (3%) This language is large</li>
<li>42 (3%) This language has a very coherent design</li>
<li>34 (3%) This language is suitable for real-time applications</li>
<li>35 (3%) Learning this language improved my ability as a programmer</li>
<li class="supNeg">6 (4%) I would use this language for writing embedded programs</li>
<li>55 (4%) I use this language out of choice</li>
<li>44 (4%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">82 (4%) This language has a niche outside of which I would not use it</li>
<li>59 (4%) This language excels at text processing</li>
<li>45 (4%) This language is well documented</li>
<li class="supNeg">10 (4%) It's unusual for me to discover unfamiliar features</li>
<li>33 (4%) Code written in this language tends to be very reliable</li>
<li>31 (4%) This language has unusual features that I often miss when using other languages</li>
<li>28 (4%) There are many good commercial tools for this language</li>
<li>43 (5%) The semantics of this language are much different than other languages I know.</li>
<li>45 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">22 (5%) This language excels at concurrency</li>
<li>32 (5%) Learning this language significantly changed how I use other languages.</li>
<li>34 (5%) This is a mainstream language</li>
<li>42 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>69 (5%) This is a high level language</li>
<li class="supNeg">24 (5%) This language is good for beginners</li>
<li>39 (6%) This language would be good for teaching children to write software</li>
<li>55 (6%) I would use this language as a scripting language embedded inside a larger application</li>
<li>27 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>47 (6%) The resources for learning this language are of high quality</li>
<li>51 (7%) I would like to write more of this language than I currently do</li>
<li>48 (7%) I often get angry when writing code in this language</li>
<li>36 (7%) It is easy to debug programs written in this language when it goes wrong</li>
<li>61 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">14 (7%) This language has a very rigid idea of how things should be done</li>
<li>32 (7%) I would use this language for mobile applications</li>
<li>46 (8%) I usually use this language on solo projects</li>
<li>48 (8%) This language makes it easy to shoot yourself in the foot</li>
<li>60 (8%) There is a wide variety of open source code written in this language</li>
<li>58 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>48 (8%) I learned this language early in my career as a programmer</li>
<li>45 (9%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>58 (9%) Programs written in this language will usually work in future versions of the language</li>
<li>57 (9%) This language is likely to be around for a very long time</li>
<li>42 (9%) I would use this language for a web project</li>
<li>52 (9%) I use many applications written in this language</li>
<li>32 (9%) I often feel like I am not smart enough to write this language</li>
</ul>
<ul>
<li>38 (2%) I usually use this language on solo projects</li>
<li>26 (2%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">14 (2%) This language has a strong static type system</li>
<li>32 (2%) I usually use this language on projects with many other members</li>
<li>35 (3%) I would use this language for writing programs for an embedded hardware platform</li>
<li>48 (3%) This language excels at text processing</li>
<li>29 (3%) This language is good for distributed computing</li>
<li>38 (3%) This is a mainstream language</li>
<li>32 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>37 (3%) I know many other people who use this language</li>
<li>38 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>42 (4%) Code written in this language tends to be terse</li>
<li>43 (4%) Programs written in this language tend to be efficient</li>
<li>48 (4%) This language is suitable for real-time applications</li>
<li>59 (4%) This language has a good community</li>
<li>42 (4%) Libraries in this language tend to be well documented.</li>
<li>26 (4%) This is a low level language</li>
<li>62 (4%) This language encourages writing code that is easy to maintain.</li>
<li>67 (4%) This language has a high quality implementation</li>
<li>26 (5%) This language excels at concurrency</li>
<li>49 (5%) There are many good commercial tools for this language</li>
<li>39 (5%) I use many applications written in this language</li>
<li>70 (5%) I use this language out of choice</li>
<li>61 (5%) I would use this language for mobile applications</li>
<li class="supPos">85 (5%) I find this language easy to prototype in</li>
<li>69 (5%) I would like to write more of this language than I currently do</li>
<li>41 (5%) I learned this language early in my career as a programmer</li>
<li>35 (5%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">82 (6%) This is a high level language</li>
<li>54 (6%) I would use this language for a web project</li>
<li>35 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">20 (6%) Writing code in this language is a lot of work</li>
<li>44 (6%) There are many good open-source tools for this language</li>
<li class="supNeg">24 (6%) I often get angry when writing code in this language</li>
<li>71 (6%) This language is expressive</li>
<li>34 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>74 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">23 (7%) I can imagine using this language in my day job</li>
<li>54 (7%) This language has a good library distribution mechanism.</li>
<li>54 (7%) I would use this language for a desktop GUI project</li>
<li>47 (7%) There is a wide variety of open source code written in this language</li>
<li>42 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">79 (8%) This language is very flexible</li>
<li class="supPos">79 (8%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>41 (8%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supPos">82 (8%) This language encourages writing reusable code.</li>
<li>63 (8%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">76 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li>43 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>51 (8%) I would list this language on my resume</li>
<li>47 (8%) This language is good for scientific computing</li>
<li class="supNeg">21 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>67 (8%) Code written in this language is very readable</li>
<li>40 (8%) This language has many features which feel "tacked on"</li>
<li>35 (8%) I would use this language for writing server programs</li>
<li class="supNeg">12 (8%) I am reluctant to admit to knowing this language</li>
<li>40 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>51 (9%) I can imagine this will be a popular language in twenty years time</li>
<li>28 (9%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>54 (9%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>30 (9%) This language has an annoying syntax</li>
<li class="supNeg">19 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li>45 (9%) Code written in this language tends to be very reliable</li>
<li>60 (9%) This language has unusual features that I often miss when using other languages</li>
<li>66 (9%) I find it easy to write efficient code in this language</li>
</ul>
<ul></ul>
<ul>
<li>38 (1%) I use many applications written in this language</li>
<li>62 (2%) This language is well suited for an agile development approach using short iterations.</li>
<li>52 (2%) This language is likely to be around for a very long time</li>
<li class="supNeg">5 (3%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>27 (3%) Writing code in this language is a lot of work</li>
<li>72 (4%) This language has a very coherent design</li>
<li>64 (4%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>36 (5%) This is a mainstream language</li>
<li class="supPos">81 (5%) This language is likely to have a strong influence on future languages</li>
<li>62 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">75 (5%) This language excels at symbolic manipulation</li>
<li class="supNeg">23 (5%) This is a low level language</li>
<li>38 (5%) This language is good for beginners</li>
<li>28 (5%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">22 (5%) This language makes it easy to shoot yourself in the foot</li>
<li>49 (5%) I regularly use this language</li>
<li>73 (6%) This language is best for very large projects</li>
<li class="supNeg">18 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li>30 (6%) I often get angry when writing code in this language</li>
<li>40 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>46 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>60 (7%) The resources for learning this language are of high quality</li>
<li class="supPos">76 (7%) This language has a high quality implementation</li>
<li>37 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li>60 (7%) Programs written in this language tend to play well with others</li>
<li>32 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li>57 (7%) I would use this language for a web project</li>
<li class="supPos">88 (7%) This is a high level language</li>
<li class="supPos">80 (7%) I find this language easy to prototype in</li>
<li>61 (7%) Code written in this language is very readable</li>
<li>59 (7%) Code written in this language tends to be terse</li>
<li>45 (8%) I would use this language for mobile applications</li>
<li class="supNeg">24 (8%) Code written in this language tends to be verbose</li>
<li>55 (8%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>47 (8%) This language has many features which feel "tacked on"</li>
<li>40 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">91 (8%) This language encourages writing reusable code.</li>
<li>33 (8%) I usually use this language on projects with many other members</li>
<li>25 (9%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>43 (9%) I can imagine using this language in my day job</li>
<li>57 (9%) This language has a good library distribution mechanism.</li>
<li>52 (9%) This language is very flexible</li>
<li>63 (9%) I would use this language for casual scripting</li>
<li>40 (9%) I know many other people who use this language</li>
<li class="supPos">84 (9%) This language encourages writing code that is easy to maintain.</li>
<li>53 (9%) This language is built on a small core of orthogonal features</li>
<li>38 (9%) This language is minimal</li>
<li class="supPos">82 (9%) I use this language out of choice</li>
<li>51 (9%) There are many good tools for this language</li>
</ul>
<ul>
<li class="supPos">77 (3%) This is a high level language</li>
<li class="supNeg">15 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>36 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>27 (4%) There are many good commercial tools for this language</li>
<li>41 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>67 (5%) I find this language easy to prototype in</li>
<li class="supNeg">15 (5%) This is a mainstream language</li>
<li class="supNeg">7 (5%) I know many other people who use this language</li>
<li>67 (6%) I use this language out of choice</li>
<li>74 (6%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>54 (6%) This language would be good for teaching children to write software</li>
<li>25 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>31 (6%) There are many good open-source tools for this language</li>
<li class="supNeg">17 (7%) I can imagine using this language in my day job</li>
<li>25 (7%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">21 (7%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">24 (7%) This is a low level language</li>
<li>50 (8%) Programs written in this language will usually work in future versions of the language</li>
<li>43 (8%) I would use this language for a desktop GUI project</li>
<li class="supNeg">18 (8%) I usually use this language on projects with many other members</li>
<li>34 (8%) This language excels at concurrency</li>
<li>29 (8%) Libraries in this language tend to be well documented.</li>
<li>42 (8%) This language is suitable for real-time applications</li>
<li>39 (8%) I would use this language for writing embedded programs</li>
<li>37 (8%) This language has many features which feel "tacked on"</li>
<li class="supPos">87 (9%) I enjoy playing with this language but would never use it for "real code"</li>
<li>57 (9%) This language encourages writing code that is easy to maintain.</li>
<li>62 (9%) This language has unusual features that I often miss when using other languages</li>
<li>38 (9%) I would use this language for writing server programs</li>
<li>72 (9%) This language is expressive</li>
</ul>
<ul>
<li>48 (3%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">11 (3%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">13 (4%) I would use this language for writing server programs</li>
<li>54 (4%) Code written in this language is very readable</li>
<li>28 (5%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>38 (5%) This language has a very dogmatic community</li>
<li class="supNeg">14 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">7 (5%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">8 (5%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">18 (5%) This language excels at symbolic manipulation</li>
<li>40 (6%) There are many good tools for this language</li>
<li>56 (6%) I know this language well</li>
<li class="supNeg">14 (6%) This language is very flexible</li>
<li>28 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">8 (6%) I enjoy using this language</li>
<li class="supNeg">10 (6%) I can imagine using this language in my day job</li>
<li class="supNeg">13 (7%) I usually use this language on solo projects</li>
<li>37 (7%) This language is best for very large projects</li>
<li>48 (7%) This is a mainstream language</li>
<li>50 (7%) This language encourages writing code that is easy to maintain.</li>
<li>56 (7%) It's unusual for me to discover unfamiliar features</li>
<li>44 (7%) This is a low level language</li>
<li>51 (7%) It is easy to tell at a glance what code in this language does</li>
<li>35 (7%) I use many applications written in this language</li>
<li>46 (7%) This language has a high quality implementation</li>
<li class="supNeg">15 (8%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">13 (8%) This language is good for distributed computing</li>
<li>32 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>29 (9%) I usually use this language on projects with many other members</li>
<li class="supNeg">19 (9%) This language is likely to have a strong influence on future languages</li>
<li>56 (9%) This is a high level language</li>
<li class="supNeg">16 (9%) There are many good open-source tools for this language</li>
<li class="supPos">82 (9%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (9%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">15 (9%) I regularly use this language</li>
<li>67 (9%) I enjoy playing with this language but would never use it for "real code"</li>
</ul>
<ul>
<li class="supNeg">20 (1%) This language excels at concurrency</li>
<li class="supNeg">16 (2%) This language is good for distributed computing</li>
<li>45 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">17 (2%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">13 (4%) Programs written in this language tend to play well with others</li>
<li>30 (4%) I regularly use this language</li>
<li>42 (5%) This language is well documented</li>
<li class="supPos">85 (5%) This language has a niche outside of which I would not use it</li>
<li class="supNeg">14 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">16 (6%) I use many applications written in this language</li>
<li class="supNeg">19 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">23 (7%) This language is best for very large projects</li>
<li>46 (7%) Code written in this language is very readable</li>
<li>56 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">10 (7%) This is a low level language</li>
<li class="supPos">75 (7%) This language has a very coherent design</li>
<li>58 (7%) This language excels at symbolic manipulation</li>
<li>33 (7%) This language is large</li>
<li>29 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">20 (8%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">23 (8%) This language is good for beginners</li>
<li class="supNeg">23 (8%) There are many good tools for this language</li>
<li class="supNeg">22 (8%) There is a wide variety of open source code written in this language</li>
<li>59 (9%) This language is good for scientific computing</li>
<li class="supNeg">19 (9%) I would use this language for a desktop GUI project</li>
<li class="supNeg">22 (9%) I know many other people who use this language</li>
<li>33 (9%) This language is likely to be around for a very long time</li>
<li class="supPos">88 (9%) This is a high level language</li>
<li>37 (9%) This language is best for very small projects</li>
</ul>
</div>
k-means with k = 17
<tabled class="data" id="clusters17">
  <trd>
    <tdd>Assembler,0.0</tdd>
  </trd>
  <trd>
    <tdd>Erlang,0.0</tdd>
  </trd>
  <trd>
    <tdd>D,5.0</tdd>
    <tdd>Go,5.0</tdd>
    <tdd>Ada,7.0</tdd>
    <tdd>Eiffel,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>Groovy,8.0</tdd>
    <tdd>Forth,10.0</tdd>
  </trd>
  <trd>
    <tdd>Agda,0.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,0.0</tdd>
  </trd>
  <trd>
    <tdd>TCL,5.0</tdd>
    <tdd>ELisp,6.0</tdd>
    <tdd>AWK,6.0</tdd>
    <tdd>Shell,7.0</tdd>
    <tdd>Prolog,8.0</tdd>
  </trd>
  <trd>
    <tdd>Haskell,0.0</tdd>
  </trd>
  <trd>
    <tdd>R,5.0</tdd>
    <tdd>Matlab,5.0</tdd>
    <tdd>Mathematica,5.0</tdd>
    <tdd>APL,8.0</tdd>
  </trd>
  <trd>
    <tdd>F#,4.0</tdd>
    <tdd>Scala,4.0</tdd>
  </trd>
  <trd>
    <tdd>ActionScript,0.0</tdd>
  </trd>
  <trd>
    <tdd>Python,5.0</tdd>
    <tdd>Ruby,5.0</tdd>
    <tdd>Clojure,6.0</tdd>
  </trd>
  <trd>
    <tdd>Common Lisp,6.0</tdd>
    <tdd>Lua,6.0</tdd>
    <tdd>Scheme,6.0</tdd>
    <tdd>Smalltalk,6.0</tdd>
    <tdd>Factor,7.0</tdd>
    <tdd>Io,7.0</tdd>
  </trd>
  <trd>
    <tdd>Javascript,7.0</tdd>
    <tdd>Objective C,7.0</tdd>
    <tdd>C#,8.0</tdd>
    <tdd>C++,9.0</tdd>
    <tdd>Java,9.0</tdd>
    <tdd>Perl,9.0</tdd>
    <tdd>PHP,10.0</tdd>
    <tdd>C,12.0</tdd>
  </trd>
  <trd>
    <tdd>REBOL,0.0</tdd>
  </trd>
  <trd>
    <tdd>O'Caml,5.0</tdd>
    <tdd>Standard ML,5.0</tdd>
    <tdd>J,7.0</tdd>
  </trd>
  <trd>
    <tdd>Pascal,5.0</tdd>
    <tdd>Fortran,6.0</tdd>
    <tdd>Delphi,6.0</tdd>
    <tdd>Cobol,7.0</tdd>
    <tdd>Visual Basic,7.0</tdd>
  </trd>
</tabled>
<div class="support" id="support17">
<ul></ul>
<ul></ul>
<ul>
<li>57 (4%) This language is expressive</li>
<li>43 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>62 (6%) I use this language out of choice</li>
<li>52 (6%) I find code written in this language very elegant</li>
<li>49 (6%) This language would be good for teaching children to write software</li>
<li>38 (6%) I enjoy using this language</li>
<li>42 (7%) I would list this language on my resume</li>
<li>33 (7%) This language is good for beginners</li>
<li>55 (8%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>39 (8%) I am reluctant to admit to knowing this language</li>
<li>42 (8%) There are many good commercial tools for this language</li>
<li>49 (8%) This language is likely to have a strong influence on future languages</li>
<li>30 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>34 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>46 (9%) I would use this language for writing server programs</li>
<li>48 (9%) This language has unusual features that I often miss when using other languages</li>
<li>48 (9%) This language matches it's problem domain particularly well.</li>
<li>29 (9%) I use many applications written in this language</li>
<li>32 (9%) This is a mainstream language</li>
</ul>
<ul></ul>
<ul></ul>
<ul>
<li>57 (3%) I use this language out of choice</li>
<li class="supNeg">15 (4%) When I write code in this language I can be very sure it is correct</li>
<li>43 (4%) Code written in this language tends to be terse</li>
<li class="supNeg">11 (4%) Programs written in this language tend to be efficient</li>
<li>35 (4%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>70 (4%) I find this language easy to prototype in</li>
<li>26 (4%) This language is good for beginners</li>
<li>49 (5%) The resources for learning this language are of high quality</li>
<li>32 (5%) There are many good commercial tools for this language</li>
<li>28 (5%) I would use this language for mobile applications</li>
<li class="supNeg">9 (5%) This language is good for distributed computing</li>
<li>51 (6%) This language is unusually bad for beginners</li>
<li class="supNeg">24 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>58 (6%) Programs written in this language will usually work in future versions of the language</li>
<li>47 (6%) Code written in this language is very readable</li>
<li>36 (7%) Code written in this language tends to be verbose</li>
<li class="supNeg">22 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>31 (7%) Code written in this language tends to be very reliable</li>
<li>50 (7%) I learned this language early in my career as a programmer</li>
<li>52 (7%) This language has a high quality implementation</li>
<li class="supNeg">23 (7%) This language is large</li>
<li>54 (7%) This language is minimal</li>
<li>50 (7%) I often get angry when writing code in this language</li>
<li>25 (7%) This language is suitable for real-time applications</li>
<li>43 (7%) I am reluctant to admit to knowing this language</li>
<li>48 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">13 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>34 (8%) Writing code in this language is a lot of work</li>
<li>25 (8%) This language is likely to have a strong influence on future languages</li>
<li>26 (8%) This is a low level language</li>
<li>30 (8%) It is easy to debug programs written in this language when it goes wrong</li>
<li>52 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>60 (8%) This language matches it's problem domain particularly well.</li>
<li>60 (8%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">14 (8%) This language has a strong static type system</li>
<li>36 (9%) This language has a very dogmatic community</li>
<li class="supNeg">18 (9%) I can imagine using this language in my day job</li>
<li>39 (9%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">18 (9%) I would use this language for writing server programs</li>
<li class="supNeg">16 (9%) This language is good for numeric computing</li>
<li>45 (9%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">17 (9%) This language excels at concurrency</li>
<li>34 (9%) I would use this language for a web project</li>
<li class="supPos">82 (9%) This language has a niche outside of which I would not use it</li>
<li>29 (9%) This language would be good for teaching children to write software</li>
<li class="supNeg">24 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>51 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li>41 (9%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>40 (9%) This language is well documented</li>
</ul>
<ul></ul>
<ul>
<li>45 (1%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>45 (2%) This language has a very rigid idea of how things should be done</li>
<li>42 (2%) There is a lot of accidental complexity when writing code in this language</li>
<li>64 (2%) This language has an annoying syntax</li>
<li class="supNeg">19 (2%) This language is good for distributed computing</li>
<li>28 (2%) Writing code in this language is a lot of work</li>
<li class="supPos">83 (2%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">19 (3%) This language has a strong static type system</li>
<li class="supNeg">24 (3%) This language excels at concurrency</li>
<li class="supPos">89 (3%) This language has a niche outside of which I would not use it</li>
<li>53 (3%) I would use this language for casual scripting</li>
<li>38 (3%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">22 (4%) I would use this language for a web project</li>
<li class="supPos">91 (4%) This language is good for numeric computing</li>
<li class="supNeg">17 (4%) This language is best for very large projects</li>
<li class="supNeg">18 (4%) This is a low level language</li>
<li>30 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>49 (4%) This language is large</li>
<li>49 (4%) This language encourages writing reusable code.</li>
<li class="supPos">80 (4%) I find this language easy to prototype in</li>
<li>33 (4%) I usually use this language on projects with many other members</li>
<li>43 (4%) This language makes it easy to shoot yourself in the foot</li>
<li>34 (4%) This language has unusual features that I often miss when using other languages</li>
<li>39 (4%) I would like to write more of this language than I currently do</li>
<li class="supNeg">4 (5%) I would use this language for writing server programs</li>
<li>32 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li>50 (5%) I find it easy to write efficient code in this language</li>
<li>47 (5%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">8 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li>50 (5%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>28 (5%) This language is suitable for real-time applications</li>
<li>46 (5%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>46 (6%) This language has a very dogmatic community</li>
<li>27 (6%) I would use this language for a desktop GUI project</li>
<li>31 (6%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>49 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">14 (6%) I would use this language for mobile applications</li>
<li>56 (7%) This language is unusually bad for beginners</li>
<li class="supPos">83 (7%) This is a high level language</li>
<li class="supNeg">12 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>48 (7%) Code written in this language is very readable</li>
<li>36 (7%) This language is likely to have a strong influence on future languages</li>
<li>40 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>53 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>35 (8%) Programs written in this language tend to be efficient</li>
<li class="supNeg">16 (8%) This language excels at text processing</li>
<li>34 (8%) Code written in this language tends to be very reliable</li>
<li>43 (8%) This language is best for very small projects</li>
<li class="supNeg">22 (8%) I enjoy using this language</li>
<li class="supNeg">22 (8%) I would use this language to write a command-line app</li>
<li>49 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>38 (8%) This language is good for beginners</li>
<li>26 (8%) When I write code in this language I can be very sure it is correct</li>
<li>31 (8%) I would use this language for writing embedded programs</li>
<li>56 (8%) I use this language out of choice</li>
<li>48 (9%) This language encourages writing code that is easy to maintain.</li>
<li>55 (9%) I often get angry when writing code in this language</li>
<li class="supPos">87 (9%) This language is good for scientific computing</li>
<li>33 (9%) I use many applications written in this language</li>
</ul>
<ul>
<li>45 (0%) This is a mainstream language</li>
<li class="supPos">85 (0%) I find this language easy to prototype in</li>
<li>66 (0%) Code written in this language tends to be very reliable</li>
<li class="supPos">96 (0%) This language encourages writing reusable code.</li>
<li class="supPos">78 (0%) This language has a strong static type system</li>
<li>61 (0%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">19 (0%) This is a low level language</li>
<li>37 (0%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">92 (0%) This is a high level language</li>
<li class="supPos">90 (0%) I find it easy to write efficient code in this language</li>
<li>73 (1%) I would use this language for casual scripting</li>
<li class="supNeg">10 (1%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>55 (1%) This language matches it's problem domain particularly well.</li>
<li>59 (1%) This language has many features which feel "tacked on"</li>
<li class="supPos">82 (1%) This language is likely to have a strong influence on future languages</li>
<li>71 (1%) I would use this language for a desktop GUI project</li>
<li>54 (1%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">16 (1%) I learned this language early in my career as a programmer</li>
<li>53 (1%) This language is likely to be around for a very long time</li>
<li>38 (1%) This language is best for very small projects</li>
<li>71 (2%) Programs written in this language tend to play well with others</li>
<li>45 (2%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>69 (2%) This language has a high quality implementation</li>
<li>28 (2%) This language is minimal</li>
<li class="supPos">84 (2%) This language encourages writing code that is easy to maintain.</li>
<li>63 (2%) It is easy to tell at a glance what code in this language does</li>
<li>62 (2%) Libraries in this language tend to be well documented.</li>
<li>68 (2%) Code written in this language is very readable</li>
<li>26 (2%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>64 (2%) This language has a good library distribution mechanism.</li>
<li>57 (2%) I often feel like I am not smart enough to write this language</li>
<li class="supPos">76 (3%) I find code written in this language very elegant</li>
<li>54 (3%) I regularly use this language</li>
<li>70 (3%) This language has a very coherent design</li>
<li>73 (3%) I enjoy using this language</li>
<li>64 (3%) There are many good tools for this language</li>
<li class="supPos">94 (3%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">21 (3%) Writing code in this language is a lot of work</li>
<li class="supNeg">22 (3%) Code written in this language tends to be verbose</li>
<li class="supNeg">18 (3%) There is a lot of accidental complexity when writing code in this language</li>
<li>67 (3%) It is easy to debug programs written in this language when it goes wrong</li>
<li>37 (3%) This language has a very dogmatic community</li>
<li>31 (3%) I would use this language for writing programs for an embedded hardware platform</li>
<li>46 (3%) This language is well documented</li>
<li class="supPos">95 (3%) I use this language out of choice</li>
<li>56 (4%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>43 (4%) This language is good for beginners</li>
<li>45 (4%) I use many applications written in this language</li>
<li>48 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">81 (4%) I would use this language to write a command-line app</li>
<li>57 (4%) This language excels at text processing</li>
<li>25 (4%) This language makes it easy to shoot yourself in the foot</li>
<li>39 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>38 (4%) This language has a very rigid idea of how things should be done</li>
<li>42 (4%) I know many other people who use this language</li>
<li>61 (5%) This language is good for distributed computing</li>
<li>36 (5%) This language is built on a small core of orthogonal features</li>
<li>40 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>43 (5%) This language would be good for teaching children to write software</li>
<li class="supPos">82 (5%) This language is expressive</li>
<li class="supPos">92 (6%) I know this language well</li>
<li>53 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">16 (6%) I am reluctant to admit to knowing this language</li>
<li>54 (6%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">84 (6%) I would use this language for writing server programs</li>
<li>57 (6%) This language is suitable for real-time applications</li>
<li class="supPos">86 (6%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">75 (6%) This language is good for numeric computing</li>
<li>55 (7%) Programs written in this language tend to be efficient</li>
<li class="supNeg">20 (7%) This language has a niche in which it is great</li>
<li>57 (7%) Code written in this language tends to be terse</li>
<li>50 (7%) This language is unusually bad for beginners</li>
<li>65 (8%) I can imagine using this language in my day job</li>
<li class="supPos">75 (8%) Learning this language improved my ability as a programmer</li>
<li>66 (8%) This language has a good community</li>
<li>46 (8%) When I write code in this language I can be very sure it is correct</li>
<li>71 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>32 (8%) I often get angry when writing code in this language</li>
<li>66 (8%) This language excels at concurrency</li>
<li>70 (8%) This language is good for scientific computing</li>
<li>72 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">90 (9%) I can imagine this will be a popular language in twenty years time</li>
<li>40 (9%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>68 (9%) This language excels at symbolic manipulation</li>
<li>74 (9%) This language is likely to be a passing fad</li>
<li>34 (9%) I would use this language for writing embedded programs</li>
<li class="supPos">82 (9%) I would list this language on my resume</li>
<li>71 (9%) This language has unusual features that I often miss when using other languages</li>
</ul>
<ul></ul>
<ul>
<li>68 (0%) I still discover new features of this language on a fairly regular basis</li>
<li class="supPos">86 (1%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">76 (2%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supPos">95 (2%) I find this language easy to prototype in</li>
<li class="supPos">83 (3%) This language has a good community</li>
<li>51 (3%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">83 (3%) This is a high level language</li>
<li>63 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">85 (3%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">19 (3%) This is a low level language</li>
<li>25 (4%) This language has a niche in which it is great</li>
<li>30 (4%) Code written in this language tends to be verbose</li>
<li>51 (5%) Code written in this language tends to be terse</li>
<li class="supNeg">7 (5%) Writing code in this language is a lot of work</li>
<li>32 (5%) When I write code in this language I can be very sure it is correct</li>
<li>56 (5%) There are many good commercial tools for this language</li>
<li>47 (5%) Code written in this language tends to be very reliable</li>
<li>37 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>25 (5%) I learned this language early in my career as a programmer</li>
<li class="supPos">75 (5%) I would use this language for a desktop GUI project</li>
<li>36 (5%) This language makes it easy to shoot yourself in the foot</li>
<li>71 (5%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">21 (5%) This language has an annoying syntax</li>
<li>43 (6%) Programs written in this language will usually work in future versions of the language</li>
<li>49 (6%) I enjoy using this language</li>
<li>67 (6%) I would use this language for writing server programs</li>
<li>65 (6%) This language is best for very large projects</li>
<li>73 (6%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">93 (6%) I use this language out of choice</li>
<li>31 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>66 (6%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supPos">83 (6%) This language encourages writing reusable code.</li>
<li>28 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supPos">80 (7%) There are many good open-source tools for this language</li>
<li>29 (7%) I would use this language for writing embedded programs</li>
<li>69 (7%) I find code written in this language very elegant</li>
<li>68 (7%) I would use this language for mobile applications</li>
<li>66 (7%) I know this language well</li>
<li class="supNeg">23 (7%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>71 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">19 (7%) This language has a strong static type system</li>
<li>66 (7%) Programs written in this language tend to play well with others</li>
<li>72 (8%) I would list this language on my resume</li>
<li class="supNeg">20 (8%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">90 (8%) I would use this language to write a command-line app</li>
<li>50 (8%) This language is large</li>
<li>48 (9%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>44 (9%) This language is suitable for real-time applications</li>
<li>33 (9%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>35 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>65 (9%) This language excels at symbolic manipulation</li>
<li>32 (9%) This language excels at concurrency</li>
<li>68 (9%) This language has a very coherent design</li>
<li class="supNeg">24 (9%) I am reluctant to admit to knowing this language</li>
<li class="supPos">85 (9%) This language is expressive</li>
</ul>
<ul>
<li>29 (3%) This language is good for distributed computing</li>
<li>59 (4%) This language has a good community</li>
<li>61 (4%) This language encourages writing code that is easy to maintain.</li>
<li>30 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">23 (4%) When I write code in this language I can be very sure it is correct</li>
<li>27 (5%) This language excels at concurrency</li>
<li>35 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>35 (5%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>68 (5%) I use this language out of choice</li>
<li>46 (5%) This language is suitable for real-time applications</li>
<li>27 (5%) This is a low level language</li>
<li class="supPos">80 (5%) This is a high level language</li>
<li class="supNeg">17 (5%) This language has a strong static type system</li>
<li>45 (5%) This language excels at text processing</li>
<li>32 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">79 (6%) This language is very flexible</li>
<li>69 (7%) This language is expressive</li>
<li>43 (7%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>40 (7%) This language has many features which feel "tacked on"</li>
<li>38 (7%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">22 (7%) I can imagine using this language in my day job</li>
<li class="supPos">80 (7%) I find this language easy to prototype in</li>
<li class="supNeg">23 (7%) Writing code in this language is a lot of work</li>
<li>41 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>42 (8%) Programs written in this language tend to be efficient</li>
<li class="supNeg">24 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">81 (8%) This language encourages writing reusable code.</li>
<li class="supPos">78 (8%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>39 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>38 (8%) This language makes it easy to shoot yourself in the foot</li>
<li>44 (8%) I usually use this language on solo projects</li>
<li>55 (9%) I would use this language for mobile applications</li>
<li>57 (9%) This language has unusual features that I often miss when using other languages</li>
<li>33 (9%) I would use this language for writing server programs</li>
<li>50 (9%) I would use this language for a desktop GUI project</li>
<li>72 (9%) I find code written in this language very elegant</li>
<li>32 (9%) This language has an annoying syntax</li>
</ul>
<ul>
<li>35 (3%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>25 (5%) This language excels at concurrency</li>
<li>54 (8%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>33 (8%) I find code written in this language very elegant</li>
<li>62 (9%) This is a high level language</li>
<li class="supNeg">20 (9%) When I write code in this language I can be very sure it is correct</li>
<li>44 (9%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>48 (9%) Code written in this language is very readable</li>
<li>38 (9%) I would like to write more of this language than I currently do</li>
</ul>
<ul></ul>
<ul>
<li>60 (0%) Programs written in this language will usually work in future versions of the language</li>
<li>59 (1%) Code written in this language is very readable</li>
<li>30 (2%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">76 (2%) I use this language out of choice</li>
<li>35 (2%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>54 (2%) This language is very flexible</li>
<li>36 (2%) There are many good commercial tools for this language</li>
<li class="supPos">80 (3%) This is a high level language</li>
<li>66 (3%) This language has unusual features that I often miss when using other languages</li>
<li>62 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>65 (3%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">76 (4%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>36 (4%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>50 (4%) This language is large</li>
<li class="supPos">77 (4%) I find it easy to write efficient code in this language</li>
<li>34 (4%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>59 (4%) I would like to write more of this language than I currently do</li>
<li>34 (4%) Writing code in this language is a lot of work</li>
<li>32 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li>37 (5%) This language excels at concurrency</li>
<li>35 (5%) This language has a very rigid idea of how things should be done</li>
<li class="supPos">86 (5%) This language is expressive</li>
<li>56 (5%) I usually use this language on solo projects</li>
<li>56 (5%) This language is unusually bad for beginners</li>
<li>57 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li>34 (5%) Developers who primarily use this language often burn out after a few years</li>
<li>38 (5%) I often get angry when writing code in this language</li>
<li class="supNeg">19 (6%) This is a low level language</li>
<li>48 (6%) This language is likely to be a passing fad</li>
<li>40 (6%) I learned this language early in my career as a programmer</li>
<li class="supNeg">15 (6%) I am reluctant to admit to knowing this language</li>
<li>44 (6%) This language would be good for teaching children to write software</li>
<li>54 (6%) This language is minimal</li>
<li class="supPos">77 (6%) Learning this language improved my ability as a programmer</li>
<li class="supPos">78 (6%) I find code written in this language very elegant</li>
<li>74 (6%) Code written in this language tends to be very reliable</li>
<li>56 (7%) I would use this language for casual scripting</li>
<li>44 (7%) There are many good open-source tools for this language</li>
<li class="supPos">76 (7%) This language has a very coherent design</li>
<li>33 (7%) This language is best for very small projects</li>
<li>30 (7%) I use many applications written in this language</li>
<li>54 (7%) This language has a good community</li>
<li>43 (7%) Programs written in this language tend to play well with others</li>
<li>39 (7%) This language is likely to be around for a very long time</li>
<li>29 (7%) There is a wide variety of open source code written in this language</li>
<li>37 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>73 (8%) This language is good for numeric computing</li>
<li class="supNeg">10 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>43 (8%) I often feel like I am not smart enough to write this language</li>
<li class="supPos">75 (8%) I find this language easy to prototype in</li>
<li class="supNeg">23 (8%) This is a mainstream language</li>
<li class="supNeg">12 (8%) Code written in this language tends to be verbose</li>
<li>29 (8%) I usually use this language on projects with many other members</li>
<li>30 (8%) This language is good for distributed computing</li>
<li>46 (9%) When I write code in this language I can be very sure it is correct</li>
<li>29 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>44 (9%) I would use this language for a desktop GUI project</li>
<li>38 (9%) I would use this language for mobile applications</li>
<li>50 (9%) This language has an annoying syntax</li>
<li>68 (9%) This language is good for scientific computing</li>
<li>47 (9%) I would use this language for writing embedded programs</li>
<li>57 (9%) This language is suitable for real-time applications</li>
</ul>
<ul>
<li>48 (3%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">11 (3%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">13 (4%) I would use this language for writing server programs</li>
<li>54 (4%) Code written in this language is very readable</li>
<li>28 (5%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>38 (5%) This language has a very dogmatic community</li>
<li class="supNeg">14 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">7 (5%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">8 (5%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">18 (5%) This language excels at symbolic manipulation</li>
<li>40 (6%) There are many good tools for this language</li>
<li>56 (6%) I know this language well</li>
<li class="supNeg">14 (6%) This language is very flexible</li>
<li>28 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">8 (6%) I enjoy using this language</li>
<li class="supNeg">10 (6%) I can imagine using this language in my day job</li>
<li class="supNeg">13 (7%) I usually use this language on solo projects</li>
<li>37 (7%) This language is best for very large projects</li>
<li>48 (7%) This is a mainstream language</li>
<li>50 (7%) This language encourages writing code that is easy to maintain.</li>
<li>56 (7%) It's unusual for me to discover unfamiliar features</li>
<li>44 (7%) This is a low level language</li>
<li>51 (7%) It is easy to tell at a glance what code in this language does</li>
<li>35 (7%) I use many applications written in this language</li>
<li>46 (7%) This language has a high quality implementation</li>
<li class="supNeg">15 (8%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">13 (8%) This language is good for distributed computing</li>
<li>32 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>29 (9%) I usually use this language on projects with many other members</li>
<li class="supNeg">19 (9%) This language is likely to have a strong influence on future languages</li>
<li>56 (9%) This is a high level language</li>
<li class="supNeg">16 (9%) There are many good open-source tools for this language</li>
<li class="supPos">82 (9%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (9%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">15 (9%) I regularly use this language</li>
<li>67 (9%) I enjoy playing with this language but would never use it for "real code"</li>
</ul>
<ul></ul>
</div>
k-means with k = 18
<tabled class="data" id="clusters18">
  <trd>
    <tdd>O'Caml,5.0</tdd>
    <tdd>F#,6.0</tdd>
    <tdd>Go,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>D,7.0</tdd>
    <tdd>Clojure,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Erlang,8.0</tdd>
    <tdd>Scala,8.0</tdd>
    <tdd>Eiffel,8.0</tdd>
    <tdd>Ada,9.0</tdd>
    <tdd>Haskell,9.0</tdd>
  </trd>
  <trd>
    <tdd>Mathematica,0.0</tdd>
  </trd>
  <trd>
    <tdd>C#,4.0</tdd>
    <tdd>Java,4.0</tdd>
  </trd>
  <trd>
    <tdd>ActionScript,0.0</tdd>
  </trd>
  <trd>
    <tdd>Objective C,6.0</tdd>
    <tdd>Groovy,6.0</tdd>
    <tdd>Javascript,7.0</tdd>
    <tdd>Delphi,7.0</tdd>
  </trd>
  <trd>
    <tdd>PHP,4.0</tdd>
    <tdd>Visual Basic,4.0</tdd>
  </trd>
  <trd>
    <tdd>Perl,0.0</tdd>
  </trd>
  <trd>
    <tdd>Python,4.0</tdd>
    <tdd>Ruby,4.0</tdd>
  </trd>
  <trd>
    <tdd>Fortran,5.0</tdd>
    <tdd>Cobol,6.0</tdd>
    <tdd>Pascal,6.0</tdd>
  </trd>
  <trd>
    <tdd>Scheme,5.0</tdd>
    <tdd>Smalltalk,5.0</tdd>
    <tdd>Lua,6.0</tdd>
  </trd>
  <trd>
    <tdd>Haxe,0.0</tdd>
  </trd>
  <trd>
    <tdd>TCL,5.0</tdd>
    <tdd>ELisp,6.0</tdd>
    <tdd>AWK,6.0</tdd>
    <tdd>Shell,7.0</tdd>
    <tdd>Prolog,8.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,6.0</tdd>
    <tdd>Io,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>Forth,8.0</tdd>
    <tdd>J,8.0</tdd>
    <tdd>APL,8.0</tdd>
    <tdd>REBOL,11.0</tdd>
  </trd>
  <trd>
    <tdd>R,4.0</tdd>
    <tdd>Matlab,4.0</tdd>
  </trd>
  <trd>
    <tdd>C,6.0</tdd>
    <tdd>C++,6.0</tdd>
  </trd>
  <trd>
    <tdd>Assembler,0.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,7.0</tdd>
    <tdd>Agda,7.0</tdd>
  </trd>
</tabled>
<div class="support" id="support18">
<ul>
<li>38 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>35 (7%) This is a mainstream language</li>
<li>34 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>63 (7%) Code written in this language is very readable</li>
<li>34 (8%) I use many applications written in this language</li>
<li>39 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">86 (9%) This language encourages writing reusable code.</li>
<li>36 (9%) I usually use this language on projects with many other members</li>
<li>43 (9%) There are many good commercial tools for this language</li>
<li>63 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>37 (9%) I would use this language for writing programs for an embedded hardware platform</li>
<li>46 (9%) This language would be good for teaching children to write software</li>
<li>57 (9%) Programs written in this language tend to play well with others</li>
</ul>
<ul></ul>
<ul>
<li>52 (0%) I can imagine this will be a popular language in twenty years time</li>
<li>60 (0%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">15 (0%) This language is minimal</li>
<li>66 (0%) This is a high level language</li>
<li>46 (0%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supPos">83 (0%) This language encourages writing reusable code.</li>
<li class="supPos">99 (0%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>56 (0%) This language is good for numeric computing</li>
<li>37 (0%) This is a low level language</li>
<li class="supPos">88 (0%) The resources for learning this language are of high quality</li>
<li>64 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>71 (0%) This language is likely to be around for a very long time</li>
<li class="supPos">98 (1%) I know many other people who use this language</li>
<li>37 (1%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>41 (1%) This language is unusually bad for beginners</li>
<li>34 (1%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>48 (1%) This language is expressive</li>
<li>64 (1%) This language has a strong static type system</li>
<li>49 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>47 (1%) Programs written in this language tend to be efficient</li>
<li>54 (1%) This language is good for scientific computing</li>
<li class="supPos">86 (1%) This language is large</li>
<li class="supPos">98 (1%) Libraries in this language tend to be well documented.</li>
<li>52 (2%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>36 (2%) Learning this language improved my ability as a programmer</li>
<li class="supPos">81 (2%) This language encourages writing code that is easy to maintain.</li>
<li>45 (2%) This language excels at text processing</li>
<li>46 (2%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">75 (2%) I would use this language for writing server programs</li>
<li>62 (2%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">20 (2%) This language is built on a small core of orthogonal features</li>
<li>50 (2%) This language is good for distributed computing</li>
<li class="supPos">83 (2%) I find it easy to write efficient code in this language</li>
<li class="supPos">94 (2%) This language is best for very large projects</li>
<li class="supPos">80 (2%) I find this language easy to prototype in</li>
<li class="supPos">81 (2%) I use many applications written in this language</li>
<li>55 (2%) I still discover new features of this language on a fairly regular basis</li>
<li>65 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">96 (3%) There are many good commercial tools for this language</li>
<li>39 (3%) This language excels at symbolic manipulation</li>
<li>53 (3%) This language is good for beginners</li>
<li>38 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>36 (3%) I find code written in this language very elegant</li>
<li>30 (3%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>53 (3%) I would use this language for casual scripting</li>
<li>30 (3%) This language has unusual features that I often miss when using other languages</li>
<li>37 (4%) This language is very flexible</li>
<li class="supPos">95 (4%) This is a mainstream language</li>
<li class="supNeg">15 (4%) I often feel like I am not smart enough to write this language</li>
<li>53 (4%) I learned this language early in my career as a programmer</li>
<li class="supNeg">4 (4%) This language has a niche in which it is great</li>
<li>50 (4%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>68 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>61 (4%) Code written in this language tends to be very reliable</li>
<li>39 (4%) I would like to write more of this language than I currently do</li>
<li>67 (4%) This language has a good library distribution mechanism.</li>
<li class="supPos">78 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>57 (4%) Code written in this language is very readable</li>
<li>55 (4%) This language has a very coherent design</li>
<li class="supPos">87 (4%) It is easy to tell at a glance what code in this language does</li>
<li>35 (4%) This language matches it's problem domain particularly well.</li>
<li>74 (4%) Programs written in this language tend to play well with others</li>
<li class="supPos">95 (4%) This language has a high quality implementation</li>
<li>52 (4%) I enjoy using this language</li>
<li>66 (4%) This language has a good community</li>
<li class="supNeg">5 (5%) The semantics of this language are much different than other languages I know.</li>
<li>39 (5%) This language is likely to be a passing fad</li>
<li>74 (5%) This language has a very dogmatic community</li>
<li>31 (5%) This language excels at concurrency</li>
<li>32 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">17 (5%) This language has a niche outside of which I would not use it</li>
<li>34 (5%) When I write code in this language I can be very sure it is correct</li>
<li>51 (6%) This language would be good for teaching children to write software</li>
<li class="supPos">80 (6%) This language has many features which feel "tacked on"</li>
<li class="supNeg">18 (6%) This language is best for very small projects</li>
<li>41 (6%) I would use this language for writing embedded programs</li>
<li>27 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">93 (6%) This language is well documented</li>
<li>37 (6%) Writing code in this language is a lot of work</li>
<li class="supPos">93 (6%) I would use this language for mobile applications</li>
<li>74 (6%) I would use this language for a web project</li>
<li class="supPos">92 (7%) It is easy to debug programs written in this language when it goes wrong</li>
<li>56 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">92 (7%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>52 (7%) This language is suitable for real-time applications</li>
<li>43 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">89 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>54 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>73 (9%) It's unusual for me to discover unfamiliar features</li>
<li>51 (9%) I can imagine using this language in my day job</li>
<li>67 (9%) I would use this language to write a command-line app</li>
<li>26 (9%) Code written in this language tends to be terse</li>
<li class="supPos">76 (9%) I know this language well</li>
</ul>
<ul></ul>
<ul>
<li>63 (1%) There are many good commercial tools for this language</li>
<li>58 (3%) I often get angry when writing code in this language</li>
<li>66 (3%) This language has many features which feel "tacked on"</li>
<li>46 (3%) This language is large</li>
<li>63 (4%) Programs written in this language will usually work in future versions of the language</li>
<li>55 (4%) Programs written in this language tend to play well with others</li>
<li>30 (4%) This language excels at concurrency</li>
<li>29 (5%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">21 (5%) When I write code in this language I can be very sure it is correct</li>
<li>55 (5%) This language has a good library distribution mechanism.</li>
<li>38 (5%) Learning this language improved my ability as a programmer</li>
<li>54 (5%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>31 (5%) This language is good for distributed computing</li>
<li>55 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li>44 (6%) It's unusual for me to discover unfamiliar features</li>
<li>56 (6%) The resources for learning this language are of high quality</li>
<li>37 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>61 (6%) I use this language out of choice</li>
<li>60 (7%) This language encourages writing code that is easy to maintain.</li>
<li>60 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>41 (7%) This language has a very coherent design</li>
<li>38 (7%) This language excels at symbolic manipulation</li>
<li>41 (7%) This language has a very dogmatic community</li>
<li>68 (7%) This is a high level language</li>
<li>52 (7%) Code written in this language is very readable</li>
<li>29 (7%) Learning this language significantly changed how I use other languages.</li>
<li>54 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>38 (7%) This language is likely to have a strong influence on future languages</li>
<li>56 (8%) There are many good tools for this language</li>
<li>43 (8%) It is easy to debug programs written in this language when it goes wrong</li>
<li>44 (8%) I would like to write more of this language than I currently do</li>
<li class="supNeg">23 (8%) I often feel like I am not smart enough to write this language</li>
<li>45 (8%) I find code written in this language very elegant</li>
<li>48 (8%) This language is unusually bad for beginners</li>
<li>29 (8%) Code written in this language tends to be terse</li>
<li>34 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>54 (8%) Libraries in this language tend to be well documented.</li>
<li>30 (9%) I enjoy using this language</li>
<li>31 (9%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>69 (9%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>34 (9%) This language matches it's problem domain particularly well.</li>
<li>49 (9%) This language is expressive</li>
<li>34 (9%) This language is minimal</li>
<li>57 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>62 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>31 (9%) I can imagine using this language in my day job</li>
</ul>
<ul>
<li class="supNeg">0 (0%) Learning this language significantly changed how I use other languages.</li>
<li>37 (0%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">20 (0%) This language excels at concurrency</li>
<li>54 (0%) Libraries in this language tend to be well documented.</li>
<li>44 (0%) I find it easy to write efficient code in this language</li>
<li class="supNeg">8 (0%) This language is built on a small core of orthogonal features</li>
<li>71 (0%) This language has an annoying syntax</li>
<li>55 (0%) Code written in this language is very readable</li>
<li>31 (0%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">3 (0%) I enjoy using this language</li>
<li>30 (0%) This language has a very dogmatic community</li>
<li>35 (0%) This language encourages writing reusable code.</li>
<li>35 (0%) Writing code in this language is a lot of work</li>
<li>30 (1%) This language is best for very large projects</li>
<li class="supNeg">11 (1%) Programs written in this language tend to be efficient</li>
<li class="supNeg">21 (1%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>30 (1%) Programs written in this language will usually work in future versions of the language</li>
<li class="supNeg">21 (1%) This language is good for numeric computing</li>
<li>65 (1%) I find this language easy to prototype in</li>
<li>27 (1%) This language is suitable for real-time applications</li>
<li>26 (1%) This language is expressive</li>
<li class="supNeg">14 (2%) I can imagine using this language in my day job</li>
<li>35 (2%) This is a low level language</li>
<li class="supPos">92 (2%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">12 (2%) This language is good for distributed computing</li>
<li class="supNeg">4 (2%) I would use this language for writing programs for an embedded hardware platform</li>
<li>25 (2%) I would use this language as a scripting language embedded inside a larger application</li>
<li>32 (2%) I would use this language to write a command-line app</li>
<li class="supPos">83 (2%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">4 (2%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">5 (2%) Learning this language improved my ability as a programmer</li>
<li class="supNeg">5 (2%) This language has unusual features that I often miss when using other languages</li>
<li>59 (2%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">8 (3%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">16 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>37 (3%) This language is likely to be around for a very long time</li>
<li>48 (3%) This language is good for beginners</li>
<li>62 (3%) I know this language well</li>
<li>64 (3%) There is a lot of accidental complexity when writing code in this language</li>
<li>44 (3%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">79 (3%) This language has many features which feel "tacked on"</li>
<li class="supNeg">10 (3%) I often feel like I am not smart enough to write this language</li>
<li>30 (3%) I would use this language for mobile applications</li>
<li>61 (3%) It is easy to tell at a glance what code in this language does</li>
<li>33 (4%) This language has a high quality implementation</li>
<li>52 (4%) This language is large</li>
<li>66 (4%) This is a high level language</li>
<li class="supNeg">4 (4%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>39 (4%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">16 (4%) This language is likely to have a strong influence on future languages</li>
<li>54 (4%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">14 (4%) I would use this language for writing embedded programs</li>
<li class="supNeg">4 (4%) Code written in this language tends to be very reliable</li>
<li>37 (5%) Programs written in this language tend to play well with others</li>
<li>69 (5%) There are many good commercial tools for this language</li>
<li>61 (5%) The resources for learning this language are of high quality</li>
<li>50 (5%) There are many good tools for this language</li>
<li class="supNeg">12 (5%) The semantics of this language are much different than other languages I know.</li>
<li>48 (5%) This language has a good library distribution mechanism.</li>
<li>62 (5%) This language is likely to be a passing fad</li>
<li class="supNeg">24 (5%) This language excels at symbolic manipulation</li>
<li>34 (5%) I use this language out of choice</li>
<li class="supNeg">18 (6%) Code written in this language tends to be terse</li>
<li>48 (6%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">20 (6%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>45 (6%) This language encourages writing code that is easy to maintain.</li>
<li>53 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li>38 (6%) This language is best for very small projects</li>
<li>59 (7%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">87 (7%) I often get angry when writing code in this language</li>
<li>48 (7%) This language excels at text processing</li>
<li class="supNeg">7 (7%) I would like to write more of this language than I currently do</li>
<li>45 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">88 (8%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supNeg">20 (8%) This language is good for scientific computing</li>
<li class="supNeg">12 (8%) I find code written in this language very elegant</li>
<li class="supPos">91 (8%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">15 (8%) I can imagine this will be a popular language in twenty years time</li>
<li>62 (9%) Code written in this language tends to be verbose</li>
<li class="supNeg">9 (9%) This language has a very coherent design</li>
<li>55 (9%) I would use this language for casual scripting</li>
<li class="supNeg">21 (9%) This language has a strong static type system</li>
<li>52 (9%) This language would be good for teaching children to write software</li>
</ul>
<ul></ul>
<ul>
<li>36 (0%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supPos">78 (0%) This language is expressive</li>
<li>25 (0%) This language has an annoying syntax</li>
<li class="supPos">77 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>56 (0%) This language is large</li>
<li>60 (0%) There are many good commercial tools for this language</li>
<li>73 (0%) Learning this language improved my ability as a programmer</li>
<li class="supPos">78 (0%) This language encourages writing reusable code.</li>
<li>29 (0%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">83 (0%) This language is best for very small projects</li>
<li class="supNeg">21 (0%) This is a low level language</li>
<li class="supPos">88 (0%) This language would be good for teaching children to write software</li>
<li>68 (0%) I still discover new features of this language on a fairly regular basis</li>
<li>71 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>40 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>67 (1%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">87 (1%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>52 (2%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">21 (2%) I often feel like I am not smart enough to write this language</li>
<li>63 (2%) This language has a very dogmatic community</li>
<li class="supNeg">15 (2%) This language is unusually bad for beginners</li>
<li class="supPos">96 (2%) I would use this language to write a command-line app</li>
<li>52 (2%) I find it easy to write efficient code in this language</li>
<li>37 (2%) This language is good for distributed computing</li>
<li>43 (2%) Code written in this language tends to be very reliable</li>
<li>48 (2%) Code written in this language tends to be terse</li>
<li>67 (2%) I use many applications written in this language</li>
<li>28 (2%) This language has a niche in which it is great</li>
<li>59 (2%) This language excels at symbolic manipulation</li>
<li>64 (2%) I find code written in this language very elegant</li>
<li>33 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">75 (2%) Libraries in this language tend to be well documented.</li>
<li>71 (2%) I know this language well</li>
<li class="supPos">82 (2%) This language has a good community</li>
<li>61 (3%) This language is best for very large projects</li>
<li class="supPos">80 (3%) This language excels at text processing</li>
<li>62 (3%) This language has many features which feel "tacked on"</li>
<li class="supPos">75 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supPos">95 (3%) I find this language easy to prototype in</li>
<li>33 (3%) This language is built on a small core of orthogonal features</li>
<li>65 (3%) I usually use this language on solo projects</li>
<li>65 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>45 (3%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>51 (3%) I would like to write more of this language than I currently do</li>
<li class="supPos">96 (3%) This language has a good library distribution mechanism.</li>
<li class="supPos">84 (3%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>51 (3%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">14 (4%) This language has a strong static type system</li>
<li class="supPos">83 (4%) This is a high level language</li>
<li>73 (4%) I know many other people who use this language</li>
<li class="supNeg">4 (4%) Writing code in this language is a lot of work</li>
<li>63 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">76 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">88 (4%) There is a wide variety of open source code written in this language</li>
<li>28 (4%) I learned this language early in my career as a programmer</li>
<li>68 (4%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>73 (4%) This is a mainstream language</li>
<li>31 (4%) Code written in this language tends to be verbose</li>
<li class="supPos">94 (5%) The resources for learning this language are of high quality</li>
<li class="supPos">94 (5%) I would use this language for a web project</li>
<li>38 (5%) This language is suitable for real-time applications</li>
<li>62 (5%) I usually use this language on projects with many other members</li>
<li>27 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>46 (5%) I enjoy using this language</li>
<li>64 (5%) I would use this language for writing server programs</li>
<li class="supPos">94 (5%) I would use this language for casual scripting</li>
<li>64 (5%) It is easy to debug programs written in this language when it goes wrong</li>
<li>60 (6%) I regularly use this language</li>
<li>36 (6%) This language is minimal</li>
<li class="supPos">77 (6%) I would use this language for a desktop GUI project</li>
<li>70 (6%) Programs written in this language tend to play well with others</li>
<li>32 (6%) When I write code in this language I can be very sure it is correct</li>
<li>28 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>28 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>41 (7%) This language matches it's problem domain particularly well.</li>
<li class="supPos">92 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>44 (7%) Programs written in this language will usually work in future versions of the language</li>
<li class="supNeg">24 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">91 (7%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>27 (7%) This language excels at concurrency</li>
<li class="supPos">76 (7%) I would list this language on my resume</li>
<li class="supPos">82 (7%) There are many good open-source tools for this language</li>
<li>74 (7%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">91 (8%) I use this language out of choice</li>
<li class="supNeg">21 (8%) This language has a very rigid idea of how things should be done</li>
<li>27 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>40 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>28 (8%) I would use this language for writing embedded programs</li>
<li>29 (8%) I am reluctant to admit to knowing this language</li>
<li>51 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>67 (8%) I would use this language for mobile applications</li>
<li>63 (9%) This language has a very coherent design</li>
<li class="supPos">86 (9%) This language is well documented</li>
<li>66 (9%) There are many good tools for this language</li>
</ul>
<ul>
<li>48 (0%) This language makes it easy to shoot yourself in the foot</li>
<li>35 (1%) This language is best for very large projects</li>
<li>37 (1%) The resources for learning this language are of high quality</li>
<li>35 (2%) There are many good tools for this language</li>
<li>46 (2%) This language has a very coherent design</li>
<li class="supNeg">13 (2%) I can imagine this will be a popular language in twenty years time</li>
<li>31 (2%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supNeg">5 (3%) I enjoy using this language</li>
<li>32 (3%) I know many other people who use this language</li>
<li>49 (3%) This is a high level language</li>
<li class="supNeg">7 (3%) I regularly use this language</li>
<li>29 (3%) I use many applications written in this language</li>
<li class="supNeg">5 (4%) I can imagine using this language in my day job</li>
<li class="supNeg">15 (4%) This language excels at symbolic manipulation</li>
<li>48 (4%) It is easy to tell at a glance what code in this language does</li>
<li>42 (4%) This is a mainstream language</li>
<li>63 (4%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>39 (4%) This language has a very dogmatic community</li>
<li class="supNeg">11 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">12 (4%) I would use this language for writing server programs</li>
<li>31 (5%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>26 (5%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>49 (5%) There are many good commercial tools for this language</li>
<li>54 (5%) Code written in this language is very readable</li>
<li class="supNeg">22 (6%) I would use this language for casual scripting</li>
<li class="supNeg">10 (6%) This language is very flexible</li>
<li>25 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">9 (6%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">19 (6%) I would use this language for a desktop GUI project</li>
<li>46 (6%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">6 (6%) This language has unusual features that I often miss when using other languages</li>
<li>69 (6%) I often get angry when writing code in this language</li>
<li>72 (6%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">11 (6%) This language excels at text processing</li>
<li>56 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>50 (7%) This language has a high quality implementation</li>
<li class="supNeg">10 (7%) This language is best for very small projects</li>
<li class="supNeg">10 (7%) I usually use this language on solo projects</li>
<li>39 (7%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>57 (7%) I know this language well</li>
<li>53 (7%) This language has many features which feel "tacked on"</li>
<li>48 (7%) This is a low level language</li>
<li class="supNeg">17 (7%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">21 (7%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">16 (7%) This language is expressive</li>
<li>64 (8%) Programs written in this language will usually work in future versions of the language</li>
<li>31 (8%) This language has a good library distribution mechanism.</li>
<li>47 (8%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">11 (8%) This language is good for distributed computing</li>
<li>27 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">18 (8%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">24 (8%) I usually use this language on projects with many other members</li>
<li class="supPos">87 (9%) I learned this language early in my career as a programmer</li>
<li>28 (9%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">12 (9%) This language has a good community</li>
<li>57 (9%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">19 (9%) This language excels at concurrency</li>
<li>40 (9%) Code written in this language tends to be very reliable</li>
<li>41 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
</ul>
<ul>
<li>27 (1%) This language is good for distributed computing</li>
<li>61 (1%) This language has a good community</li>
<li>25 (1%) When I write code in this language I can be very sure it is correct</li>
<li>30 (1%) I would use this language for writing server programs</li>
<li>30 (2%) This language makes it easy to shoot yourself in the foot</li>
<li>38 (2%) I usually use this language on solo projects</li>
<li class="supNeg">14 (2%) This language has a strong static type system</li>
<li>32 (2%) I usually use this language on projects with many other members</li>
<li>46 (3%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>38 (3%) This language is frequently used for applications it isn't suitable for</li>
<li>48 (3%) This language excels at text processing</li>
<li class="supPos">95 (3%) This language would be good for teaching children to write software</li>
<li>41 (3%) Programs written in this language tend to be efficient</li>
<li>35 (3%) I would use this language for writing programs for an embedded hardware platform</li>
<li>39 (4%) This is a mainstream language</li>
<li>43 (4%) This language is good for scientific computing</li>
<li>39 (4%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">82 (4%) I find this language easy to prototype in</li>
<li>32 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>36 (4%) I know many other people who use this language</li>
<li>51 (4%) I would use this language for a web project</li>
<li>47 (4%) This language is suitable for real-time applications</li>
<li>42 (4%) Code written in this language tends to be terse</li>
<li>64 (4%) This language encourages writing code that is easy to maintain.</li>
<li>41 (4%) I use many applications written in this language</li>
<li>41 (4%) Libraries in this language tend to be well documented.</li>
<li>71 (5%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>72 (5%) I use this language out of choice</li>
<li>26 (5%) This is a low level language</li>
<li>48 (5%) There are many good commercial tools for this language</li>
<li>67 (5%) This language has a high quality implementation</li>
<li class="supPos">80 (5%) This is a high level language</li>
<li>46 (5%) This language is well documented</li>
<li class="supNeg">16 (5%) I am reluctant to admit to knowing this language</li>
<li>48 (5%) Programs written in this language will usually work in future versions of the language</li>
<li>26 (5%) This language excels at concurrency</li>
<li>39 (5%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">21 (5%) I often get angry when writing code in this language</li>
<li>36 (5%) This language has many features which feel "tacked on"</li>
<li>68 (6%) I would like to write more of this language than I currently do</li>
<li>61 (6%) I would use this language for mobile applications</li>
<li>46 (6%) There are many good open-source tools for this language</li>
<li>40 (6%) I learned this language early in my career as a programmer</li>
<li>38 (6%) This language is good for numeric computing</li>
<li>26 (6%) This language has an annoying syntax</li>
<li>69 (6%) This language is expressive</li>
<li class="supNeg">19 (6%) Writing code in this language is a lot of work</li>
<li>56 (6%) This language has unusual features that I often miss when using other languages</li>
<li>45 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>55 (7%) I can imagine this will be a popular language in twenty years time</li>
<li>35 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>44 (7%) I still discover new features of this language on a fairly regular basis</li>
<li>25 (7%) I can imagine using this language in my day job</li>
<li>56 (7%) I would use this language for a desktop GUI project</li>
<li class="supPos">87 (7%) This language is good for beginners</li>
<li>47 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>55 (8%) This language has a good library distribution mechanism.</li>
<li>71 (8%) It is easy to tell at a glance what code in this language does</li>
<li>47 (8%) There is a wide variety of open source code written in this language</li>
<li class="supPos">77 (8%) This language is very flexible</li>
<li>49 (8%) I would list this language on my resume</li>
<li class="supNeg">19 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">83 (9%) This language encourages writing reusable code.</li>
<li class="supPos">79 (9%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supPos">76 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li>62 (9%) I find it easy to write efficient code in this language</li>
<li>63 (9%) This language is likely to have a strong influence on future languages</li>
<li>68 (9%) Code written in this language is very readable</li>
<li class="supPos">87 (9%) This language has a very coherent design</li>
<li>26 (9%) This language is unusually bad for beginners</li>
<li>39 (9%) This language is likely to be a passing fad</li>
<li>41 (9%) I often write things in this language with the intent of rewriting them in something else later</li>
</ul>
<ul></ul>
<ul>
<li>57 (3%) I use this language out of choice</li>
<li class="supNeg">15 (4%) When I write code in this language I can be very sure it is correct</li>
<li>43 (4%) Code written in this language tends to be terse</li>
<li class="supNeg">11 (4%) Programs written in this language tend to be efficient</li>
<li>35 (4%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>70 (4%) I find this language easy to prototype in</li>
<li>26 (4%) This language is good for beginners</li>
<li>49 (5%) The resources for learning this language are of high quality</li>
<li>32 (5%) There are many good commercial tools for this language</li>
<li>28 (5%) I would use this language for mobile applications</li>
<li class="supNeg">9 (5%) This language is good for distributed computing</li>
<li>51 (6%) This language is unusually bad for beginners</li>
<li class="supNeg">24 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>58 (6%) Programs written in this language will usually work in future versions of the language</li>
<li>47 (6%) Code written in this language is very readable</li>
<li>36 (7%) Code written in this language tends to be verbose</li>
<li class="supNeg">22 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>31 (7%) Code written in this language tends to be very reliable</li>
<li>50 (7%) I learned this language early in my career as a programmer</li>
<li>52 (7%) This language has a high quality implementation</li>
<li class="supNeg">23 (7%) This language is large</li>
<li>54 (7%) This language is minimal</li>
<li>50 (7%) I often get angry when writing code in this language</li>
<li>25 (7%) This language is suitable for real-time applications</li>
<li>43 (7%) I am reluctant to admit to knowing this language</li>
<li>48 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">13 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>34 (8%) Writing code in this language is a lot of work</li>
<li>25 (8%) This language is likely to have a strong influence on future languages</li>
<li>26 (8%) This is a low level language</li>
<li>30 (8%) It is easy to debug programs written in this language when it goes wrong</li>
<li>52 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>60 (8%) This language matches it's problem domain particularly well.</li>
<li>60 (8%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">14 (8%) This language has a strong static type system</li>
<li>36 (9%) This language has a very dogmatic community</li>
<li class="supNeg">18 (9%) I can imagine using this language in my day job</li>
<li>39 (9%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">18 (9%) I would use this language for writing server programs</li>
<li class="supNeg">16 (9%) This language is good for numeric computing</li>
<li>45 (9%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">17 (9%) This language excels at concurrency</li>
<li>34 (9%) I would use this language for a web project</li>
<li class="supPos">82 (9%) This language has a niche outside of which I would not use it</li>
<li>29 (9%) This language would be good for teaching children to write software</li>
<li class="supNeg">24 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>51 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li>41 (9%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>40 (9%) This language is well documented</li>
</ul>
<ul>
<li class="supNeg">15 (5%) This is a mainstream language</li>
<li>35 (5%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">16 (5%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>38 (6%) This language has many features which feel "tacked on"</li>
<li>35 (6%) This language is well documented</li>
<li class="supNeg">23 (7%) There is a wide variety of open source code written in this language</li>
<li>31 (7%) There are many good commercial tools for this language</li>
<li class="supNeg">11 (7%) I know many other people who use this language</li>
<li class="supNeg">11 (8%) I can imagine using this language in my day job</li>
<li>64 (8%) I use this language out of choice</li>
<li>53 (8%) This language makes it easy to shoot yourself in the foot</li>
<li>25 (8%) When I write code in this language I can be very sure it is correct</li>
<li>27 (8%) There are many good open-source tools for this language</li>
<li>37 (8%) The resources for learning this language are of high quality</li>
<li>70 (8%) I find this language easy to prototype in</li>
<li class="supPos">87 (8%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">76 (9%) This language has a very coherent design</li>
<li>49 (9%) I know this language well</li>
<li class="supNeg">15 (9%) I usually use this language on projects with many other members</li>
<li>58 (9%) I would use this language for casual scripting</li>
<li class="supNeg">22 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>43 (9%) Code written in this language is very readable</li>
<li class="supNeg">21 (9%) This language has a strong static type system</li>
<li>32 (9%) This language excels at concurrency</li>
</ul>
<ul>
<li>49 (0%) This language is large</li>
<li>40 (0%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">22 (0%) This language has a strong static type system</li>
<li class="supNeg">13 (0%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">21 (0%) This language is good for distributed computing</li>
<li>30 (0%) This language has unusual features that I often miss when using other languages</li>
<li>65 (0%) This language has an annoying syntax</li>
<li>30 (0%) This language is suitable for real-time applications</li>
<li>41 (1%) Code written in this language tends to be terse</li>
<li>46 (1%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>40 (1%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">21 (1%) This is a low level language</li>
<li>41 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>35 (1%) I usually use this language on projects with many other members</li>
<li class="supNeg">18 (1%) This language is built on a small core of orthogonal features</li>
<li>47 (1%) This language is frequently used for applications it isn't suitable for</li>
<li>66 (1%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>54 (1%) Code written in this language is very readable</li>
<li>27 (1%) This language excels at concurrency</li>
<li>53 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">80 (2%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>44 (2%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">13 (2%) This language is best for very large projects</li>
<li>43 (2%) This language is best for very small projects</li>
<li>49 (2%) This language is unusually bad for beginners</li>
<li>55 (2%) This language is well suited for an agile development approach using short iterations.</li>
<li>56 (2%) This language excels at symbolic manipulation</li>
<li>42 (2%) I usually use this language on solo projects</li>
<li>31 (2%) I can imagine using this language in my day job</li>
<li class="supPos">81 (2%) I enjoy playing with this language but would never use it for "real code"</li>
<li>53 (2%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>56 (2%) I would use this language for casual scripting</li>
<li>26 (3%) This language is minimal</li>
<li>51 (3%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>54 (3%) This language is likely to be a passing fad</li>
<li>58 (3%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>51 (3%) This language is well documented</li>
<li>29 (3%) Programs written in this language tend to be efficient</li>
<li>28 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>30 (3%) Writing code in this language is a lot of work</li>
<li class="supPos">82 (3%) This is a high level language</li>
<li>36 (3%) I would use this language as a scripting language embedded inside a larger application</li>
<li>41 (3%) This language has a very dogmatic community</li>
<li>48 (4%) This language encourages writing reusable code.</li>
<li>47 (4%) It is easy to tell at a glance what code in this language does</li>
<li>49 (4%) The semantics of this language are much different than other languages I know.</li>
<li>54 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>47 (4%) This is a mainstream language</li>
<li class="supNeg">21 (4%) This language excels at text processing</li>
<li>42 (4%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supPos">92 (4%) This language is good for numeric computing</li>
<li class="supPos">88 (5%) This language has a niche outside of which I would not use it</li>
<li class="supNeg">7 (5%) I would use this language for writing server programs</li>
<li>38 (5%) This language has a very coherent design</li>
<li class="supNeg">23 (5%) Learning this language significantly changed how I use other languages.</li>
<li>36 (5%) I regularly use this language</li>
<li>48 (5%) There are many good tools for this language</li>
<li>35 (5%) This language would be good for teaching children to write software</li>
<li>42 (5%) I would like to write more of this language than I currently do</li>
<li class="supPos">78 (5%) I find this language easy to prototype in</li>
<li>42 (5%) I use many applications written in this language</li>
<li class="supPos">94 (5%) This language is good for scientific computing</li>
<li>49 (5%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">22 (5%) I would use this language for a web project</li>
<li class="supNeg">23 (5%) Learning this language improved my ability as a programmer</li>
<li>58 (5%) This language has many features which feel "tacked on"</li>
<li>57 (6%) This language has a high quality implementation</li>
<li>67 (6%) This language has a niche in which it is great</li>
<li>45 (6%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">6 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>51 (6%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">24 (6%) I would use this language for a desktop GUI project</li>
<li>32 (6%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>34 (6%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">13 (6%) I would use this language for mobile applications</li>
<li>44 (6%) Code written in this language tends to be verbose</li>
<li>31 (6%) I learned this language early in my career as a programmer</li>
<li>53 (6%) I find it easy to write efficient code in this language</li>
<li>55 (7%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>31 (7%) I often feel like I am not smart enough to write this language</li>
<li>38 (7%) This language is good for beginners</li>
<li>45 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">21 (8%) When I write code in this language I can be very sure it is correct</li>
<li>62 (8%) I know many other people who use this language</li>
<li>37 (8%) I find code written in this language very elegant</li>
<li class="supPos">83 (8%) This language matches it's problem domain particularly well.</li>
<li>45 (9%) This language is likely to be around for a very long time</li>
<li>41 (9%) There is a wide variety of open source code written in this language</li>
<li>42 (9%) I would list this language on my resume</li>
<li class="supNeg">17 (9%) I enjoy using this language</li>
<li>26 (9%) I would use this language for writing embedded programs</li>
<li>28 (9%) It's unusual for me to discover unfamiliar features</li>
<li>30 (9%) Code written in this language tends to be very reliable</li>
</ul>
<ul>
<li>55 (0%) I can imagine this will be a popular language in twenty years time</li>
<li>73 (0%) This language is good for numeric computing</li>
<li class="supNeg">18 (0%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">78 (0%) I usually use this language on projects with many other members</li>
<li>43 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>39 (0%) I would like to write more of this language than I currently do</li>
<li>55 (0%) Libraries in this language tend to be well documented.</li>
<li class="supPos">77 (0%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">87 (0%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">82 (0%) There are many good open-source tools for this language</li>
<li class="supPos">98 (1%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supPos">98 (1%) I find it easy to write efficient code in this language</li>
<li class="supNeg">4 (1%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">86 (1%) There are many good commercial tools for this language</li>
<li class="supPos">76 (1%) There are many good tools for this language</li>
<li class="supPos">88 (1%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>47 (2%) I often feel like I am not smart enough to write this language</li>
<li>56 (2%) This language has a strong static type system</li>
<li class="supPos">97 (2%) I use many applications written in this language</li>
<li class="supPos">93 (2%) This language has a high quality implementation</li>
<li>39 (2%) I would use this language for casual scripting</li>
<li>44 (2%) I find this language easy to prototype in</li>
<li class="supPos">87 (2%) This is a mainstream language</li>
<li class="supNeg">7 (2%) I am reluctant to admit to knowing this language</li>
<li>36 (2%) This language has a very coherent design</li>
<li>43 (3%) This language has a very dogmatic community</li>
<li class="supPos">85 (3%) I know many other people who use this language</li>
<li>31 (3%) This language has a niche outside of which I would not use it</li>
<li class="supPos">84 (3%) Programs written in this language tend to be efficient</li>
<li>33 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>60 (3%) I would use this language for mobile applications</li>
<li class="supPos">92 (3%) Learning this language improved my ability as a programmer</li>
<li>47 (3%) This language has a good library distribution mechanism.</li>
<li class="supNeg">21 (3%) This language excels at concurrency</li>
<li>37 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">78 (4%) The resources for learning this language are of high quality</li>
<li class="supPos">95 (4%) This language is suitable for real-time applications</li>
<li>33 (4%) This language is well suited for an agile development approach using short iterations.</li>
<li>29 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">75 (4%) I know this language well</li>
<li>28 (4%) I find code written in this language very elegant</li>
<li>62 (4%) Writing code in this language is a lot of work</li>
<li class="supPos">95 (4%) Programs written in this language will usually work in future versions of the language</li>
<li>40 (4%) Learning this language significantly changed how I use other languages.</li>
<li>61 (4%) Code written in this language tends to be verbose</li>
<li>56 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>38 (4%) This language has a good community</li>
<li>28 (4%) This language excels at symbolic manipulation</li>
<li>41 (4%) It is easy to tell at a glance what code in this language does</li>
<li>36 (5%) I would use this language for a web project</li>
<li class="supNeg">19 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">5 (5%) I use this language out of choice</li>
<li>49 (5%) This language encourages writing code that is easy to maintain.</li>
<li>49 (6%) This is a high level language</li>
<li>69 (6%) This language is best for very large projects</li>
<li class="supPos">78 (6%) I would use this language to write a command-line app</li>
<li class="supPos">93 (6%) There is a wide variety of open source code written in this language</li>
<li>45 (6%) Code written in this language is very readable</li>
<li>57 (6%) I often get angry when writing code in this language</li>
<li>68 (6%) This language is good for scientific computing</li>
<li>34 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (7%) I enjoy using this language</li>
<li>34 (7%) Code written in this language tends to be very reliable</li>
<li class="supPos">82 (7%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>73 (8%) This language is very flexible</li>
<li>69 (8%) This is a low level language</li>
<li>31 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">91 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>27 (8%) This language excels at text processing</li>
<li>41 (8%) Code written in this language tends to be terse</li>
<li>46 (8%) I would use this language for writing server programs</li>
<li class="supPos">83 (9%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">90 (9%) This language is likely to be around for a very long time</li>
</ul>
<ul></ul>
<ul>
<li>35 (0%) I would use this language for writing embedded programs</li>
<li class="supNeg">0 (0%) This is a mainstream language</li>
<li>69 (0%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">20 (0%) This language excels at concurrency</li>
<li class="supNeg">20 (1%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">21 (1%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">20 (1%) I can imagine using this language in my day job</li>
<li>52 (1%) Code written in this language is very readable</li>
<li>58 (1%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>68 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>61 (1%) This language excels at symbolic manipulation</li>
<li class="supPos">79 (1%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">97 (2%) Learning this language improved my ability as a programmer</li>
<li>47 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">83 (2%) I use this language out of choice</li>
<li>30 (2%) This language is best for very large projects</li>
<li class="supPos">97 (2%) I often feel like I am not smart enough to write this language</li>
<li>53 (2%) I enjoy using this language</li>
<li>54 (2%) Writing code in this language is a lot of work</li>
<li class="supNeg">15 (3%) This language is good for distributed computing</li>
<li class="supNeg">16 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">17 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">23 (3%) This language is good for numeric computing</li>
<li class="supPos">81 (3%) This language has a very coherent design</li>
<li>32 (3%) This language is large</li>
<li class="supPos">95 (4%) When I write code in this language I can be very sure it is correct</li>
<li>29 (4%) I regularly use this language</li>
<li class="supPos">95 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">4 (4%) Programs written in this language tend to be efficient</li>
<li>40 (4%) This language is well documented</li>
<li class="supPos">95 (4%) This language has a strong static type system</li>
<li class="supPos">82 (4%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>64 (4%) I would like to write more of this language than I currently do</li>
<li class="supNeg">15 (4%) Programs written in this language tend to play well with others</li>
<li class="supPos">94 (5%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">81 (5%) This language has a niche outside of which I would not use it</li>
<li class="supNeg">5 (5%) This is a low level language</li>
<li class="supNeg">5 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>58 (5%) This language is likely to be a passing fad</li>
<li>57 (5%) This language is good for scientific computing</li>
<li>39 (5%) This language has a good library distribution mechanism.</li>
<li>74 (5%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">89 (5%) This is a high level language</li>
<li class="supNeg">19 (5%) There are many good tools for this language</li>
<li>67 (6%) This language encourages writing reusable code.</li>
<li>58 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li>46 (6%) This language has an annoying syntax</li>
<li class="supNeg">8 (6%) I often get angry when writing code in this language</li>
<li class="supNeg">22 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">7 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">80 (8%) I find code written in this language very elegant</li>
<li class="supNeg">13 (8%) I use many applications written in this language</li>
<li>55 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>44 (8%) Code written in this language tends to be verbose</li>
<li class="supPos">84 (8%) This language is expressive</li>
<li class="supNeg">9 (9%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">24 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">22 (9%) Libraries in this language tend to be well documented.</li>
<li>49 (9%) I know this language well</li>
<li class="supNeg">10 (9%) I would use this language for writing server programs</li>
</ul>
<ul></ul>
</div>
k-means with k = 19
<tabled class="data" id="clusters19">
  <trd>
    <tdd>R,5.0</tdd>
    <tdd>Matlab,5.0</tdd>
    <tdd>Mathematica,6.0</tdd>
    <tdd>ActionScript,10.0</tdd>
  </trd>
  <trd>
    <tdd>Eiffel,5.0</tdd>
    <tdd>Ada,6.0</tdd>
    <tdd>Standard ML,6.0</tdd>
  </trd>
  <trd>
    <tdd>F#,4.0</tdd>
    <tdd>Scala,4.0</tdd>
  </trd>
  <trd>
    <tdd>Pascal,5.0</tdd>
    <tdd>Fortran,6.0</tdd>
    <tdd>Delphi,6.0</tdd>
    <tdd>Cobol,7.0</tdd>
    <tdd>Visual Basic,7.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,0.0</tdd>
  </trd>
  <trd>
    <tdd>D,3.0</tdd>
    <tdd>Go,3.0</tdd>
  </trd>
  <trd>
    <tdd>Python,4.0</tdd>
    <tdd>Ruby,4.0</tdd>
  </trd>
  <trd>
    <tdd>C#,6.0</tdd>
    <tdd>Java,7.0</tdd>
    <tdd>Objective C,7.0</tdd>
    <tdd>C++,8.0</tdd>
  </trd>
  <trd>
    <tdd>AWK,5.0</tdd>
    <tdd>TCL,5.0</tdd>
    <tdd>ELisp,6.0</tdd>
    <tdd>Shell,6.0</tdd>
  </trd>
  <trd>
    <tdd>Prolog,0.0</tdd>
  </trd>
  <trd>
    <tdd>APL,0.0</tdd>
  </trd>
  <trd>
    <tdd>C,0.0</tdd>
  </trd>
  <trd>
    <tdd>Common Lisp,6.0</tdd>
    <tdd>Clojure,6.0</tdd>
    <tdd>O'Caml,6.0</tdd>
    <tdd>Scheme,7.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Erlang,8.0</tdd>
    <tdd>Haskell,8.0</tdd>
  </trd>
  <trd>
    <tdd>Lua,5.0</tdd>
    <tdd>Groovy,5.0</tdd>
    <tdd>Haxe,5.0</tdd>
  </trd>
  <trd>
    <tdd>Assembler,0.0</tdd>
  </trd>
  <trd>
    <tdd>Agda,0.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,6.0</tdd>
    <tdd>Io,6.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
    <tdd>J,8.0</tdd>
    <tdd>Forth,9.0</tdd>
    <tdd>REBOL,10.0</tdd>
  </trd>
  <trd>
    <tdd>Javascript,5.0</tdd>
    <tdd>Perl,6.0</tdd>
    <tdd>PHP,6.0</tdd>
  </trd>
</tabled>
<div class="support" id="support19">
<ul>
<li>41 (1%) Code written in this language tends to be terse</li>
<li>41 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>53 (2%) Code written in this language is very readable</li>
<li>42 (2%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">24 (3%) This language excels at concurrency</li>
<li class="supNeg">18 (3%) This language is good for distributed computing</li>
<li>49 (3%) This language encourages writing reusable code.</li>
<li>50 (3%) This language is large</li>
<li>49 (3%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">21 (3%) This language excels at text processing</li>
<li>45 (4%) This is a mainstream language</li>
<li class="supPos">80 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li>35 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li>52 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>31 (4%) Writing code in this language is a lot of work</li>
<li class="supNeg">24 (5%) This language has a strong static type system</li>
<li>35 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>46 (5%) This language is best for very small projects</li>
<li>55 (5%) This language has many features which feel "tacked on"</li>
<li>52 (5%) I find it easy to write efficient code in this language</li>
<li>47 (5%) I usually use this language on solo projects</li>
<li>26 (5%) Learning this language significantly changed how I use other languages.</li>
<li>66 (5%) This language has an annoying syntax</li>
<li>27 (5%) Programs written in this language tend to be efficient</li>
<li>45 (5%) This language has a very dogmatic community</li>
<li class="supNeg">7 (5%) I would use this language for writing server programs</li>
<li>44 (6%) There are many good tools for this language</li>
<li class="supPos">88 (6%) This is a high level language</li>
<li>51 (6%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">24 (6%) When I write code in this language I can be very sure it is correct</li>
<li>32 (6%) I usually use this language on projects with many other members</li>
<li>45 (6%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>37 (6%) I would like to write more of this language than I currently do</li>
<li class="supPos">85 (6%) This language matches it's problem domain particularly well.</li>
<li>40 (7%) This language has a very rigid idea of how things should be done</li>
<li>49 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>57 (7%) I would use this language for casual scripting</li>
<li>28 (7%) I can imagine using this language in my day job</li>
<li class="supNeg">12 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>27 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">22 (8%) This is a low level language</li>
<li>31 (8%) I would use this language for writing embedded programs</li>
<li>36 (8%) I learned this language early in my career as a programmer</li>
<li>42 (8%) This language would be good for teaching children to write software</li>
<li>35 (8%) There is a wide variety of open source code written in this language</li>
<li>42 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>54 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">20 (9%) I would use this language to write a command-line app</li>
<li>36 (9%) Code written in this language tends to be very reliable</li>
<li class="supPos">85 (9%) I find this language easy to prototype in</li>
<li>32 (9%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">24 (9%) I enjoy using this language</li>
<li class="supNeg">21 (9%) It's unusual for me to discover unfamiliar features</li>
</ul>
<ul>
<li>33 (1%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">23 (1%) I still discover new features of this language on a fairly regular basis</li>
<li>26 (1%) There is a wide variety of open source code written in this language</li>
<li>41 (2%) Learning this language significantly changed how I use other languages.</li>
<li>32 (2%) I would use this language for a web project</li>
<li class="supNeg">23 (2%) I can imagine this will be a popular language in twenty years time</li>
<li>44 (2%) I would list this language on my resume</li>
<li>60 (2%) This language is good for numeric computing</li>
<li class="supNeg">22 (3%) I know many other people who use this language</li>
<li class="supNeg">22 (3%) This language makes it easy to shoot yourself in the foot</li>
<li>43 (3%) I would use this language for writing server programs</li>
<li>65 (4%) This language is well documented</li>
<li>28 (4%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>27 (4%) I can imagine using this language in my day job</li>
<li>32 (4%) This language is likely to be around for a very long time</li>
<li>53 (4%) I would like to write more of this language than I currently do</li>
<li>36 (5%) This language excels at concurrency</li>
<li>54 (5%) I learned this language early in my career as a programmer</li>
<li>33 (5%) This language excels at text processing</li>
<li>46 (5%) This language is very flexible</li>
<li>47 (5%) I would use this language to write a command-line app</li>
<li>48 (5%) This language would be good for teaching children to write software</li>
<li>39 (5%) There are many good commercial tools for this language</li>
<li>28 (5%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>30 (6%) This language is good for distributed computing</li>
<li>56 (6%) This language is good for scientific computing</li>
<li>71 (6%) This is a high level language</li>
<li>61 (6%) This language has a very dogmatic community</li>
<li>38 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supPos">84 (6%) This language encourages writing reusable code.</li>
<li>52 (6%) Programs written in this language tend to be efficient</li>
<li>30 (6%) There are many good open-source tools for this language</li>
<li>40 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>74 (6%) Learning this language improved my ability as a programmer</li>
<li>65 (6%) It is easy to tell at a glance what code in this language does</li>
<li>67 (7%) I find it easy to write efficient code in this language</li>
<li>44 (7%) This language has an annoying syntax</li>
<li>32 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">22 (7%) This language has a niche in which it is great</li>
<li>41 (7%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>57 (7%) When I write code in this language I can be very sure it is correct</li>
<li>66 (7%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">19 (7%) I regularly use this language</li>
<li>30 (7%) I use many applications written in this language</li>
<li>39 (7%) This language has a niche outside of which I would not use it</li>
<li>46 (7%) Programs written in this language tend to play well with others</li>
<li>66 (7%) Code written in this language is very readable</li>
<li>72 (8%) Code written in this language tends to be very reliable</li>
<li>36 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>33 (8%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">13 (8%) This language is best for very small projects</li>
<li>36 (8%) I would use this language for casual scripting</li>
<li>34 (8%) I would use this language for a desktop GUI project</li>
<li>62 (8%) I use this language out of choice</li>
<li>63 (8%) The resources for learning this language are of high quality</li>
<li>55 (8%) I find this language easy to prototype in</li>
<li>39 (8%) I usually use this language on projects with many other members</li>
<li>60 (8%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>41 (8%) This language matches it's problem domain particularly well.</li>
<li>70 (9%) This language is best for very large projects</li>
<li>43 (9%) Writing code in this language is a lot of work</li>
<li>42 (9%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>37 (9%) The semantics of this language are much different than other languages I know.</li>
</ul>
<ul>
<li>45 (0%) This is a mainstream language</li>
<li class="supPos">85 (0%) I find this language easy to prototype in</li>
<li>66 (0%) Code written in this language tends to be very reliable</li>
<li class="supPos">96 (0%) This language encourages writing reusable code.</li>
<li class="supPos">78 (0%) This language has a strong static type system</li>
<li>61 (0%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">19 (0%) This is a low level language</li>
<li>37 (0%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">92 (0%) This is a high level language</li>
<li class="supPos">90 (0%) I find it easy to write efficient code in this language</li>
<li>73 (1%) I would use this language for casual scripting</li>
<li class="supNeg">10 (1%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>55 (1%) This language matches it's problem domain particularly well.</li>
<li>59 (1%) This language has many features which feel "tacked on"</li>
<li class="supPos">82 (1%) This language is likely to have a strong influence on future languages</li>
<li>71 (1%) I would use this language for a desktop GUI project</li>
<li>54 (1%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">16 (1%) I learned this language early in my career as a programmer</li>
<li>53 (1%) This language is likely to be around for a very long time</li>
<li>38 (1%) This language is best for very small projects</li>
<li>71 (2%) Programs written in this language tend to play well with others</li>
<li>45 (2%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>69 (2%) This language has a high quality implementation</li>
<li>28 (2%) This language is minimal</li>
<li class="supPos">84 (2%) This language encourages writing code that is easy to maintain.</li>
<li>63 (2%) It is easy to tell at a glance what code in this language does</li>
<li>62 (2%) Libraries in this language tend to be well documented.</li>
<li>68 (2%) Code written in this language is very readable</li>
<li>26 (2%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>64 (2%) This language has a good library distribution mechanism.</li>
<li>57 (2%) I often feel like I am not smart enough to write this language</li>
<li class="supPos">76 (3%) I find code written in this language very elegant</li>
<li>54 (3%) I regularly use this language</li>
<li>70 (3%) This language has a very coherent design</li>
<li>73 (3%) I enjoy using this language</li>
<li>64 (3%) There are many good tools for this language</li>
<li class="supPos">94 (3%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">21 (3%) Writing code in this language is a lot of work</li>
<li class="supNeg">22 (3%) Code written in this language tends to be verbose</li>
<li class="supNeg">18 (3%) There is a lot of accidental complexity when writing code in this language</li>
<li>67 (3%) It is easy to debug programs written in this language when it goes wrong</li>
<li>37 (3%) This language has a very dogmatic community</li>
<li>31 (3%) I would use this language for writing programs for an embedded hardware platform</li>
<li>46 (3%) This language is well documented</li>
<li class="supPos">95 (3%) I use this language out of choice</li>
<li>56 (4%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>43 (4%) This language is good for beginners</li>
<li>45 (4%) I use many applications written in this language</li>
<li>48 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">81 (4%) I would use this language to write a command-line app</li>
<li>57 (4%) This language excels at text processing</li>
<li>25 (4%) This language makes it easy to shoot yourself in the foot</li>
<li>39 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>38 (4%) This language has a very rigid idea of how things should be done</li>
<li>42 (4%) I know many other people who use this language</li>
<li>61 (5%) This language is good for distributed computing</li>
<li>36 (5%) This language is built on a small core of orthogonal features</li>
<li>40 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>43 (5%) This language would be good for teaching children to write software</li>
<li class="supPos">82 (5%) This language is expressive</li>
<li class="supPos">92 (6%) I know this language well</li>
<li>53 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">16 (6%) I am reluctant to admit to knowing this language</li>
<li>54 (6%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">84 (6%) I would use this language for writing server programs</li>
<li>57 (6%) This language is suitable for real-time applications</li>
<li class="supPos">86 (6%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">75 (6%) This language is good for numeric computing</li>
<li>55 (7%) Programs written in this language tend to be efficient</li>
<li class="supNeg">20 (7%) This language has a niche in which it is great</li>
<li>57 (7%) Code written in this language tends to be terse</li>
<li>50 (7%) This language is unusually bad for beginners</li>
<li>65 (8%) I can imagine using this language in my day job</li>
<li class="supPos">75 (8%) Learning this language improved my ability as a programmer</li>
<li>66 (8%) This language has a good community</li>
<li>46 (8%) When I write code in this language I can be very sure it is correct</li>
<li>71 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>32 (8%) I often get angry when writing code in this language</li>
<li>66 (8%) This language excels at concurrency</li>
<li>70 (8%) This language is good for scientific computing</li>
<li>72 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">90 (9%) I can imagine this will be a popular language in twenty years time</li>
<li>40 (9%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>68 (9%) This language excels at symbolic manipulation</li>
<li>74 (9%) This language is likely to be a passing fad</li>
<li>34 (9%) I would use this language for writing embedded programs</li>
<li class="supPos">82 (9%) I would list this language on my resume</li>
<li>71 (9%) This language has unusual features that I often miss when using other languages</li>
</ul>
<ul>
<li>48 (3%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">11 (3%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">13 (4%) I would use this language for writing server programs</li>
<li>54 (4%) Code written in this language is very readable</li>
<li>28 (5%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>38 (5%) This language has a very dogmatic community</li>
<li class="supNeg">14 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">7 (5%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">8 (5%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">18 (5%) This language excels at symbolic manipulation</li>
<li>40 (6%) There are many good tools for this language</li>
<li>56 (6%) I know this language well</li>
<li class="supNeg">14 (6%) This language is very flexible</li>
<li>28 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">8 (6%) I enjoy using this language</li>
<li class="supNeg">10 (6%) I can imagine using this language in my day job</li>
<li class="supNeg">13 (7%) I usually use this language on solo projects</li>
<li>37 (7%) This language is best for very large projects</li>
<li>48 (7%) This is a mainstream language</li>
<li>50 (7%) This language encourages writing code that is easy to maintain.</li>
<li>56 (7%) It's unusual for me to discover unfamiliar features</li>
<li>44 (7%) This is a low level language</li>
<li>51 (7%) It is easy to tell at a glance what code in this language does</li>
<li>35 (7%) I use many applications written in this language</li>
<li>46 (7%) This language has a high quality implementation</li>
<li class="supNeg">15 (8%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">13 (8%) This language is good for distributed computing</li>
<li>32 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>29 (9%) I usually use this language on projects with many other members</li>
<li class="supNeg">19 (9%) This language is likely to have a strong influence on future languages</li>
<li>56 (9%) This is a high level language</li>
<li class="supNeg">16 (9%) There are many good open-source tools for this language</li>
<li class="supPos">82 (9%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (9%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">15 (9%) I regularly use this language</li>
<li>67 (9%) I enjoy playing with this language but would never use it for "real code"</li>
</ul>
<ul></ul>
<ul>
<li>38 (0%) This language has an annoying syntax</li>
<li>42 (0%) This language has a very rigid idea of how things should be done</li>
<li>44 (0%) Code written in this language tends to be verbose</li>
<li>44 (0%) This language would be good for teaching children to write software</li>
<li>37 (0%) This language is good for beginners</li>
<li>32 (0%) It's unusual for me to discover unfamiliar features</li>
<li>72 (0%) Programs written in this language tend to be efficient</li>
<li>32 (0%) I usually use this language on projects with many other members</li>
<li>67 (0%) I use this language out of choice</li>
<li>47 (0%) This language is unusually bad for beginners</li>
<li>69 (0%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>54 (0%) I find code written in this language very elegant</li>
<li class="supNeg">16 (0%) I know many other people who use this language</li>
<li>45 (0%) I usually use this language on solo projects</li>
<li>31 (1%) Writing code in this language is a lot of work</li>
<li>47 (1%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>51 (1%) Code written in this language tends to be very reliable</li>
<li>64 (1%) This language is best for very large projects</li>
<li>39 (1%) This language is good for distributed computing</li>
<li>36 (1%) This is a mainstream language</li>
<li>47 (1%) I know this language well</li>
<li>36 (1%) This language is well documented</li>
<li>26 (1%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>34 (1%) I often get angry when writing code in this language</li>
<li>59 (1%) This language is good for scientific computing</li>
<li>31 (1%) I would use this language as a scripting language embedded inside a larger application</li>
<li>63 (1%) I can imagine this will be a popular language in twenty years time</li>
<li>36 (2%) This language is best for very small projects</li>
<li>54 (2%) I would use this language for writing server programs</li>
<li>43 (2%) This language excels at text processing</li>
<li>73 (2%) This language is suitable for real-time applications</li>
<li>35 (2%) I enjoy using this language</li>
<li>57 (2%) This language is expressive</li>
<li>63 (2%) This language has a very coherent design</li>
<li>44 (2%) I would use this language for a web project</li>
<li class="supNeg">24 (2%) I use many applications written in this language</li>
<li>37 (2%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>36 (2%) I can imagine using this language in my day job</li>
<li>55 (2%) This language is well suited for an agile development approach using short iterations.</li>
<li>55 (2%) This language has unusual features that I often miss when using other languages</li>
<li>36 (2%) There are many good commercial tools for this language</li>
<li>49 (2%) This language has a very dogmatic community</li>
<li>41 (3%) It is easy to debug programs written in this language when it goes wrong</li>
<li>74 (3%) I find this language easy to prototype in</li>
<li>25 (3%) I regularly use this language</li>
<li>60 (3%) This is a high level language</li>
<li>36 (3%) Learning this language significantly changed how I use other languages.</li>
<li>47 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supPos">77 (3%) This language is likely to be a passing fad</li>
<li>53 (3%) This is a low level language</li>
<li>48 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>42 (4%) This language excels at symbolic manipulation</li>
<li>59 (4%) I would use this language for a desktop GUI project</li>
<li>51 (4%) This language is likely to have a strong influence on future languages</li>
<li>35 (4%) Code written in this language tends to be terse</li>
<li>56 (4%) Code written in this language is very readable</li>
<li class="supPos">82 (4%) I find it easy to write efficient code in this language</li>
<li>47 (4%) Learning this language improved my ability as a programmer</li>
<li>40 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>55 (4%) This language matches it's problem domain particularly well.</li>
<li>62 (4%) This language has a strong static type system</li>
<li class="supPos">77 (4%) I would use this language to write a command-line app</li>
<li class="supNeg">20 (4%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>39 (4%) This language is minimal</li>
<li>39 (5%) When I write code in this language I can be very sure it is correct</li>
<li>25 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>63 (5%) This language has a good community</li>
<li>61 (5%) This language has many features which feel "tacked on"</li>
<li>40 (5%) I would use this language for mobile applications</li>
<li>36 (5%) This language has a niche outside of which I would not use it</li>
<li>33 (5%) I often feel like I am not smart enough to write this language</li>
<li>26 (5%) The semantics of this language are much different than other languages I know.</li>
<li>38 (5%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>44 (5%) Developers who primarily use this language often burn out after a few years</li>
<li class="supPos">76 (5%) This language encourages writing reusable code.</li>
<li>53 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li>30 (5%) I am reluctant to admit to knowing this language</li>
<li>46 (5%) This language makes it easy to shoot yourself in the foot</li>
<li>51 (5%) The resources for learning this language are of high quality</li>
<li>27 (6%) There is a wide variety of open source code written in this language</li>
<li>71 (6%) This language encourages writing code that is easy to maintain.</li>
<li>36 (6%) There are many good tools for this language</li>
<li>52 (6%) I would use this language for casual scripting</li>
<li>73 (6%) I would like to write more of this language than I currently do</li>
<li>59 (7%) Programs written in this language tend to play well with others</li>
<li>57 (7%) This language is good for numeric computing</li>
<li class="supNeg">10 (7%) This language has a niche in which it is great</li>
<li>59 (8%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>37 (8%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>42 (8%) I would list this language on my resume</li>
<li>44 (8%) This language is large</li>
<li>49 (8%) I still discover new features of this language on a fairly regular basis</li>
<li>48 (8%) This language is very flexible</li>
<li>63 (8%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>31 (9%) Programs written in this language will usually work in future versions of the language</li>
<li>37 (9%) Libraries in this language tend to be well documented.</li>
<li>65 (9%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>54 (9%) This language has a high quality implementation</li>
</ul>
<ul>
<li>36 (0%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supPos">78 (0%) This language is expressive</li>
<li>25 (0%) This language has an annoying syntax</li>
<li class="supPos">77 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>56 (0%) This language is large</li>
<li>60 (0%) There are many good commercial tools for this language</li>
<li>73 (0%) Learning this language improved my ability as a programmer</li>
<li class="supPos">78 (0%) This language encourages writing reusable code.</li>
<li>29 (0%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">83 (0%) This language is best for very small projects</li>
<li class="supNeg">21 (0%) This is a low level language</li>
<li class="supPos">88 (0%) This language would be good for teaching children to write software</li>
<li>68 (0%) I still discover new features of this language on a fairly regular basis</li>
<li>71 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>40 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>67 (1%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">87 (1%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>52 (2%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">21 (2%) I often feel like I am not smart enough to write this language</li>
<li>63 (2%) This language has a very dogmatic community</li>
<li class="supNeg">15 (2%) This language is unusually bad for beginners</li>
<li class="supPos">96 (2%) I would use this language to write a command-line app</li>
<li>52 (2%) I find it easy to write efficient code in this language</li>
<li>37 (2%) This language is good for distributed computing</li>
<li>43 (2%) Code written in this language tends to be very reliable</li>
<li>48 (2%) Code written in this language tends to be terse</li>
<li>67 (2%) I use many applications written in this language</li>
<li>28 (2%) This language has a niche in which it is great</li>
<li>59 (2%) This language excels at symbolic manipulation</li>
<li>64 (2%) I find code written in this language very elegant</li>
<li>33 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">75 (2%) Libraries in this language tend to be well documented.</li>
<li>71 (2%) I know this language well</li>
<li class="supPos">82 (2%) This language has a good community</li>
<li>61 (3%) This language is best for very large projects</li>
<li class="supPos">80 (3%) This language excels at text processing</li>
<li>62 (3%) This language has many features which feel "tacked on"</li>
<li class="supPos">75 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supPos">95 (3%) I find this language easy to prototype in</li>
<li>33 (3%) This language is built on a small core of orthogonal features</li>
<li>65 (3%) I usually use this language on solo projects</li>
<li>65 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>45 (3%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>51 (3%) I would like to write more of this language than I currently do</li>
<li class="supPos">96 (3%) This language has a good library distribution mechanism.</li>
<li class="supPos">84 (3%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>51 (3%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">14 (4%) This language has a strong static type system</li>
<li class="supPos">83 (4%) This is a high level language</li>
<li>73 (4%) I know many other people who use this language</li>
<li class="supNeg">4 (4%) Writing code in this language is a lot of work</li>
<li>63 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">76 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">88 (4%) There is a wide variety of open source code written in this language</li>
<li>28 (4%) I learned this language early in my career as a programmer</li>
<li>68 (4%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>73 (4%) This is a mainstream language</li>
<li>31 (4%) Code written in this language tends to be verbose</li>
<li class="supPos">94 (5%) The resources for learning this language are of high quality</li>
<li class="supPos">94 (5%) I would use this language for a web project</li>
<li>38 (5%) This language is suitable for real-time applications</li>
<li>62 (5%) I usually use this language on projects with many other members</li>
<li>27 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>46 (5%) I enjoy using this language</li>
<li>64 (5%) I would use this language for writing server programs</li>
<li class="supPos">94 (5%) I would use this language for casual scripting</li>
<li>64 (5%) It is easy to debug programs written in this language when it goes wrong</li>
<li>60 (6%) I regularly use this language</li>
<li>36 (6%) This language is minimal</li>
<li class="supPos">77 (6%) I would use this language for a desktop GUI project</li>
<li>70 (6%) Programs written in this language tend to play well with others</li>
<li>32 (6%) When I write code in this language I can be very sure it is correct</li>
<li>28 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>28 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>41 (7%) This language matches it's problem domain particularly well.</li>
<li class="supPos">92 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>44 (7%) Programs written in this language will usually work in future versions of the language</li>
<li class="supNeg">24 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">91 (7%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>27 (7%) This language excels at concurrency</li>
<li class="supPos">76 (7%) I would list this language on my resume</li>
<li class="supPos">82 (7%) There are many good open-source tools for this language</li>
<li>74 (7%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">91 (8%) I use this language out of choice</li>
<li class="supNeg">21 (8%) This language has a very rigid idea of how things should be done</li>
<li>27 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>40 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>28 (8%) I would use this language for writing embedded programs</li>
<li>29 (8%) I am reluctant to admit to knowing this language</li>
<li>51 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>67 (8%) I would use this language for mobile applications</li>
<li>63 (9%) This language has a very coherent design</li>
<li class="supPos">86 (9%) This language is well documented</li>
<li>66 (9%) There are many good tools for this language</li>
</ul>
<ul>
<li>57 (2%) This language is good for scientific computing</li>
<li>36 (3%) This language excels at symbolic manipulation</li>
<li>33 (3%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>44 (4%) This language is expressive</li>
<li>27 (4%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>41 (4%) I would like to write more of this language than I currently do</li>
<li>62 (4%) This is a high level language</li>
<li>60 (4%) This language has a strong static type system</li>
<li>56 (4%) I still discover new features of this language on a fairly regular basis</li>
<li>41 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>50 (5%) I can imagine this will be a popular language in twenty years time</li>
<li>44 (5%) This language is likely to have a strong influence on future languages</li>
<li>43 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">17 (6%) This language is minimal</li>
<li>35 (6%) This language has unusual features that I often miss when using other languages</li>
<li>27 (7%) This language excels at concurrency</li>
<li>27 (7%) Code written in this language tends to be terse</li>
<li>43 (7%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>43 (7%) This language is good for distributed computing</li>
<li>39 (7%) This language excels at text processing</li>
<li>51 (8%) Code written in this language is very readable</li>
<li class="supPos">89 (8%) This language has a high quality implementation</li>
<li>27 (8%) When I write code in this language I can be very sure it is correct</li>
<li>46 (8%) I would use this language for casual scripting</li>
<li>54 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>35 (8%) I find code written in this language very elegant</li>
<li>31 (8%) Learning this language significantly changed how I use other languages.</li>
<li>26 (8%) I would use this language as a scripting language embedded inside a larger application</li>
<li>50 (8%) I can imagine using this language in my day job</li>
<li class="supNeg">11 (8%) This language is best for very small projects</li>
<li>33 (8%) I enjoy playing with this language but would never use it for "real code"</li>
<li>46 (8%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>56 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>33 (9%) This language matches it's problem domain particularly well.</li>
<li class="supPos">79 (9%) The resources for learning this language are of high quality</li>
<li class="supPos">80 (9%) This language encourages writing reusable code.</li>
<li class="supPos">85 (9%) I find it easy to write efficient code in this language</li>
<li class="supPos">87 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>47 (9%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">84 (9%) I use many applications written in this language</li>
<li>70 (9%) Programs written in this language tend to play well with others</li>
<li>49 (9%) This language has a very coherent design</li>
</ul>
<ul>
<li class="supNeg">21 (0%) This language is good for scientific computing</li>
<li class="supNeg">22 (2%) I can imagine using this language in my day job</li>
<li class="supNeg">21 (2%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">21 (2%) This language is likely to have a strong influence on future languages</li>
<li>72 (3%) I find this language easy to prototype in</li>
<li>48 (3%) This language is unusually bad for beginners</li>
<li>30 (3%) This is a low level language</li>
<li>58 (3%) I use this language out of choice</li>
<li>33 (3%) Learning this language improved my ability as a programmer</li>
<li class="supNeg">13 (3%) Programs written in this language tend to be efficient</li>
<li>42 (4%) Code written in this language tends to be terse</li>
<li class="supNeg">24 (4%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">10 (4%) This language has a strong static type system</li>
<li class="supNeg">15 (4%) When I write code in this language I can be very sure it is correct</li>
<li>67 (4%) This is a high level language</li>
<li>49 (4%) This language has a high quality implementation</li>
<li>39 (4%) Code written in this language tends to be verbose</li>
<li class="supNeg">7 (4%) This language is good for distributed computing</li>
<li>28 (4%) This language has unusual features that I often miss when using other languages</li>
<li>35 (5%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>57 (5%) This language is minimal</li>
<li>27 (5%) This language is good for beginners</li>
<li>48 (5%) The resources for learning this language are of high quality</li>
<li>38 (5%) This language has a very coherent design</li>
<li class="supNeg">24 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>32 (5%) There are many good commercial tools for this language</li>
<li>33 (5%) It is easy to debug programs written in this language when it goes wrong</li>
<li>31 (5%) Writing code in this language is a lot of work</li>
<li>56 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>29 (6%) I would use this language for mobile applications</li>
<li>35 (6%) I find code written in this language very elegant</li>
<li>51 (7%) I use many applications written in this language</li>
<li>29 (7%) Code written in this language tends to be very reliable</li>
<li>48 (7%) Code written in this language is very readable</li>
<li>52 (7%) I learned this language early in my career as a programmer</li>
<li>59 (7%) Programs written in this language will usually work in future versions of the language</li>
<li>27 (7%) This language is suitable for real-time applications</li>
<li>26 (7%) Learning this language significantly changed how I use other languages.</li>
<li>44 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>62 (7%) Developers who primarily use this language often burn out after a few years</li>
<li>31 (7%) This language is built on a small core of orthogonal features</li>
<li>49 (7%) I often get angry when writing code in this language</li>
<li>47 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>37 (8%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">23 (8%) This language is large</li>
<li>27 (8%) I often feel like I am not smart enough to write this language</li>
<li>43 (8%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">14 (8%) I enjoy using this language</li>
<li class="supNeg">14 (8%) This language is good for numeric computing</li>
<li class="supNeg">13 (9%) I would use this language for writing programs for an embedded hardware platform</li>
<li>58 (9%) This language matches it's problem domain particularly well.</li>
<li>44 (9%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">16 (9%) I would use this language for writing server programs</li>
<li>37 (9%) This language is well documented</li>
<li>47 (9%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">80 (9%) This language has a niche outside of which I would not use it</li>
<li>35 (9%) This language has a very dogmatic community</li>
<li>44 (9%) I usually use this language on solo projects</li>
</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul>
<li>37 (2%) I use many applications written in this language</li>
<li>44 (3%) There is a wide variety of open source code written in this language</li>
<li>36 (3%) This is a mainstream language</li>
<li class="supNeg">22 (5%) This is a low level language</li>
<li>29 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>35 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">86 (5%) This is a high level language</li>
<li>46 (6%) There are many good commercial tools for this language</li>
<li class="supNeg">23 (6%) I often get angry when writing code in this language</li>
<li>35 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>34 (6%) I usually use this language on projects with many other members</li>
<li>42 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">21 (7%) Writing code in this language is a lot of work</li>
<li>28 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>41 (7%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>51 (7%) There are many good tools for this language</li>
<li>46 (7%) I regularly use this language</li>
<li>73 (7%) This language has a high quality implementation</li>
<li>59 (7%) I would use this language for a web project</li>
<li>37 (7%) I know many other people who use this language</li>
<li class="supPos">75 (7%) This language is likely to have a strong influence on future languages</li>
<li>69 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li>59 (8%) I would use this language for casual scripting</li>
<li class="supNeg">11 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>52 (8%) Code written in this language tends to be terse</li>
<li class="supPos">88 (8%) This language encourages writing reusable code.</li>
<li class="supPos">84 (8%) I find this language easy to prototype in</li>
<li>28 (8%) This language makes it easy to shoot yourself in the foot</li>
<li>40 (8%) This language has many features which feel "tacked on"</li>
<li>47 (8%) This language excels at text processing</li>
<li class="supNeg">18 (8%) There is a lot of accidental complexity when writing code in this language</li>
<li>66 (9%) Code written in this language is very readable</li>
<li>51 (9%) This language is likely to be around for a very long time</li>
<li class="supPos">77 (9%) I would like to write more of this language than I currently do</li>
<li>57 (9%) This language has a good library distribution mechanism.</li>
<li class="supPos">79 (9%) This language has a very coherent design</li>
</ul>
<ul>
<li>74 (1%) I would use this language for casual scripting</li>
<li>58 (1%) I find code written in this language very elegant</li>
<li class="supNeg">19 (1%) I often feel like I am not smart enough to write this language</li>
<li>57 (1%) There is a wide variety of open source code written in this language</li>
<li>42 (2%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>54 (2%) This language excels at text processing</li>
<li>30 (2%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>49 (2%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>43 (2%) This language has unusual features that I often miss when using other languages</li>
<li>41 (2%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>47 (3%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>58 (3%) I would use this language for a desktop GUI project</li>
<li class="supPos">77 (3%) This is a high level language</li>
<li>35 (3%) This language is good for scientific computing</li>
<li>65 (3%) This language has a good community</li>
<li>31 (3%) This language has an annoying syntax</li>
<li>43 (3%) This language is suitable for real-time applications</li>
<li>38 (3%) Code written in this language tends to be terse</li>
<li>52 (3%) Programs written in this language will usually work in future versions of the language</li>
<li>40 (3%) It is easy to debug programs written in this language when it goes wrong</li>
<li>43 (4%) I use many applications written in this language</li>
<li>32 (4%) This language is likely to be around for a very long time</li>
<li>34 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>55 (4%) I would like to write more of this language than I currently do</li>
<li>35 (4%) Programs written in this language tend to be efficient</li>
<li>36 (4%) Learning this language improved my ability as a programmer</li>
<li>40 (4%) This is a mainstream language</li>
<li>43 (4%) This language is likely to have a strong influence on future languages</li>
<li>41 (4%) I can imagine using this language in my day job</li>
<li>27 (4%) This is a low level language</li>
<li class="supNeg">22 (4%) When I write code in this language I can be very sure it is correct</li>
<li>43 (4%) This language is large</li>
<li>51 (4%) This language is best for very small projects</li>
<li>60 (5%) This language is expressive</li>
<li class="supNeg">23 (5%) Writing code in this language is a lot of work</li>
<li class="supPos">86 (5%) I find this language easy to prototype in</li>
<li>44 (5%) Libraries in this language tend to be well documented.</li>
<li>39 (5%) This language is good for numeric computing</li>
<li>46 (6%) This language has a niche outside of which I would not use it</li>
<li>47 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>44 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>74 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li>62 (6%) This language has a good library distribution mechanism.</li>
<li>26 (6%) This language excels at concurrency</li>
<li>43 (6%) This language is best for very large projects</li>
<li>44 (6%) This language is unusually bad for beginners</li>
<li>35 (6%) I regularly use this language</li>
<li>70 (7%) This language encourages writing code that is easy to maintain.</li>
<li>58 (7%) The resources for learning this language are of high quality</li>
<li>68 (7%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>57 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li>49 (7%) I would list this language on my resume</li>
<li>72 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>70 (7%) I use this language out of choice</li>
<li>50 (8%) There are many good open-source tools for this language</li>
<li>34 (8%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">24 (8%) The semantics of this language are much different than other languages I know.</li>
<li>40 (9%) This language makes it easy to shoot yourself in the foot</li>
<li>47 (9%) There are many good tools for this language</li>
<li>61 (9%) I find it easy to write efficient code in this language</li>
<li>48 (9%) I usually use this language on solo projects</li>
<li>67 (9%) I would use this language to write a command-line app</li>
<li>27 (9%) This language is good for distributed computing</li>
<li class="supNeg">20 (9%) I learned this language early in my career as a programmer</li>
<li>57 (9%) This language excels at symbolic manipulation</li>
<li>48 (9%) There are many good commercial tools for this language</li>
<li>42 (9%) I still discover new features of this language on a fairly regular basis</li>
<li>41 (9%) I would use this language for writing server programs</li>
<li>42 (9%) I know many other people who use this language</li>
<li>26 (9%) I would use this language for writing programs for an embedded hardware platform</li>
</ul>
<ul></ul>
<ul></ul>
<ul>
<li>36 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">15 (5%) This is a mainstream language</li>
<li class="supNeg">16 (5%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">75 (5%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>39 (6%) This language has many features which feel "tacked on"</li>
<li>53 (6%) This language would be good for teaching children to write software</li>
<li>25 (6%) There is a wide variety of open source code written in this language</li>
<li>34 (7%) This language is well documented</li>
<li class="supNeg">13 (7%) I can imagine using this language in my day job</li>
<li class="supNeg">23 (7%) When I write code in this language I can be very sure it is correct</li>
<li>66 (7%) I use this language out of choice</li>
<li>31 (7%) There are many good commercial tools for this language</li>
<li class="supNeg">10 (8%) I know many other people who use this language</li>
<li>51 (8%) I know this language well</li>
<li>44 (8%) I would use this language for a desktop GUI project</li>
<li>68 (8%) I find this language easy to prototype in</li>
<li>28 (8%) There are many good open-source tools for this language</li>
<li>34 (8%) This language excels at concurrency</li>
<li>53 (8%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">13 (8%) I usually use this language on projects with many other members</li>
<li>37 (9%) The resources for learning this language are of high quality</li>
<li class="supPos">87 (9%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">77 (9%) This language has a very coherent design</li>
<li>41 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>44 (9%) Code written in this language is very readable</li>
</ul>
<ul>
<li>35 (0%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>56 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>66 (1%) This language has a good community</li>
<li class="supPos">81 (1%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">11 (2%) This language has a strong static type system</li>
<li class="supNeg">24 (2%) This language excels at concurrency</li>
<li>37 (2%) It is easy to debug programs written in this language when it goes wrong</li>
<li>29 (2%) This language is suitable for real-time applications</li>
<li class="supNeg">21 (2%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>32 (3%) This is a low level language</li>
<li class="supNeg">20 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>32 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>43 (3%) This language matches it's problem domain particularly well.</li>
<li>60 (3%) There are many good tools for this language</li>
<li>27 (3%) This language is best for very large projects</li>
<li>46 (3%) This language would be good for teaching children to write software</li>
<li class="supNeg">12 (3%) When I write code in this language I can be very sure it is correct</li>
<li>45 (4%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>69 (4%) There are many good open-source tools for this language</li>
<li>61 (4%) This language makes it easy to shoot yourself in the foot</li>
<li>69 (5%) This is a high level language</li>
<li>53 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li>73 (5%) I would use this language for a web project</li>
<li>59 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">15 (5%) Code written in this language tends to be very reliable</li>
<li>44 (5%) This language encourages writing code that is easy to maintain.</li>
<li>48 (5%) This language is likely to be a passing fad</li>
<li class="supNeg">15 (6%) I would use this language for writing embedded programs</li>
<li>33 (6%) This language has a niche in which it is great</li>
<li class="supNeg">19 (6%) This language is good for distributed computing</li>
<li>51 (6%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">87 (6%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>43 (6%) I find it easy to write efficient code in this language</li>
<li>52 (6%) I learned this language early in my career as a programmer</li>
<li>72 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>42 (7%) This language encourages writing reusable code.</li>
<li>56 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">76 (7%) I find this language easy to prototype in</li>
<li class="supPos">85 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">23 (7%) This language is good for numeric computing</li>
<li class="supPos">78 (7%) This is a mainstream language</li>
<li>52 (7%) Libraries in this language tend to be well documented.</li>
<li>61 (7%) The resources for learning this language are of high quality</li>
<li>71 (7%) I use many applications written in this language</li>
<li>60 (8%) I would list this language on my resume</li>
<li>57 (8%) There are many good commercial tools for this language</li>
<li>51 (8%) I use this language out of choice</li>
<li class="supPos">82 (8%) I know many other people who use this language</li>
<li>42 (8%) This language has a very dogmatic community</li>
<li>48 (9%) Code written in this language tends to be verbose</li>
<li>63 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li>49 (9%) I usually use this language on solo projects</li>
<li>67 (9%) I often get angry when writing code in this language</li>
<li>25 (9%) I can imagine using this language in my day job</li>
<li class="supNeg">22 (9%) This language has a very rigid idea of how things should be done</li>
<li>45 (9%) This language is good for beginners</li>
</ul>
<ul></ul>
</div>
k-means with k = 20
<tabled class="data" id="clusters20">
  <trd>
    <tdd>Javascript,6.0</tdd>
    <tdd>Perl,6.0</tdd>
    <tdd>PHP,6.0</tdd>
    <tdd>Shell,6.0</tdd>
  </trd>
  <trd>
    <tdd>J,0.0</tdd>
  </trd>
  <trd>
    <tdd>Agda,0.0</tdd>
  </trd>
  <trd>
    <tdd>Prolog,6.0</tdd>
    <tdd>APL,7.0</tdd>
    <tdd>ELisp,8.0</tdd>
    <tdd>AWK,8.0</tdd>
    <tdd>Assembler,13.0</tdd>
  </trd>
  <trd>
    <tdd>R,4.0</tdd>
    <tdd>Matlab,4.0</tdd>
    <tdd>Mathematica,4.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,5.0</tdd>
    <tdd>Forth,5.0</tdd>
  </trd>
  <trd>
    <tdd>D,5.0</tdd>
    <tdd>Go,5.0</tdd>
    <tdd>Ada,6.0</tdd>
    <tdd>Eiffel,6.0</tdd>
    <tdd>Standard ML,7.0</tdd>
  </trd>
  <trd>
    <tdd>TCL,5.0</tdd>
    <tdd>Io,5.0</tdd>
  </trd>
  <trd>
    <tdd>Mozart-Oz,0.0</tdd>
  </trd>
  <trd>
    <tdd>C#,4.0</tdd>
    <tdd>Java,4.0</tdd>
  </trd>
  <trd>
    <tdd>Lua,6.0</tdd>
    <tdd>Ruby,6.0</tdd>
    <tdd>Groovy,6.0</tdd>
    <tdd>Haxe,6.0</tdd>
    <tdd>Python,8.0</tdd>
  </trd>
  <trd>
    <tdd>C++,6.0</tdd>
    <tdd>C,8.0</tdd>
    <tdd>Objective C,8.0</tdd>
  </trd>
  <trd>
    <tdd>ActionScript,0.0</tdd>
  </trd>
  <trd>
    <tdd>Clojure,5.0</tdd>
    <tdd>O'Caml,5.0</tdd>
    <tdd>Common Lisp,6.0</tdd>
    <tdd>F#,6.0</tdd>
    <tdd>Smalltalk,7.0</tdd>
    <tdd>Erlang,8.0</tdd>
    <tdd>Haskell,8.0</tdd>
    <tdd>Scala,8.0</tdd>
    <tdd>Scheme,8.0</tdd>
  </trd>
  <trd>
    <tdd>Pascal,5.0</tdd>
    <tdd>Fortran,6.0</tdd>
    <tdd>Delphi,6.0</tdd>
    <tdd>Cobol,7.0</tdd>
    <tdd>Visual Basic,7.0</tdd>
  </trd>
  <trd>
    <tdd>REBOL,0.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,0.0</tdd>
  </trd>
</tabled>
<div class="support" id="support20">
<ul>
<li class="supNeg">21 (2%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>32 (2%) This is a low level language</li>
<li class="supNeg">19 (2%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>32 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">22 (3%) This language excels at concurrency</li>
<li>36 (3%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">9 (3%) This language has a strong static type system</li>
<li class="supNeg">11 (3%) When I write code in this language I can be very sure it is correct</li>
<li>27 (3%) This language is suitable for real-time applications</li>
<li>38 (3%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>68 (4%) This is a high level language</li>
<li>54 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">16 (4%) Code written in this language tends to be very reliable</li>
<li>43 (5%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>45 (5%) This language matches it's problem domain particularly well.</li>
<li>43 (5%) I find it easy to write efficient code in this language</li>
<li>64 (5%) This language makes it easy to shoot yourself in the foot</li>
<li>66 (6%) There are many good open-source tools for this language</li>
<li>72 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>54 (6%) I learned this language early in my career as a programmer</li>
<li class="supPos">85 (6%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supPos">86 (6%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>74 (6%) I find this language easy to prototype in</li>
<li class="supNeg">16 (7%) This language is good for distributed computing</li>
<li>59 (7%) The resources for learning this language are of high quality</li>
<li>55 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">80 (7%) I know many other people who use this language</li>
<li>50 (8%) I usually use this language on solo projects</li>
<li>25 (8%) I can imagine using this language in my day job</li>
<li>53 (8%) I use this language out of choice</li>
<li class="supNeg">22 (8%) This language has a very rigid idea of how things should be done</li>
<li>57 (8%) I would list this language on my resume</li>
<li>37 (8%) This language has a niche in which it is great</li>
<li>46 (8%) Code written in this language tends to be verbose</li>
<li>61 (8%) There is a lot of accidental complexity when writing code in this language</li>
<li>36 (8%) Writing code in this language is a lot of work</li>
<li>64 (8%) I often get angry when writing code in this language</li>
<li>40 (8%) This language has a very dogmatic community</li>
<li>65 (9%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>41 (9%) This language would be good for teaching children to write software</li>
<li>40 (9%) This language encourages writing code that is easy to maintain.</li>
<li>30 (9%) I find code written in this language very elegant</li>
<li>40 (9%) Code written in this language is very readable</li>
<li class="supNeg">16 (9%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">75 (9%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">19 (9%) I enjoy using this language</li>
</ul>
<ul></ul>
<ul></ul>
<ul>
<li>25 (1%) I would use this language for mobile applications</li>
<li>56 (3%) I use this language out of choice</li>
<li class="supPos">91 (4%) This language has a niche outside of which I would not use it</li>
<li>48 (4%) The resources for learning this language are of high quality</li>
<li class="supNeg">20 (5%) I would list this language on my resume</li>
<li class="supNeg">9 (6%) This language is good for distributed computing</li>
<li>57 (6%) This language has a niche in which it is great</li>
<li>55 (7%) Programs written in this language will usually work in future versions of the language</li>
<li>58 (7%) Developers who primarily use this language often burn out after a few years</li>
<li class="supPos">83 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">24 (7%) I enjoy using this language</li>
<li>38 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>35 (8%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">24 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>35 (8%) There are many good commercial tools for this language</li>
<li class="supNeg">15 (8%) I would use this language for a desktop GUI project</li>
<li class="supNeg">12 (8%) I can imagine this will be a popular language in twenty years time</li>
<li>37 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">11 (9%) This language is best for very large projects</li>
<li>51 (9%) I often get angry when writing code in this language</li>
<li>51 (9%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">23 (9%) I would use this language for a web project</li>
<li>38 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
</ul>
<ul>
<li>40 (0%) There is a lot of accidental complexity when writing code in this language</li>
<li>42 (1%) Code written in this language tends to be terse</li>
<li>40 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>36 (1%) I usually use this language on projects with many other members</li>
<li class="supNeg">21 (1%) This language has a strong static type system</li>
<li>45 (1%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>41 (1%) I am reluctant to admit to knowing this language</li>
<li>44 (1%) This language has a very rigid idea of how things should be done</li>
<li>26 (1%) This language excels at concurrency</li>
<li>54 (1%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">20 (2%) This language is good for distributed computing</li>
<li>53 (2%) Code written in this language is very readable</li>
<li>26 (2%) This language is minimal</li>
<li>63 (2%) This language has an annoying syntax</li>
<li>59 (2%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supPos">82 (3%) I enjoy playing with this language but would never use it for "real code"</li>
<li>29 (3%) Writing code in this language is a lot of work</li>
<li>30 (3%) Programs written in this language tend to be efficient</li>
<li>51 (3%) This language is large</li>
<li>47 (3%) This language encourages writing reusable code.</li>
<li>50 (3%) The semantics of this language are much different than other languages I know.</li>
<li>33 (3%) This language has unusual features that I often miss when using other languages</li>
<li class="supPos">92 (3%) This language is good for numeric computing</li>
<li class="supNeg">20 (4%) This language excels at text processing</li>
<li>43 (4%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">23 (4%) Learning this language significantly changed how I use other languages.</li>
<li>54 (4%) I would use this language for casual scripting</li>
<li class="supPos">89 (4%) This language has a niche outside of which I would not use it</li>
<li>44 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>47 (4%) There are many good tools for this language</li>
<li>31 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>45 (4%) This is a mainstream language</li>
<li>34 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">22 (4%) I would use this language for a web project</li>
<li class="supNeg">18 (4%) This is a low level language</li>
<li>40 (4%) I would like to write more of this language than I currently do</li>
<li>52 (4%) This language is unusually bad for beginners</li>
<li class="supNeg">16 (4%) This language is best for very large projects</li>
<li>57 (5%) This language has many features which feel "tacked on"</li>
<li class="supPos">80 (5%) I find this language easy to prototype in</li>
<li>26 (5%) This language is suitable for real-time applications</li>
<li>33 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">5 (5%) I would use this language for writing server programs</li>
<li>51 (5%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supPos">91 (5%) This language is good for scientific computing</li>
<li class="supNeg">12 (5%) I would use this language for mobile applications</li>
<li>42 (5%) Code written in this language tends to be verbose</li>
<li>41 (6%) This language has a very coherent design</li>
<li>51 (6%) I find it easy to write efficient code in this language</li>
<li>36 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>47 (6%) This language is best for very small projects</li>
<li class="supNeg">9 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">9 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">86 (6%) This is a high level language</li>
<li>46 (6%) I usually use this language on solo projects</li>
<li>46 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>45 (6%) This language has a very dogmatic community</li>
<li>51 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li>54 (6%) Libraries in this language tend to be well documented.</li>
<li>50 (6%) Developers who primarily use this language often burn out after a few years</li>
<li>47 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">23 (7%) When I write code in this language I can be very sure it is correct</li>
<li>37 (7%) I find code written in this language very elegant</li>
<li>28 (7%) I would use this language for a desktop GUI project</li>
<li>61 (7%) This language has a high quality implementation</li>
<li>26 (7%) I can imagine using this language in my day job</li>
<li>38 (7%) I use many applications written in this language</li>
<li>41 (8%) This language is good for beginners</li>
<li class="supPos">85 (8%) This language matches it's problem domain particularly well.</li>
<li>27 (8%) Learning this language improved my ability as a programmer</li>
<li>49 (8%) This language is likely to be a passing fad</li>
<li>32 (8%) Code written in this language tends to be very reliable</li>
<li>39 (8%) I would list this language on my resume</li>
<li>40 (8%) This language would be good for teaching children to write software</li>
<li>51 (8%) This language encourages writing code that is easy to maintain.</li>
<li>35 (8%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">21 (9%) I enjoy using this language</li>
<li>29 (9%) I would use this language for writing embedded programs</li>
<li>37 (9%) There is a wide variety of open source code written in this language</li>
<li>37 (9%) I learned this language early in my career as a programmer</li>
<li class="supNeg">21 (9%) I would use this language to write a command-line app</li>
<li>57 (9%) There are many good commercial tools for this language</li>
</ul>
<ul>
<li>46 (0%) I enjoy using this language</li>
<li>31 (0%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>44 (0%) I would use this language for mobile applications</li>
<li>46 (0%) I often get angry when writing code in this language</li>
<li>37 (0%) Code written in this language is very readable</li>
<li>53 (0%) This language would be good for teaching children to write software</li>
<li>40 (0%) I regularly use this language</li>
<li>39 (0%) This language is frequently used for applications it isn't suitable for</li>
<li>37 (1%) Writing code in this language is a lot of work</li>
<li class="supNeg">24 (1%) This language is best for very large projects</li>
<li>37 (1%) This language has many features which feel "tacked on"</li>
<li class="supNeg">15 (1%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">12 (1%) This is a mainstream language</li>
<li>72 (1%) This language has a very coherent design</li>
<li>29 (1%) I would use this language for a web project</li>
<li>46 (1%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">22 (1%) There is a wide variety of open source code written in this language</li>
<li>27 (1%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">13 (1%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>45 (1%) This language has an annoying syntax</li>
<li class="supNeg">9 (2%) I can imagine using this language in my day job</li>
<li>31 (2%) This language has a very rigid idea of how things should be done</li>
<li>49 (2%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">2 (2%) I usually use this language on projects with many other members</li>
<li>61 (2%) This language is unusually bad for beginners</li>
<li>33 (2%) I would use this language for a desktop GUI project</li>
<li>33 (2%) This language is good for scientific computing</li>
<li>39 (2%) This language has a very dogmatic community</li>
<li>46 (3%) This language is likely to be around for a very long time</li>
<li>67 (3%) Learning this language improved my ability as a programmer</li>
<li>33 (3%) I am reluctant to admit to knowing this language</li>
<li>59 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li>65 (3%) This language is best for very small projects</li>
<li>45 (3%) This language is good for numeric computing</li>
<li>49 (3%) I would like to write more of this language than I currently do</li>
<li>52 (3%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>41 (3%) The resources for learning this language are of high quality</li>
<li>59 (3%) I use this language out of choice</li>
<li>29 (4%) This language excels at concurrency</li>
<li class="supNeg">13 (4%) Code written in this language tends to be verbose</li>
<li>45 (4%) This language is likely to have a strong influence on future languages</li>
<li>45 (4%) I know this language well</li>
<li class="supNeg">9 (4%) I can imagine this will be a popular language in twenty years time</li>
<li>57 (4%) I often feel like I am not smart enough to write this language</li>
<li>68 (4%) This language is likely to be a passing fad</li>
<li class="supNeg">12 (4%) I know many other people who use this language</li>
<li>48 (5%) This language has unusual features that I often miss when using other languages</li>
<li>31 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>40 (5%) I would use this language to write a command-line app</li>
<li>31 (5%) There are many good tools for this language</li>
<li class="supPos">78 (5%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>73 (5%) This language is very flexible</li>
<li>68 (5%) Code written in this language tends to be terse</li>
<li>25 (5%) This language is large</li>
<li>49 (6%) This language excels at symbolic manipulation</li>
<li>53 (6%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>30 (6%) I would use this language for writing server programs</li>
<li class="supNeg">19 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>62 (6%) I find this language easy to prototype in</li>
<li class="supNeg">20 (6%) There are many good open-source tools for this language</li>
<li>27 (7%) This language is good for distributed computing</li>
<li>51 (7%) Developers who primarily use this language often burn out after a few years</li>
<li>25 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>63 (7%) This language has a high quality implementation</li>
<li class="supNeg">16 (7%) It is easy to debug programs written in this language when it goes wrong</li>
<li>39 (8%) This language is well documented</li>
<li>62 (9%) Programs written in this language tend to be efficient</li>
<li>61 (9%) This language is built on a small core of orthogonal features</li>
<li>60 (9%) This language is expressive</li>
<li>60 (9%) I find it easy to write efficient code in this language</li>
<li>54 (9%) I would use this language for casual scripting</li>
<li>62 (9%) I find code written in this language very elegant</li>
<li>38 (9%) This language has a good library distribution mechanism.</li>
<li>60 (9%) This language makes it easy to shoot yourself in the foot</li>
</ul>
<ul>
<li>35 (2%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>39 (3%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">20 (3%) I know many other people who use this language</li>
<li>26 (4%) There is a wide variety of open source code written in this language</li>
<li>46 (4%) This language would be good for teaching children to write software</li>
<li>38 (4%) There are many good commercial tools for this language</li>
<li>59 (5%) This language is good for numeric computing</li>
<li>57 (5%) This language is good for scientific computing</li>
<li>43 (5%) I would list this language on my resume</li>
<li>30 (5%) I can imagine using this language in my day job</li>
<li>40 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>42 (6%) This language has an annoying syntax</li>
<li>48 (6%) I would use this language for writing server programs</li>
<li>36 (6%) I would use this language for a web project</li>
<li>33 (6%) This language is good for distributed computing</li>
<li>37 (6%) This language excels at text processing</li>
<li class="supNeg">21 (6%) I regularly use this language</li>
<li>28 (6%) I use many applications written in this language</li>
<li>46 (6%) This language is very flexible</li>
<li>38 (7%) This language has a niche outside of which I would not use it</li>
<li>64 (7%) I use this language out of choice</li>
<li>42 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>32 (7%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>32 (7%) I am reluctant to admit to knowing this language</li>
<li>36 (7%) I usually use this language on projects with many other members</li>
<li>67 (7%) This language is best for very large projects</li>
<li class="supPos">81 (7%) This language encourages writing reusable code.</li>
<li>67 (7%) This is a high level language</li>
<li>37 (8%) I enjoy using this language</li>
<li>56 (8%) This language has a very dogmatic community</li>
<li>62 (8%) Code written in this language is very readable</li>
<li>27 (8%) I would use this language as a scripting language embedded inside a larger application</li>
<li>32 (8%) There are many good open-source tools for this language</li>
<li>32 (8%) This language is likely to be around for a very long time</li>
<li>31 (8%) This is a mainstream language</li>
<li>41 (9%) I would use this language for mobile applications</li>
<li>73 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>37 (9%) There are many good tools for this language</li>
<li>73 (9%) I find it easy to write efficient code in this language</li>
<li>38 (9%) Writing code in this language is a lot of work</li>
<li>65 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>62 (9%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">17 (9%) This language has a niche in which it is great</li>
<li>30 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>58 (9%) The resources for learning this language are of high quality</li>
<li>35 (9%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>51 (9%) Programs written in this language tend to play well with others</li>
<li>32 (9%) The semantics of this language are much different than other languages I know.</li>
</ul>
<ul>
<li>62 (0%) I would use this language as a scripting language embedded inside a larger application</li>
<li>37 (0%) This language is suitable for real-time applications</li>
<li>74 (0%) I find this language easy to prototype in</li>
<li class="supNeg">21 (0%) This language has a very rigid idea of how things should be done</li>
<li>40 (0%) The resources for learning this language are of high quality</li>
<li>46 (0%) This language matches it's problem domain particularly well.</li>
<li>51 (0%) I would use this language for a web project</li>
<li>69 (1%) This language is best for very small projects</li>
<li class="supNeg">15 (1%) This language has a strong static type system</li>
<li class="supNeg">24 (1%) I often feel like I am not smart enough to write this language</li>
<li>26 (1%) This language excels at concurrency</li>
<li class="supNeg">18 (1%) I would list this language on my resume</li>
<li>60 (1%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>37 (1%) I find it easy to write efficient code in this language</li>
<li>56 (1%) Code written in this language is very readable</li>
<li>26 (1%) Code written in this language tends to be very reliable</li>
<li>26 (2%) I would use this language for writing programs for an embedded hardware platform</li>
<li>42 (2%) I would use this language for mobile applications</li>
<li class="supNeg">20 (2%) When I write code in this language I can be very sure it is correct</li>
<li>27 (2%) There are many good tools for this language</li>
<li>27 (2%) There are many good open-source tools for this language</li>
<li>47 (2%) This language excels at symbolic manipulation</li>
<li>28 (2%) This is a low level language</li>
<li>72 (2%) I would use this language for casual scripting</li>
<li>31 (2%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">23 (3%) I would use this language for writing server programs</li>
<li>51 (3%) This language encourages writing code that is easy to maintain.</li>
<li>47 (3%) I would like to write more of this language than I currently do</li>
<li class="supNeg">18 (3%) I usually use this language on projects with many other members</li>
<li class="supPos">76 (3%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">12 (3%) I regularly use this language</li>
<li class="supNeg">22 (3%) I can imagine using this language in my day job</li>
<li>29 (3%) There are many good commercial tools for this language</li>
<li>27 (3%) This language is likely to have a strong influence on future languages</li>
<li>49 (3%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>26 (4%) Writing code in this language is a lot of work</li>
<li>64 (4%) I would use this language to write a command-line app</li>
<li>50 (4%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>52 (4%) I know this language well</li>
<li>45 (4%) This language has a high quality implementation</li>
<li>25 (5%) This language has a very dogmatic community</li>
<li>48 (5%) This language has many features which feel "tacked on"</li>
<li>25 (5%) This language is good for scientific computing</li>
<li>34 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">18 (5%) This language is good for distributed computing</li>
<li class="supNeg">10 (6%) This language has a niche in which it is great</li>
<li>28 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>50 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>42 (6%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>58 (6%) I use this language out of choice</li>
<li>31 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>55 (6%) Programs written in this language tend to play well with others</li>
<li>31 (7%) Libraries in this language tend to be well documented.</li>
<li>59 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>32 (7%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>36 (7%) Code written in this language tends to be verbose</li>
<li>39 (7%) This language has a good library distribution mechanism.</li>
<li>32 (8%) This language is well documented</li>
<li>41 (8%) This language is frequently used for applications it isn't suitable for</li>
<li>38 (8%) This language is good for beginners</li>
<li>27 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>71 (8%) This is a high level language</li>
<li>26 (8%) I still discover new features of this language on a fairly regular basis</li>
<li>62 (8%) This language is minimal</li>
<li class="supNeg">19 (8%) Programs written in this language tend to be efficient</li>
<li>46 (9%) Code written in this language tends to be terse</li>
<li>47 (9%) I usually use this language on solo projects</li>
<li class="supNeg">19 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>32 (9%) This language is good for numeric computing</li>
</ul>
<ul></ul>
<ul>
<li>52 (0%) I can imagine this will be a popular language in twenty years time</li>
<li>60 (0%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">15 (0%) This language is minimal</li>
<li>66 (0%) This is a high level language</li>
<li>46 (0%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supPos">83 (0%) This language encourages writing reusable code.</li>
<li class="supPos">99 (0%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>56 (0%) This language is good for numeric computing</li>
<li>37 (0%) This is a low level language</li>
<li class="supPos">88 (0%) The resources for learning this language are of high quality</li>
<li>64 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>71 (0%) This language is likely to be around for a very long time</li>
<li class="supPos">98 (1%) I know many other people who use this language</li>
<li>37 (1%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>41 (1%) This language is unusually bad for beginners</li>
<li>34 (1%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>48 (1%) This language is expressive</li>
<li>64 (1%) This language has a strong static type system</li>
<li>49 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>47 (1%) Programs written in this language tend to be efficient</li>
<li>54 (1%) This language is good for scientific computing</li>
<li class="supPos">86 (1%) This language is large</li>
<li class="supPos">98 (1%) Libraries in this language tend to be well documented.</li>
<li>52 (2%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>36 (2%) Learning this language improved my ability as a programmer</li>
<li class="supPos">81 (2%) This language encourages writing code that is easy to maintain.</li>
<li>45 (2%) This language excels at text processing</li>
<li>46 (2%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">75 (2%) I would use this language for writing server programs</li>
<li>62 (2%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">20 (2%) This language is built on a small core of orthogonal features</li>
<li>50 (2%) This language is good for distributed computing</li>
<li class="supPos">83 (2%) I find it easy to write efficient code in this language</li>
<li class="supPos">94 (2%) This language is best for very large projects</li>
<li class="supPos">80 (2%) I find this language easy to prototype in</li>
<li class="supPos">81 (2%) I use many applications written in this language</li>
<li>55 (2%) I still discover new features of this language on a fairly regular basis</li>
<li>65 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">96 (3%) There are many good commercial tools for this language</li>
<li>39 (3%) This language excels at symbolic manipulation</li>
<li>53 (3%) This language is good for beginners</li>
<li>38 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>36 (3%) I find code written in this language very elegant</li>
<li>30 (3%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>53 (3%) I would use this language for casual scripting</li>
<li>30 (3%) This language has unusual features that I often miss when using other languages</li>
<li>37 (4%) This language is very flexible</li>
<li class="supPos">95 (4%) This is a mainstream language</li>
<li class="supNeg">15 (4%) I often feel like I am not smart enough to write this language</li>
<li>53 (4%) I learned this language early in my career as a programmer</li>
<li class="supNeg">4 (4%) This language has a niche in which it is great</li>
<li>50 (4%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>68 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>61 (4%) Code written in this language tends to be very reliable</li>
<li>39 (4%) I would like to write more of this language than I currently do</li>
<li>67 (4%) This language has a good library distribution mechanism.</li>
<li class="supPos">78 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>57 (4%) Code written in this language is very readable</li>
<li>55 (4%) This language has a very coherent design</li>
<li class="supPos">87 (4%) It is easy to tell at a glance what code in this language does</li>
<li>35 (4%) This language matches it's problem domain particularly well.</li>
<li>74 (4%) Programs written in this language tend to play well with others</li>
<li class="supPos">95 (4%) This language has a high quality implementation</li>
<li>52 (4%) I enjoy using this language</li>
<li>66 (4%) This language has a good community</li>
<li class="supNeg">5 (5%) The semantics of this language are much different than other languages I know.</li>
<li>39 (5%) This language is likely to be a passing fad</li>
<li>74 (5%) This language has a very dogmatic community</li>
<li>31 (5%) This language excels at concurrency</li>
<li>32 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">17 (5%) This language has a niche outside of which I would not use it</li>
<li>34 (5%) When I write code in this language I can be very sure it is correct</li>
<li>51 (6%) This language would be good for teaching children to write software</li>
<li class="supPos">80 (6%) This language has many features which feel "tacked on"</li>
<li class="supNeg">18 (6%) This language is best for very small projects</li>
<li>41 (6%) I would use this language for writing embedded programs</li>
<li>27 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">93 (6%) This language is well documented</li>
<li>37 (6%) Writing code in this language is a lot of work</li>
<li class="supPos">93 (6%) I would use this language for mobile applications</li>
<li>74 (6%) I would use this language for a web project</li>
<li class="supPos">92 (7%) It is easy to debug programs written in this language when it goes wrong</li>
<li>56 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">92 (7%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>52 (7%) This language is suitable for real-time applications</li>
<li>43 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">89 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>54 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>73 (9%) It's unusual for me to discover unfamiliar features</li>
<li>51 (9%) I can imagine using this language in my day job</li>
<li>67 (9%) I would use this language to write a command-line app</li>
<li>26 (9%) Code written in this language tends to be terse</li>
<li class="supPos">76 (9%) I know this language well</li>
</ul>
<ul>
<li class="supNeg">20 (2%) I often feel like I am not smart enough to write this language</li>
<li>60 (3%) I find code written in this language very elegant</li>
<li>28 (4%) This language has an annoying syntax</li>
<li>29 (4%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>53 (4%) I would like to write more of this language than I currently do</li>
<li>25 (4%) This is a low level language</li>
<li class="supPos">79 (4%) This is a high level language</li>
<li>47 (4%) This language has unusual features that I often miss when using other languages</li>
<li>41 (5%) This language is suitable for real-time applications</li>
<li>42 (6%) Code written in this language tends to be terse</li>
<li>43 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supPos">90 (6%) I find this language easy to prototype in</li>
<li>49 (6%) Programs written in this language will usually work in future versions of the language</li>
<li>26 (7%) This language excels at concurrency</li>
<li>40 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>31 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>48 (7%) This language is large</li>
<li>26 (7%) The semantics of this language are much different than other languages I know.</li>
<li>69 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>26 (7%) When I write code in this language I can be very sure it is correct</li>
<li>71 (7%) This language encourages writing code that is easy to maintain.</li>
<li>58 (7%) This language excels at symbolic manipulation</li>
<li>42 (8%) Code written in this language tends to be very reliable</li>
<li>41 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>57 (8%) I find it easy to write efficient code in this language</li>
<li class="supNeg">23 (8%) I learned this language early in my career as a programmer</li>
<li>27 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>72 (8%) This language has a good community</li>
<li>31 (9%) This language is good for distributed computing</li>
<li>42 (9%) I can imagine using this language in my day job</li>
<li>60 (9%) This language has many features which feel "tacked on"</li>
<li>53 (9%) There are many good commercial tools for this language</li>
<li class="supNeg">22 (9%) This language has a very rigid idea of how things should be done</li>
<li>67 (9%) I would use this language for mobile applications</li>
<li>36 (9%) Code written in this language tends to be verbose</li>
<li>37 (9%) Developers who primarily use this language often burn out after a few years</li>
</ul>
<ul>
<li class="supNeg">19 (1%) When I write code in this language I can be very sure it is correct</li>
<li>39 (2%) I would use this language for casual scripting</li>
<li>55 (2%) This language has a strong static type system</li>
<li>41 (3%) I would like to write more of this language than I currently do</li>
<li>34 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>48 (3%) This language has a good library distribution mechanism.</li>
<li>34 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li>35 (4%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>46 (4%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">23 (4%) This language excels at concurrency</li>
<li>29 (4%) This language excels at symbolic manipulation</li>
<li>43 (4%) I often feel like I am not smart enough to write this language</li>
<li>46 (5%) This language has a very dogmatic community</li>
<li class="supNeg">22 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li>70 (5%) This language is best for very large projects</li>
<li>39 (5%) I would use this language for a web project</li>
<li>37 (5%) Learning this language significantly changed how I use other languages.</li>
<li>59 (5%) Libraries in this language tend to be well documented.</li>
<li>58 (5%) I often get angry when writing code in this language</li>
<li>35 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">24 (5%) I enjoy using this language</li>
<li>64 (6%) Code written in this language tends to be verbose</li>
<li>53 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>48 (6%) Code written in this language is very readable</li>
<li>52 (6%) This language encourages writing code that is easy to maintain.</li>
<li>72 (6%) There are many good tools for this language</li>
<li>51 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>74 (6%) The resources for learning this language are of high quality</li>
<li class="supNeg">19 (7%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>58 (7%) Writing code in this language is a lot of work</li>
<li>27 (7%) This language excels at text processing</li>
<li>53 (7%) This is a high level language</li>
<li>32 (7%) Code written in this language tends to be very reliable</li>
<li>32 (7%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>64 (7%) This language is good for scientific computing</li>
<li>41 (7%) This language has a very coherent design</li>
<li>50 (7%) I find this language easy to prototype in</li>
<li class="supPos">88 (8%) This language has a high quality implementation</li>
<li>35 (8%) I enjoy playing with this language but would never use it for "real code"</li>
<li>34 (9%) I find code written in this language very elegant</li>
<li>30 (9%) This language is good for distributed computing</li>
<li>34 (9%) This language is expressive</li>
<li>71 (9%) I would list this language on my resume</li>
<li class="supPos">79 (9%) There are many good commercial tools for this language</li>
<li class="supPos">80 (9%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">86 (9%) Developers who primarily use this language often burn out after a few years</li>
</ul>
<ul></ul>
<ul>
<li>39 (4%) I use many applications written in this language</li>
<li class="supNeg">22 (4%) This is a low level language</li>
<li>38 (4%) This is a mainstream language</li>
<li>31 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>34 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">87 (5%) This is a high level language</li>
<li class="supNeg">21 (6%) Writing code in this language is a lot of work</li>
<li>28 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>42 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>38 (7%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>72 (7%) This language has a high quality implementation</li>
<li class="supNeg">11 (7%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>47 (7%) I regularly use this language</li>
<li class="supPos">77 (7%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">84 (7%) I find this language easy to prototype in</li>
<li>38 (7%) I know many other people who use this language</li>
<li>25 (7%) I often get angry when writing code in this language</li>
<li class="supNeg">18 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li>28 (8%) This language makes it easy to shoot yourself in the foot</li>
<li>51 (8%) This language is likely to be around for a very long time</li>
<li>66 (8%) Code written in this language is very readable</li>
<li>42 (8%) There is a wide variety of open source code written in this language</li>
<li class="supPos">90 (8%) This language encourages writing reusable code.</li>
<li>69 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li>53 (8%) Code written in this language tends to be terse</li>
<li>54 (8%) There are many good tools for this language</li>
<li>48 (8%) There are many good commercial tools for this language</li>
<li>59 (8%) This language has a good library distribution mechanism.</li>
<li>49 (9%) This language excels at text processing</li>
<li>62 (9%) I would use this language for casual scripting</li>
<li>35 (9%) I usually use this language on projects with many other members</li>
<li class="supPos">77 (9%) This language has a very coherent design</li>
<li>28 (9%) Code written in this language tends to be verbose</li>
<li>63 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
</ul>
<ul>
<li>48 (3%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">11 (3%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">13 (4%) I would use this language for writing server programs</li>
<li>54 (4%) Code written in this language is very readable</li>
<li>28 (5%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>38 (5%) This language has a very dogmatic community</li>
<li class="supNeg">14 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">7 (5%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">8 (5%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">18 (5%) This language excels at symbolic manipulation</li>
<li>40 (6%) There are many good tools for this language</li>
<li>56 (6%) I know this language well</li>
<li class="supNeg">14 (6%) This language is very flexible</li>
<li>28 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">8 (6%) I enjoy using this language</li>
<li class="supNeg">10 (6%) I can imagine using this language in my day job</li>
<li class="supNeg">13 (7%) I usually use this language on solo projects</li>
<li>37 (7%) This language is best for very large projects</li>
<li>48 (7%) This is a mainstream language</li>
<li>50 (7%) This language encourages writing code that is easy to maintain.</li>
<li>56 (7%) It's unusual for me to discover unfamiliar features</li>
<li>44 (7%) This is a low level language</li>
<li>51 (7%) It is easy to tell at a glance what code in this language does</li>
<li>35 (7%) I use many applications written in this language</li>
<li>46 (7%) This language has a high quality implementation</li>
<li class="supNeg">15 (8%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">13 (8%) This language is good for distributed computing</li>
<li>32 (8%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>29 (9%) I usually use this language on projects with many other members</li>
<li class="supNeg">19 (9%) This language is likely to have a strong influence on future languages</li>
<li>56 (9%) This is a high level language</li>
<li class="supNeg">16 (9%) There are many good open-source tools for this language</li>
<li class="supPos">82 (9%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (9%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">15 (9%) I regularly use this language</li>
<li>67 (9%) I enjoy playing with this language but would never use it for "real code"</li>
</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul></ul>
</div>
k-means with k = 21
<tabled class="data" id="clusters21">
  <trd>
    <tdd>PHP,4.0</tdd>
    <tdd>Visual Basic,4.0</tdd>
  </trd>
  <trd>
    <tdd>Delphi,6.0</tdd>
    <tdd>ActionScript,6.0</tdd>
  </trd>
  <trd>
    <tdd>C,6.0</tdd>
    <tdd>C++,6.0</tdd>
  </trd>
  <trd>
    <tdd>D,4.0</tdd>
    <tdd>Go,5.0</tdd>
    <tdd>Objective C,6.0</tdd>
  </trd>
  <trd>
    <tdd>Scheme,5.0</tdd>
    <tdd>Smalltalk,6.0</tdd>
    <tdd>Io,6.0</tdd>
  </trd>
  <trd>
    <tdd>Haskell,0.0</tdd>
  </trd>
  <trd>
    <tdd>APL,5.0</tdd>
    <tdd>Prolog,5.0</tdd>
    <tdd>Forth,7.0</tdd>
  </trd>
  <trd>
    <tdd>C#,4.0</tdd>
    <tdd>Java,4.0</tdd>
  </trd>
  <trd>
    <tdd>Eiffel,0.0</tdd>
  </trd>
  <trd>
    <tdd>Ada,0.0</tdd>
  </trd>
  <trd>
    <tdd>Python,4.0</tdd>
    <tdd>Ruby,4.0</tdd>
  </trd>
  <trd>
    <tdd>Fortran,5.0</tdd>
    <tdd>Pascal,7.0</tdd>
    <tdd>Cobol,8.0</tdd>
    <tdd>Assembler,11.0</tdd>
  </trd>
  <trd>
    <tdd>Agda,0.0</tdd>
  </trd>
  <trd>
    <tdd>ELisp,6.0</tdd>
    <tdd>Groovy,6.0</tdd>
    <tdd>TCL,6.0</tdd>
    <tdd>Javascript,7.0</tdd>
    <tdd>Lua,8.0</tdd>
    <tdd>Perl,8.0</tdd>
    <tdd>AWK,8.0</tdd>
    <tdd>Haxe,8.0</tdd>
    <tdd>Shell,8.0</tdd>
  </trd>
  <trd>
    <tdd>Standard ML,6.0</tdd>
    <tdd>Coq,6.0</tdd>
  </trd>
  <trd>
    <tdd>O'Caml,5.0</tdd>
    <tdd>Common Lisp,6.0</tdd>
    <tdd>F#,6.0</tdd>
    <tdd>Erlang,7.0</tdd>
    <tdd>J,8.0</tdd>
  </trd>
  <trd>
    <tdd>R,4.0</tdd>
    <tdd>Matlab,4.0</tdd>
    <tdd>Mathematica,4.0</tdd>
  </trd>
  <trd>
    <tdd>Scala,0.0</tdd>
  </trd>
  <trd>
    <tdd>Clojure,0.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,6.0</tdd>
    <tdd>Mozart-Oz,6.0</tdd>
    <tdd>REBOL,8.0</tdd>
  </trd>
</tabled>
<div class="support" id="support21">
<ul>
<li class="supNeg">0 (0%) Learning this language significantly changed how I use other languages.</li>
<li>37 (0%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">20 (0%) This language excels at concurrency</li>
<li>54 (0%) Libraries in this language tend to be well documented.</li>
<li>44 (0%) I find it easy to write efficient code in this language</li>
<li class="supNeg">8 (0%) This language is built on a small core of orthogonal features</li>
<li>71 (0%) This language has an annoying syntax</li>
<li>55 (0%) Code written in this language is very readable</li>
<li>31 (0%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">3 (0%) I enjoy using this language</li>
<li>30 (0%) This language has a very dogmatic community</li>
<li>35 (0%) This language encourages writing reusable code.</li>
<li>35 (0%) Writing code in this language is a lot of work</li>
<li>30 (1%) This language is best for very large projects</li>
<li class="supNeg">11 (1%) Programs written in this language tend to be efficient</li>
<li class="supNeg">21 (1%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>30 (1%) Programs written in this language will usually work in future versions of the language</li>
<li class="supNeg">21 (1%) This language is good for numeric computing</li>
<li>65 (1%) I find this language easy to prototype in</li>
<li>27 (1%) This language is suitable for real-time applications</li>
<li>26 (1%) This language is expressive</li>
<li class="supNeg">14 (2%) I can imagine using this language in my day job</li>
<li>35 (2%) This is a low level language</li>
<li class="supPos">92 (2%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">12 (2%) This language is good for distributed computing</li>
<li class="supNeg">4 (2%) I would use this language for writing programs for an embedded hardware platform</li>
<li>25 (2%) I would use this language as a scripting language embedded inside a larger application</li>
<li>32 (2%) I would use this language to write a command-line app</li>
<li class="supPos">83 (2%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supNeg">4 (2%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">5 (2%) Learning this language improved my ability as a programmer</li>
<li class="supNeg">5 (2%) This language has unusual features that I often miss when using other languages</li>
<li>59 (2%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">8 (3%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">16 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>37 (3%) This language is likely to be around for a very long time</li>
<li>48 (3%) This language is good for beginners</li>
<li>62 (3%) I know this language well</li>
<li>64 (3%) There is a lot of accidental complexity when writing code in this language</li>
<li>44 (3%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">79 (3%) This language has many features which feel "tacked on"</li>
<li class="supNeg">10 (3%) I often feel like I am not smart enough to write this language</li>
<li>30 (3%) I would use this language for mobile applications</li>
<li>61 (3%) It is easy to tell at a glance what code in this language does</li>
<li>33 (4%) This language has a high quality implementation</li>
<li>52 (4%) This language is large</li>
<li>66 (4%) This is a high level language</li>
<li class="supNeg">4 (4%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>39 (4%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">16 (4%) This language is likely to have a strong influence on future languages</li>
<li>54 (4%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">14 (4%) I would use this language for writing embedded programs</li>
<li class="supNeg">4 (4%) Code written in this language tends to be very reliable</li>
<li>37 (5%) Programs written in this language tend to play well with others</li>
<li>69 (5%) There are many good commercial tools for this language</li>
<li>61 (5%) The resources for learning this language are of high quality</li>
<li>50 (5%) There are many good tools for this language</li>
<li class="supNeg">12 (5%) The semantics of this language are much different than other languages I know.</li>
<li>48 (5%) This language has a good library distribution mechanism.</li>
<li>62 (5%) This language is likely to be a passing fad</li>
<li class="supNeg">24 (5%) This language excels at symbolic manipulation</li>
<li>34 (5%) I use this language out of choice</li>
<li class="supNeg">18 (6%) Code written in this language tends to be terse</li>
<li>48 (6%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">20 (6%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>45 (6%) This language encourages writing code that is easy to maintain.</li>
<li>53 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li>38 (6%) This language is best for very small projects</li>
<li>59 (7%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">87 (7%) I often get angry when writing code in this language</li>
<li>48 (7%) This language excels at text processing</li>
<li class="supNeg">7 (7%) I would like to write more of this language than I currently do</li>
<li>45 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">88 (8%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supNeg">20 (8%) This language is good for scientific computing</li>
<li class="supNeg">12 (8%) I find code written in this language very elegant</li>
<li class="supPos">91 (8%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">15 (8%) I can imagine this will be a popular language in twenty years time</li>
<li>62 (9%) Code written in this language tends to be verbose</li>
<li class="supNeg">9 (9%) This language has a very coherent design</li>
<li>55 (9%) I would use this language for casual scripting</li>
<li class="supNeg">21 (9%) This language has a strong static type system</li>
<li>52 (9%) This language would be good for teaching children to write software</li>
</ul>
<ul>
<li>35 (0%) I would use this language for writing embedded programs</li>
<li>50 (0%) This language is good for numeric computing</li>
<li>44 (0%) This language makes it easy to shoot yourself in the foot</li>
<li>28 (0%) When I write code in this language I can be very sure it is correct</li>
<li>46 (0%) This language is large</li>
<li>53 (0%) This language encourages writing reusable code.</li>
<li class="supNeg">24 (0%) This language excels at text processing</li>
<li>30 (0%) This language is built on a small core of orthogonal features</li>
<li class="supNeg">0 (0%) I still discover new features of this language on a fairly regular basis</li>
<li>29 (0%) I would like to write more of this language than I currently do</li>
<li>52 (1%) Programs written in this language tend to play well with others</li>
<li>53 (1%) Code written in this language is very readable</li>
<li>36 (1%) Writing code in this language is a lot of work</li>
<li class="supNeg">24 (1%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">76 (1%) Code written in this language tends to be verbose</li>
<li class="supNeg">11 (2%) This language has unusual features that I often miss when using other languages</li>
<li>51 (2%) This language has a niche outside of which I would not use it</li>
<li>26 (2%) There is a wide variety of open source code written in this language</li>
<li>43 (2%) Code written in this language tends to be very reliable</li>
<li class="supNeg">15 (2%) I would use this language for writing server programs</li>
<li>49 (2%) The resources for learning this language are of high quality</li>
<li>70 (2%) I am reluctant to admit to knowing this language</li>
<li>43 (2%) This language has a very dogmatic community</li>
<li>38 (3%) This is a low level language</li>
<li class="supNeg">4 (3%) I can imagine this will be a popular language in twenty years time</li>
<li>39 (4%) I would use this language for a web project</li>
<li>31 (4%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>71 (4%) This language has an annoying syntax</li>
<li>55 (4%) I know this language well</li>
<li>60 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>50 (5%) This language is likely to be around for a very long time</li>
<li class="supNeg">18 (5%) This language is good for distributed computing</li>
<li>46 (5%) This language is expressive</li>
<li>48 (5%) This is a mainstream language</li>
<li>27 (6%) I enjoy using this language</li>
<li>55 (6%) This language has many features which feel "tacked on"</li>
<li>27 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>47 (6%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>56 (6%) This language would be good for teaching children to write software</li>
<li>28 (6%) I can imagine using this language in my day job</li>
<li>34 (7%) This language has a good community</li>
<li>37 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>59 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>53 (7%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>43 (7%) There are many good tools for this language</li>
<li>67 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li>29 (8%) I usually use this language on projects with many other members</li>
<li>55 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">8 (8%) I often feel like I am not smart enough to write this language</li>
<li>25 (8%) Learning this language significantly changed how I use other languages.</li>
<li>70 (8%) There are many good commercial tools for this language</li>
<li>50 (8%) I use many applications written in this language</li>
<li>28 (8%) This language excels at concurrency</li>
<li>52 (8%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">23 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">9 (9%) This language is very flexible</li>
<li>56 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">90 (9%) This language is likely to be a passing fad</li>
<li>60 (9%) This language is best for very large projects</li>
<li>50 (9%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>29 (9%) Code written in this language tends to be terse</li>
</ul>
<ul>
<li>55 (0%) I can imagine this will be a popular language in twenty years time</li>
<li>73 (0%) This language is good for numeric computing</li>
<li class="supNeg">18 (0%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">78 (0%) I usually use this language on projects with many other members</li>
<li>43 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>39 (0%) I would like to write more of this language than I currently do</li>
<li>55 (0%) Libraries in this language tend to be well documented.</li>
<li class="supPos">77 (0%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">87 (0%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">82 (0%) There are many good open-source tools for this language</li>
<li class="supPos">98 (1%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supPos">98 (1%) I find it easy to write efficient code in this language</li>
<li class="supNeg">4 (1%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">86 (1%) There are many good commercial tools for this language</li>
<li class="supPos">76 (1%) There are many good tools for this language</li>
<li class="supPos">88 (1%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>47 (2%) I often feel like I am not smart enough to write this language</li>
<li>56 (2%) This language has a strong static type system</li>
<li class="supPos">97 (2%) I use many applications written in this language</li>
<li class="supPos">93 (2%) This language has a high quality implementation</li>
<li>39 (2%) I would use this language for casual scripting</li>
<li>44 (2%) I find this language easy to prototype in</li>
<li class="supPos">87 (2%) This is a mainstream language</li>
<li class="supNeg">7 (2%) I am reluctant to admit to knowing this language</li>
<li>36 (2%) This language has a very coherent design</li>
<li>43 (3%) This language has a very dogmatic community</li>
<li class="supPos">85 (3%) I know many other people who use this language</li>
<li>31 (3%) This language has a niche outside of which I would not use it</li>
<li class="supPos">84 (3%) Programs written in this language tend to be efficient</li>
<li>33 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>60 (3%) I would use this language for mobile applications</li>
<li class="supPos">92 (3%) Learning this language improved my ability as a programmer</li>
<li>47 (3%) This language has a good library distribution mechanism.</li>
<li class="supNeg">21 (3%) This language excels at concurrency</li>
<li>37 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">78 (4%) The resources for learning this language are of high quality</li>
<li class="supPos">95 (4%) This language is suitable for real-time applications</li>
<li>33 (4%) This language is well suited for an agile development approach using short iterations.</li>
<li>29 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">75 (4%) I know this language well</li>
<li>28 (4%) I find code written in this language very elegant</li>
<li>62 (4%) Writing code in this language is a lot of work</li>
<li class="supPos">95 (4%) Programs written in this language will usually work in future versions of the language</li>
<li>40 (4%) Learning this language significantly changed how I use other languages.</li>
<li>61 (4%) Code written in this language tends to be verbose</li>
<li>56 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>38 (4%) This language has a good community</li>
<li>28 (4%) This language excels at symbolic manipulation</li>
<li>41 (4%) It is easy to tell at a glance what code in this language does</li>
<li>36 (5%) I would use this language for a web project</li>
<li class="supNeg">19 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">5 (5%) I use this language out of choice</li>
<li>49 (5%) This language encourages writing code that is easy to maintain.</li>
<li>49 (6%) This is a high level language</li>
<li>69 (6%) This language is best for very large projects</li>
<li class="supPos">78 (6%) I would use this language to write a command-line app</li>
<li class="supPos">93 (6%) There is a wide variety of open source code written in this language</li>
<li>45 (6%) Code written in this language is very readable</li>
<li>57 (6%) I often get angry when writing code in this language</li>
<li>68 (6%) This language is good for scientific computing</li>
<li>34 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (7%) I enjoy using this language</li>
<li>34 (7%) Code written in this language tends to be very reliable</li>
<li class="supPos">82 (7%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>73 (8%) This language is very flexible</li>
<li>69 (8%) This is a low level language</li>
<li>31 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">91 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>27 (8%) This language excels at text processing</li>
<li>41 (8%) Code written in this language tends to be terse</li>
<li>46 (8%) I would use this language for writing server programs</li>
<li class="supPos">83 (9%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">90 (9%) This language is likely to be around for a very long time</li>
</ul>
<ul>
<li>42 (0%) This language has a very rigid idea of how things should be done</li>
<li>58 (1%) This language is good for scientific computing</li>
<li>46 (1%) I usually use this language on solo projects</li>
<li>44 (2%) I would use this language for a web project</li>
<li>69 (2%) I use this language out of choice</li>
<li>41 (2%) It is easy to debug programs written in this language when it goes wrong</li>
<li>29 (2%) I would use this language as a scripting language embedded inside a larger application</li>
<li>60 (2%) This is a high level language</li>
<li>50 (2%) This language has a very dogmatic community</li>
<li>37 (2%) This language is good for distributed computing</li>
<li>54 (3%) This is a low level language</li>
<li>37 (3%) I can imagine using this language in my day job</li>
<li>46 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>67 (3%) This language is best for very large projects</li>
<li>35 (3%) Learning this language significantly changed how I use other languages.</li>
<li>50 (3%) This language is likely to have a strong influence on future languages</li>
<li>55 (3%) Code written in this language is very readable</li>
<li class="supNeg">21 (3%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>51 (4%) I find code written in this language very elegant</li>
<li>62 (4%) This language has many features which feel "tacked on"</li>
<li class="supPos">79 (4%) I find it easy to write efficient code in this language</li>
<li>65 (4%) This language has a good community</li>
<li>34 (5%) I often feel like I am not smart enough to write this language</li>
<li>69 (5%) This language is suitable for real-time applications</li>
<li>32 (5%) I enjoy using this language</li>
<li>39 (5%) This language excels at symbolic manipulation</li>
<li>33 (5%) This language is good for beginners</li>
<li>36 (5%) It's unusual for me to discover unfamiliar features</li>
<li>59 (5%) This language has a strong static type system</li>
<li>28 (5%) The semantics of this language are much different than other languages I know.</li>
<li>43 (5%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>44 (5%) Learning this language improved my ability as a programmer</li>
<li>43 (5%) I know this language well</li>
<li>73 (5%) This language is likely to be a passing fad</li>
<li>32 (5%) Code written in this language tends to be terse</li>
<li>58 (6%) Programs written in this language tend to play well with others</li>
<li>59 (6%) This language has a very coherent design</li>
<li>28 (6%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>44 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>50 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>51 (6%) This language matches it's problem domain particularly well.</li>
<li>35 (6%) This language is minimal</li>
<li>67 (7%) Programs written in this language tend to be efficient</li>
<li>50 (7%) I still discover new features of this language on a fairly regular basis</li>
<li>35 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>70 (7%) I find this language easy to prototype in</li>
<li>57 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>53 (7%) This language is unusually bad for beginners</li>
<li>47 (7%) This language is large</li>
<li>67 (7%) This language encourages writing code that is easy to maintain.</li>
<li>38 (7%) This language excels at text processing</li>
<li>48 (7%) I would use this language for casual scripting</li>
<li>43 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>44 (8%) This language has an annoying syntax</li>
<li>45 (8%) This language is very flexible</li>
<li>37 (8%) I usually use this language on projects with many other members</li>
<li>41 (8%) This language is well documented</li>
<li class="supPos">80 (8%) This language encourages writing reusable code.</li>
<li>48 (8%) This language has a good library distribution mechanism.</li>
<li>35 (8%) I am reluctant to admit to knowing this language</li>
<li>34 (8%) There are many good open-source tools for this language</li>
<li>51 (8%) This language is expressive</li>
<li>49 (8%) This language has unusual features that I often miss when using other languages</li>
<li>56 (8%) The resources for learning this language are of high quality</li>
<li>37 (8%) Writing code in this language is a lot of work</li>
<li>49 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li>33 (9%) When I write code in this language I can be very sure it is correct</li>
<li>40 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>43 (9%) This is a mainstream language</li>
<li>33 (9%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>58 (9%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
</ul>
<ul>
<li>53 (0%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">24 (1%) This is a low level language</li>
<li>35 (1%) This language is frequently used for applications it isn't suitable for</li>
<li>47 (1%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>67 (1%) I use this language out of choice</li>
<li>25 (2%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">83 (2%) This is a high level language</li>
<li class="supNeg">13 (2%) This language has a strong static type system</li>
<li>27 (2%) This language is good for distributed computing</li>
<li>28 (2%) This language excels at concurrency</li>
<li>30 (2%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>59 (3%) This language has a good community</li>
<li class="supNeg">22 (3%) I can imagine using this language in my day job</li>
<li>38 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>26 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>56 (3%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">17 (3%) Writing code in this language is a lot of work</li>
<li>51 (4%) I would use this language for a web project</li>
<li>30 (4%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">17 (4%) I often get angry when writing code in this language</li>
<li>48 (5%) Code written in this language tends to be terse</li>
<li>45 (5%) I enjoy using this language</li>
<li>37 (5%) There is a wide variety of open source code written in this language</li>
<li>28 (5%) I would use this language for writing server programs</li>
<li>57 (5%) This language has unusual features that I often miss when using other languages</li>
<li class="supPos">92 (5%) This language has a very coherent design</li>
<li class="supPos">81 (5%) I find this language easy to prototype in</li>
<li>45 (5%) This language matches it's problem domain particularly well.</li>
<li>36 (5%) This language has many features which feel "tacked on"</li>
<li>39 (6%) Developers who primarily use this language often burn out after a few years</li>
<li>42 (6%) This language excels at text processing</li>
<li>41 (6%) This language is good for numeric computing</li>
<li>44 (6%) This language is suitable for real-time applications</li>
<li>62 (6%) This language encourages writing code that is easy to maintain.</li>
<li>31 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>25 (6%) This language has an annoying syntax</li>
<li class="supPos">81 (6%) This language is very flexible</li>
<li class="supPos">79 (6%) I find code written in this language very elegant</li>
<li>34 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>40 (7%) This language is good for scientific computing</li>
<li>43 (7%) Programs written in this language will usually work in future versions of the language</li>
<li class="supNeg">23 (7%) This language is unusually bad for beginners</li>
<li>44 (7%) I still discover new features of this language on a fairly regular basis</li>
<li>37 (7%) Programs written in this language tend to be efficient</li>
<li>46 (8%) I usually use this language on solo projects</li>
<li>25 (8%) I usually use this language on projects with many other members</li>
<li>47 (8%) I can imagine this will be a popular language in twenty years time</li>
<li>67 (8%) This language is expressive</li>
<li>71 (8%) It is easy to tell at a glance what code in this language does</li>
<li>69 (8%) Code written in this language is very readable</li>
<li class="supPos">80 (8%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>27 (9%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>54 (9%) I would use this language for a desktop GUI project</li>
<li>36 (9%) This language is well documented</li>
<li>36 (9%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">15 (9%) This language has a niche in which it is great</li>
<li>32 (9%) I would use this language for writing embedded programs</li>
<li>36 (9%) Libraries in this language tend to be well documented.</li>
<li>44 (9%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">20 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>32 (9%) This language has a niche outside of which I would not use it</li>
<li>73 (9%) Learning this language improved my ability as a programmer</li>
<li>31 (9%) This is a mainstream language</li>
</ul>
<ul></ul>
<ul>
<li>55 (0%) I use this language out of choice</li>
<li class="supNeg">17 (1%) I know many other people who use this language</li>
<li>64 (1%) This language is unusually bad for beginners</li>
<li class="supNeg">23 (1%) I usually use this language on solo projects</li>
<li class="supNeg">20 (1%) I use many applications written in this language</li>
<li>33 (1%) This language has many features which feel "tacked on"</li>
<li class="supNeg">17 (1%) This language is good for distributed computing</li>
<li>27 (2%) This language is good for beginners</li>
<li>45 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">22 (2%) This language excels at concurrency</li>
<li class="supNeg">9 (2%) It is easy to tell at a glance what code in this language does</li>
<li>46 (2%) It's unusual for me to discover unfamiliar features</li>
<li>38 (3%) Code written in this language is very readable</li>
<li class="supNeg">2 (3%) I can imagine using this language in my day job</li>
<li class="supNeg">4 (3%) I can imagine this will be a popular language in twenty years time</li>
<li>51 (3%) I often get angry when writing code in this language</li>
<li>37 (3%) There are many good commercial tools for this language</li>
<li>28 (3%) I would use this language for a web project</li>
<li class="supNeg">16 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>70 (3%) This language has a very coherent design</li>
<li>37 (4%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">15 (4%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">19 (4%) This language is best for very large projects</li>
<li>36 (4%) Code written in this language tends to be very reliable</li>
<li>55 (4%) This language has a niche in which it is great</li>
<li>34 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">20 (5%) There is a wide variety of open source code written in this language</li>
<li>36 (5%) This language has a good community</li>
<li>42 (5%) This language has a very dogmatic community</li>
<li>43 (5%) This language encourages writing code that is easy to maintain.</li>
<li>42 (5%) This language is likely to have a strong influence on future languages</li>
<li>56 (5%) Developers who primarily use this language often burn out after a few years</li>
<li>27 (5%) I would use this language to write a command-line app</li>
<li>31 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>47 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li>45 (5%) This language has unusual features that I often miss when using other languages</li>
<li>59 (5%) This language is expressive</li>
<li class="supPos">79 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">23 (6%) I would use this language for a desktop GUI project</li>
<li>54 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">19 (6%) This is a mainstream language</li>
<li class="supNeg">19 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>34 (6%) I regularly use this language</li>
<li>65 (6%) This language is built on a small core of orthogonal features</li>
<li>44 (6%) The resources for learning this language are of high quality</li>
<li>67 (6%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">21 (7%) There are many good open-source tools for this language</li>
<li class="supNeg">19 (7%) I still discover new features of this language on a fairly regular basis</li>
<li>60 (7%) I find code written in this language very elegant</li>
<li>44 (7%) I would use this language for casual scripting</li>
<li>27 (7%) There are many good tools for this language</li>
<li>30 (7%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">7 (7%) Libraries in this language tend to be well documented.</li>
<li>27 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>37 (7%) I enjoy using this language</li>
<li>39 (7%) This language is well documented</li>
<li class="supNeg">15 (8%) Code written in this language tends to be verbose</li>
<li>37 (8%) Writing code in this language is a lot of work</li>
<li>46 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>40 (8%) This language is likely to be around for a very long time</li>
<li>46 (8%) I would like to write more of this language than I currently do</li>
<li>45 (8%) This language has a very rigid idea of how things should be done</li>
<li>37 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>47 (9%) This language encourages writing reusable code.</li>
<li class="supNeg">18 (9%) Programs written in this language tend to play well with others</li>
<li>27 (9%) This language has a good library distribution mechanism.</li>
<li class="supNeg">16 (9%) This language excels at text processing</li>
<li>48 (9%) I know this language well</li>
<li>65 (9%) I often feel like I am not smart enough to write this language</li>
<li>67 (9%) Learning this language improved my ability as a programmer</li>
<li>51 (9%) This language excels at symbolic manipulation</li>
<li>31 (9%) I would use this language for mobile applications</li>
<li>34 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
</ul>
<ul>
<li>52 (0%) I can imagine this will be a popular language in twenty years time</li>
<li>60 (0%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">15 (0%) This language is minimal</li>
<li>66 (0%) This is a high level language</li>
<li>46 (0%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supPos">83 (0%) This language encourages writing reusable code.</li>
<li class="supPos">99 (0%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>56 (0%) This language is good for numeric computing</li>
<li>37 (0%) This is a low level language</li>
<li class="supPos">88 (0%) The resources for learning this language are of high quality</li>
<li>64 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>71 (0%) This language is likely to be around for a very long time</li>
<li class="supPos">98 (1%) I know many other people who use this language</li>
<li>37 (1%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>41 (1%) This language is unusually bad for beginners</li>
<li>34 (1%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>48 (1%) This language is expressive</li>
<li>64 (1%) This language has a strong static type system</li>
<li>49 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>47 (1%) Programs written in this language tend to be efficient</li>
<li>54 (1%) This language is good for scientific computing</li>
<li class="supPos">86 (1%) This language is large</li>
<li class="supPos">98 (1%) Libraries in this language tend to be well documented.</li>
<li>52 (2%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>36 (2%) Learning this language improved my ability as a programmer</li>
<li class="supPos">81 (2%) This language encourages writing code that is easy to maintain.</li>
<li>45 (2%) This language excels at text processing</li>
<li>46 (2%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">75 (2%) I would use this language for writing server programs</li>
<li>62 (2%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">20 (2%) This language is built on a small core of orthogonal features</li>
<li>50 (2%) This language is good for distributed computing</li>
<li class="supPos">83 (2%) I find it easy to write efficient code in this language</li>
<li class="supPos">94 (2%) This language is best for very large projects</li>
<li class="supPos">80 (2%) I find this language easy to prototype in</li>
<li class="supPos">81 (2%) I use many applications written in this language</li>
<li>55 (2%) I still discover new features of this language on a fairly regular basis</li>
<li>65 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">96 (3%) There are many good commercial tools for this language</li>
<li>39 (3%) This language excels at symbolic manipulation</li>
<li>53 (3%) This language is good for beginners</li>
<li>38 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>36 (3%) I find code written in this language very elegant</li>
<li>30 (3%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>53 (3%) I would use this language for casual scripting</li>
<li>30 (3%) This language has unusual features that I often miss when using other languages</li>
<li>37 (4%) This language is very flexible</li>
<li class="supPos">95 (4%) This is a mainstream language</li>
<li class="supNeg">15 (4%) I often feel like I am not smart enough to write this language</li>
<li>53 (4%) I learned this language early in my career as a programmer</li>
<li class="supNeg">4 (4%) This language has a niche in which it is great</li>
<li>50 (4%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>68 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>61 (4%) Code written in this language tends to be very reliable</li>
<li>39 (4%) I would like to write more of this language than I currently do</li>
<li>67 (4%) This language has a good library distribution mechanism.</li>
<li class="supPos">78 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>57 (4%) Code written in this language is very readable</li>
<li>55 (4%) This language has a very coherent design</li>
<li class="supPos">87 (4%) It is easy to tell at a glance what code in this language does</li>
<li>35 (4%) This language matches it's problem domain particularly well.</li>
<li>74 (4%) Programs written in this language tend to play well with others</li>
<li class="supPos">95 (4%) This language has a high quality implementation</li>
<li>52 (4%) I enjoy using this language</li>
<li>66 (4%) This language has a good community</li>
<li class="supNeg">5 (5%) The semantics of this language are much different than other languages I know.</li>
<li>39 (5%) This language is likely to be a passing fad</li>
<li>74 (5%) This language has a very dogmatic community</li>
<li>31 (5%) This language excels at concurrency</li>
<li>32 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">17 (5%) This language has a niche outside of which I would not use it</li>
<li>34 (5%) When I write code in this language I can be very sure it is correct</li>
<li>51 (6%) This language would be good for teaching children to write software</li>
<li class="supPos">80 (6%) This language has many features which feel "tacked on"</li>
<li class="supNeg">18 (6%) This language is best for very small projects</li>
<li>41 (6%) I would use this language for writing embedded programs</li>
<li>27 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">93 (6%) This language is well documented</li>
<li>37 (6%) Writing code in this language is a lot of work</li>
<li class="supPos">93 (6%) I would use this language for mobile applications</li>
<li>74 (6%) I would use this language for a web project</li>
<li class="supPos">92 (7%) It is easy to debug programs written in this language when it goes wrong</li>
<li>56 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">92 (7%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>52 (7%) This language is suitable for real-time applications</li>
<li>43 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">89 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>54 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>73 (9%) It's unusual for me to discover unfamiliar features</li>
<li>51 (9%) I can imagine using this language in my day job</li>
<li>67 (9%) I would use this language to write a command-line app</li>
<li>26 (9%) Code written in this language tends to be terse</li>
<li class="supPos">76 (9%) I know this language well</li>
</ul>
<ul></ul>
<ul></ul>
<ul>
<li>36 (0%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supPos">78 (0%) This language is expressive</li>
<li>25 (0%) This language has an annoying syntax</li>
<li class="supPos">77 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>56 (0%) This language is large</li>
<li>60 (0%) There are many good commercial tools for this language</li>
<li>73 (0%) Learning this language improved my ability as a programmer</li>
<li class="supPos">78 (0%) This language encourages writing reusable code.</li>
<li>29 (0%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">83 (0%) This language is best for very small projects</li>
<li class="supNeg">21 (0%) This is a low level language</li>
<li class="supPos">88 (0%) This language would be good for teaching children to write software</li>
<li>68 (0%) I still discover new features of this language on a fairly regular basis</li>
<li>71 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>40 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>67 (1%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">87 (1%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>52 (2%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">21 (2%) I often feel like I am not smart enough to write this language</li>
<li>63 (2%) This language has a very dogmatic community</li>
<li class="supNeg">15 (2%) This language is unusually bad for beginners</li>
<li class="supPos">96 (2%) I would use this language to write a command-line app</li>
<li>52 (2%) I find it easy to write efficient code in this language</li>
<li>37 (2%) This language is good for distributed computing</li>
<li>43 (2%) Code written in this language tends to be very reliable</li>
<li>48 (2%) Code written in this language tends to be terse</li>
<li>67 (2%) I use many applications written in this language</li>
<li>28 (2%) This language has a niche in which it is great</li>
<li>59 (2%) This language excels at symbolic manipulation</li>
<li>64 (2%) I find code written in this language very elegant</li>
<li>33 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">75 (2%) Libraries in this language tend to be well documented.</li>
<li>71 (2%) I know this language well</li>
<li class="supPos">82 (2%) This language has a good community</li>
<li>61 (3%) This language is best for very large projects</li>
<li class="supPos">80 (3%) This language excels at text processing</li>
<li>62 (3%) This language has many features which feel "tacked on"</li>
<li class="supPos">75 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supPos">95 (3%) I find this language easy to prototype in</li>
<li>33 (3%) This language is built on a small core of orthogonal features</li>
<li>65 (3%) I usually use this language on solo projects</li>
<li>65 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>45 (3%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>51 (3%) I would like to write more of this language than I currently do</li>
<li class="supPos">96 (3%) This language has a good library distribution mechanism.</li>
<li class="supPos">84 (3%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>51 (3%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">14 (4%) This language has a strong static type system</li>
<li class="supPos">83 (4%) This is a high level language</li>
<li>73 (4%) I know many other people who use this language</li>
<li class="supNeg">4 (4%) Writing code in this language is a lot of work</li>
<li>63 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">76 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">88 (4%) There is a wide variety of open source code written in this language</li>
<li>28 (4%) I learned this language early in my career as a programmer</li>
<li>68 (4%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>73 (4%) This is a mainstream language</li>
<li>31 (4%) Code written in this language tends to be verbose</li>
<li class="supPos">94 (5%) The resources for learning this language are of high quality</li>
<li class="supPos">94 (5%) I would use this language for a web project</li>
<li>38 (5%) This language is suitable for real-time applications</li>
<li>62 (5%) I usually use this language on projects with many other members</li>
<li>27 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>46 (5%) I enjoy using this language</li>
<li>64 (5%) I would use this language for writing server programs</li>
<li class="supPos">94 (5%) I would use this language for casual scripting</li>
<li>64 (5%) It is easy to debug programs written in this language when it goes wrong</li>
<li>60 (6%) I regularly use this language</li>
<li>36 (6%) This language is minimal</li>
<li class="supPos">77 (6%) I would use this language for a desktop GUI project</li>
<li>70 (6%) Programs written in this language tend to play well with others</li>
<li>32 (6%) When I write code in this language I can be very sure it is correct</li>
<li>28 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>28 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>41 (7%) This language matches it's problem domain particularly well.</li>
<li class="supPos">92 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>44 (7%) Programs written in this language will usually work in future versions of the language</li>
<li class="supNeg">24 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">91 (7%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>27 (7%) This language excels at concurrency</li>
<li class="supPos">76 (7%) I would list this language on my resume</li>
<li class="supPos">82 (7%) There are many good open-source tools for this language</li>
<li>74 (7%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">91 (8%) I use this language out of choice</li>
<li class="supNeg">21 (8%) This language has a very rigid idea of how things should be done</li>
<li>27 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>40 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>28 (8%) I would use this language for writing embedded programs</li>
<li>29 (8%) I am reluctant to admit to knowing this language</li>
<li>51 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>67 (8%) I would use this language for mobile applications</li>
<li>63 (9%) This language has a very coherent design</li>
<li class="supPos">86 (9%) This language is well documented</li>
<li>66 (9%) There are many good tools for this language</li>
</ul>
<ul>
<li class="supNeg">12 (2%) I can imagine this will be a popular language in twenty years time</li>
<li>45 (2%) This language has a very coherent design</li>
<li>39 (3%) The resources for learning this language are of high quality</li>
<li>32 (3%) I know many other people who use this language</li>
<li>43 (4%) This is a mainstream language</li>
<li class="supNeg">14 (4%) This language excels at symbolic manipulation</li>
<li class="supNeg">10 (4%) I would use this language for writing server programs</li>
<li>49 (4%) There are many good commercial tools for this language</li>
<li>31 (4%) I use many applications written in this language</li>
<li class="supNeg">7 (5%) I can imagine using this language in my day job</li>
<li>25 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>66 (5%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>68 (5%) I often get angry when writing code in this language</li>
<li class="supNeg">8 (5%) I still discover new features of this language on a fairly regular basis</li>
<li>71 (5%) Developers who primarily use this language often burn out after a few years</li>
<li>37 (6%) This language has a very dogmatic community</li>
<li class="supNeg">8 (6%) I would use this language as a scripting language embedded inside a larger application</li>
<li>54 (6%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">8 (7%) I enjoy using this language</li>
<li class="supNeg">9 (7%) This language is good for distributed computing</li>
<li class="supNeg">8 (7%) This language excels at text processing</li>
<li class="supNeg">10 (8%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">11 (8%) This language has a good community</li>
<li>41 (8%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supPos">85 (8%) I learned this language early in my career as a programmer</li>
<li>54 (8%) This language has a high quality implementation</li>
<li>59 (8%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">21 (9%) I usually use this language on projects with many other members</li>
<li>30 (9%) There are many good tools for this language</li>
<li>74 (9%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">12 (9%) This language is expressive</li>
</ul>
<ul></ul>
<ul>
<li>29 (4%) This is a low level language</li>
<li>71 (5%) This is a high level language</li>
<li>36 (5%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">16 (5%) When I write code in this language I can be very sure it is correct</li>
<li>54 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>27 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>57 (7%) Programs written in this language will usually work in future versions of the language</li>
<li class="supPos">79 (7%) I find this language easy to prototype in</li>
<li>41 (7%) Code written in this language tends to be terse</li>
<li>34 (7%) Learning this language improved my ability as a programmer</li>
<li>39 (8%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>36 (8%) This language has unusual features that I often miss when using other languages</li>
<li>62 (8%) I use this language out of choice</li>
<li>44 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>31 (8%) Learning this language significantly changed how I use other languages.</li>
<li>33 (9%) This language is suitable for real-time applications</li>
<li>49 (9%) This language is unusually bad for beginners</li>
<li>29 (9%) Writing code in this language is a lot of work</li>
<li>25 (9%) I often feel like I am not smart enough to write this language</li>
<li>40 (9%) Code written in this language tends to be verbose</li>
<li>55 (9%) The resources for learning this language are of high quality</li>
<li class="supPos">77 (9%) I would use this language for casual scripting</li>
<li class="supNeg">21 (9%) This language excels at concurrency</li>
<li>30 (9%) I can imagine using this language in my day job</li>
</ul>
<ul>
<li>31 (0%) I would use this language for a desktop GUI project</li>
<li>63 (0%) This language is good for scientific computing</li>
<li class="supPos">78 (0%) This language is built on a small core of orthogonal features</li>
<li>62 (0%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>25 (0%) There are many good tools for this language</li>
<li class="supNeg">19 (0%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>31 (0%) There are many good commercial tools for this language</li>
<li>34 (0%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supPos">86 (0%) This language has a very coherent design</li>
<li class="supNeg">24 (0%) This language is best for very small projects</li>
<li class="supNeg">16 (0%) I know many other people who use this language</li>
<li>34 (0%) I would use this language for writing embedded programs</li>
<li>39 (1%) There are many good open-source tools for this language</li>
<li class="supNeg">20 (1%) I can imagine using this language in my day job</li>
<li>31 (1%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>58 (1%) I would like to write more of this language than I currently do</li>
<li>63 (1%) This language has a very dogmatic community</li>
<li>29 (1%) I would use this language for mobile applications</li>
<li>50 (2%) I usually use this language on solo projects</li>
<li>54 (2%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>54 (2%) I enjoy using this language</li>
<li>66 (2%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">76 (2%) This language encourages writing reusable code.</li>
<li class="supNeg">20 (2%) This language makes it easy to shoot yourself in the foot</li>
<li>46 (3%) I would list this language on my resume</li>
<li>67 (3%) This language has unusual features that I often miss when using other languages</li>
<li>50 (3%) This language has a good community</li>
<li>60 (3%) I find this language easy to prototype in</li>
<li>69 (3%) Code written in this language tends to be very reliable</li>
<li class="supPos">77 (3%) I use this language out of choice</li>
<li>60 (3%) This language is likely to be a passing fad</li>
<li class="supNeg">19 (3%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">16 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>58 (3%) Code written in this language is very readable</li>
<li class="supPos">96 (3%) This language has a strong static type system</li>
<li>38 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>40 (4%) This language is large</li>
<li class="supNeg">19 (4%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">14 (4%) This is a low level language</li>
<li>25 (4%) This language excels at concurrency</li>
<li>63 (4%) This language has a high quality implementation</li>
<li class="supPos">80 (5%) This language is expressive</li>
<li>28 (5%) This language has a good library distribution mechanism.</li>
<li>34 (5%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>26 (5%) I can imagine this will be a popular language in twenty years time</li>
<li>31 (6%) This language has many features which feel "tacked on"</li>
<li>26 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>69 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li>40 (6%) Code written in this language tends to be terse</li>
<li>46 (6%) This language is minimal</li>
<li class="supPos">79 (7%) I find code written in this language very elegant</li>
<li class="supNeg">12 (7%) I use many applications written in this language</li>
<li class="supPos">88 (7%) Learning this language improved my ability as a programmer</li>
<li class="supPos">88 (7%) This is a high level language</li>
<li>28 (7%) Code written in this language tends to be verbose</li>
<li class="supPos">79 (7%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>53 (7%) This language is well documented</li>
<li class="supNeg">17 (7%) I regularly use this language</li>
<li>27 (7%) This language is likely to be around for a very long time</li>
<li>26 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li>27 (7%) Programs written in this language tend to play well with others</li>
<li>45 (8%) This language has an annoying syntax</li>
<li>46 (8%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">23 (8%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">8 (8%) This is a mainstream language</li>
<li>42 (8%) Writing code in this language is a lot of work</li>
<li class="supNeg">21 (8%) This language is good for distributed computing</li>
<li>49 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>73 (9%) This language excels at symbolic manipulation</li>
<li>60 (9%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">82 (9%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>42 (9%) This language is very flexible</li>
<li>53 (9%) This language matches it's problem domain particularly well.</li>
<li>29 (9%) I would use this language for writing server programs</li>
<li class="supNeg">19 (9%) I would use this language for a web project</li>
</ul>
<ul>
<li>71 (1%) This language has a very coherent design</li>
<li>36 (2%) I use many applications written in this language</li>
<li>42 (4%) This language is good for beginners</li>
<li>29 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>53 (5%) This language has an annoying syntax</li>
<li>31 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supPos">83 (5%) This is a high level language</li>
<li>40 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>69 (5%) This language has unusual features that I often miss when using other languages</li>
<li>30 (5%) Writing code in this language is a lot of work</li>
<li>51 (5%) This language has a good library distribution mechanism.</li>
<li>49 (5%) This language has many features which feel "tacked on"</li>
<li class="supNeg">22 (6%) This is a low level language</li>
<li>71 (6%) I find code written in this language very elegant</li>
<li>60 (6%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>34 (6%) I often get angry when writing code in this language</li>
<li>32 (6%) This language has a very rigid idea of how things should be done</li>
<li>73 (6%) This language has a high quality implementation</li>
<li>60 (6%) Code written in this language is very readable</li>
<li>62 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li>59 (7%) This language has a good community</li>
<li>55 (7%) This language is unusually bad for beginners</li>
<li>65 (7%) I would like to write more of this language than I currently do</li>
<li>34 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li>61 (7%) I would use this language for casual scripting</li>
<li>48 (7%) This language is likely to be around for a very long time</li>
<li>48 (8%) This language is built on a small core of orthogonal features</li>
<li class="supPos">81 (8%) I find this language easy to prototype in</li>
<li class="supNeg">10 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>64 (8%) Learning this language significantly changed how I use other languages.</li>
<li>43 (8%) I regularly use this language</li>
<li>34 (9%) This is a mainstream language</li>
<li>44 (9%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">17 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li>53 (9%) Programs written in this language tend to play well with others</li>
<li>32 (9%) I usually use this language on projects with many other members</li>
<li>40 (9%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">78 (9%) This language is expressive</li>
<li>47 (9%) I often feel like I am not smart enough to write this language</li>
<li class="supPos">75 (9%) I use this language out of choice</li>
<li>35 (9%) I know many other people who use this language</li>
<li>52 (9%) I would use this language for a desktop GUI project</li>
<li>71 (9%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
</ul>
<ul>
<li>40 (0%) There is a lot of accidental complexity when writing code in this language</li>
<li>42 (1%) Code written in this language tends to be terse</li>
<li>40 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>36 (1%) I usually use this language on projects with many other members</li>
<li class="supNeg">21 (1%) This language has a strong static type system</li>
<li>45 (1%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>41 (1%) I am reluctant to admit to knowing this language</li>
<li>44 (1%) This language has a very rigid idea of how things should be done</li>
<li>26 (1%) This language excels at concurrency</li>
<li>54 (1%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">20 (2%) This language is good for distributed computing</li>
<li>53 (2%) Code written in this language is very readable</li>
<li>26 (2%) This language is minimal</li>
<li>63 (2%) This language has an annoying syntax</li>
<li>59 (2%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supPos">82 (3%) I enjoy playing with this language but would never use it for "real code"</li>
<li>29 (3%) Writing code in this language is a lot of work</li>
<li>30 (3%) Programs written in this language tend to be efficient</li>
<li>51 (3%) This language is large</li>
<li>47 (3%) This language encourages writing reusable code.</li>
<li>50 (3%) The semantics of this language are much different than other languages I know.</li>
<li>33 (3%) This language has unusual features that I often miss when using other languages</li>
<li class="supPos">92 (3%) This language is good for numeric computing</li>
<li class="supNeg">20 (4%) This language excels at text processing</li>
<li>43 (4%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">23 (4%) Learning this language significantly changed how I use other languages.</li>
<li>54 (4%) I would use this language for casual scripting</li>
<li class="supPos">89 (4%) This language has a niche outside of which I would not use it</li>
<li>44 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>47 (4%) There are many good tools for this language</li>
<li>31 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>45 (4%) This is a mainstream language</li>
<li>34 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">22 (4%) I would use this language for a web project</li>
<li class="supNeg">18 (4%) This is a low level language</li>
<li>40 (4%) I would like to write more of this language than I currently do</li>
<li>52 (4%) This language is unusually bad for beginners</li>
<li class="supNeg">16 (4%) This language is best for very large projects</li>
<li>57 (5%) This language has many features which feel "tacked on"</li>
<li class="supPos">80 (5%) I find this language easy to prototype in</li>
<li>26 (5%) This language is suitable for real-time applications</li>
<li>33 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">5 (5%) I would use this language for writing server programs</li>
<li>51 (5%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supPos">91 (5%) This language is good for scientific computing</li>
<li class="supNeg">12 (5%) I would use this language for mobile applications</li>
<li>42 (5%) Code written in this language tends to be verbose</li>
<li>41 (6%) This language has a very coherent design</li>
<li>51 (6%) I find it easy to write efficient code in this language</li>
<li>36 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>47 (6%) This language is best for very small projects</li>
<li class="supNeg">9 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">9 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">86 (6%) This is a high level language</li>
<li>46 (6%) I usually use this language on solo projects</li>
<li>46 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>45 (6%) This language has a very dogmatic community</li>
<li>51 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li>54 (6%) Libraries in this language tend to be well documented.</li>
<li>50 (6%) Developers who primarily use this language often burn out after a few years</li>
<li>47 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">23 (7%) When I write code in this language I can be very sure it is correct</li>
<li>37 (7%) I find code written in this language very elegant</li>
<li>28 (7%) I would use this language for a desktop GUI project</li>
<li>61 (7%) This language has a high quality implementation</li>
<li>26 (7%) I can imagine using this language in my day job</li>
<li>38 (7%) I use many applications written in this language</li>
<li>41 (8%) This language is good for beginners</li>
<li class="supPos">85 (8%) This language matches it's problem domain particularly well.</li>
<li>27 (8%) Learning this language improved my ability as a programmer</li>
<li>49 (8%) This language is likely to be a passing fad</li>
<li>32 (8%) Code written in this language tends to be very reliable</li>
<li>39 (8%) I would list this language on my resume</li>
<li>40 (8%) This language would be good for teaching children to write software</li>
<li>51 (8%) This language encourages writing code that is easy to maintain.</li>
<li>35 (8%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">21 (9%) I enjoy using this language</li>
<li>29 (9%) I would use this language for writing embedded programs</li>
<li>37 (9%) There is a wide variety of open source code written in this language</li>
<li>37 (9%) I learned this language early in my career as a programmer</li>
<li class="supNeg">21 (9%) I would use this language to write a command-line app</li>
<li>57 (9%) There are many good commercial tools for this language</li>
</ul>
<ul></ul>
<ul></ul>
<ul>
<li class="supNeg">16 (1%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">18 (2%) There is a lot of accidental complexity when writing code in this language</li>
<li>43 (2%) Developers who primarily use this language often burn out after a few years</li>
<li>38 (2%) Code written in this language is very readable</li>
<li class="supPos">75 (3%) This is a high level language</li>
<li>35 (3%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">3 (3%) I know many other people who use this language</li>
<li>54 (3%) This language is built on a small core of orthogonal features</li>
<li>51 (3%) Code written in this language tends to be very reliable</li>
<li>51 (3%) This language would be good for teaching children to write software</li>
<li>50 (3%) Programs written in this language will usually work in future versions of the language</li>
<li>66 (4%) I find this language easy to prototype in</li>
<li>28 (4%) This language has a strong static type system</li>
<li>50 (4%) This language makes it easy to shoot yourself in the foot</li>
<li>38 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>26 (5%) There are many good commercial tools for this language</li>
<li class="supNeg">20 (5%) It's unusual for me to discover unfamiliar features</li>
<li>70 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li>43 (5%) I would use this language for writing server programs</li>
<li>40 (5%) This language is well documented</li>
<li class="supPos">93 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">12 (5%) I can imagine using this language in my day job</li>
<li class="supPos">77 (5%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>56 (5%) I would use this language for casual scripting</li>
<li>30 (5%) There are many good open-source tools for this language</li>
<li class="supNeg">17 (6%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>46 (6%) I find it easy to write efficient code in this language</li>
<li class="supNeg">23 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>66 (6%) I use this language out of choice</li>
<li>37 (6%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">14 (6%) This is a mainstream language</li>
<li class="supNeg">22 (6%) I would list this language on my resume</li>
<li class="supNeg">23 (7%) When I write code in this language I can be very sure it is correct</li>
<li>46 (7%) I would use this language for a desktop GUI project</li>
<li>72 (7%) This language is expressive</li>
<li>38 (8%) This language excels at concurrency</li>
<li>39 (8%) This language has many features which feel "tacked on"</li>
<li>51 (8%) This language is likely to have a strong influence on future languages</li>
<li>67 (8%) This language excels at symbolic manipulation</li>
<li class="supNeg">24 (8%) There is a wide variety of open source code written in this language</li>
<li>42 (8%) This language is good for scientific computing</li>
<li>26 (9%) This is a low level language</li>
<li>41 (9%) This language is suitable for real-time applications</li>
<li class="supNeg">16 (9%) I usually use this language on projects with many other members</li>
<li>65 (9%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">15 (9%) I would use this language for writing programs for an embedded hardware platform</li>
</ul>
<ul></ul>
</div>
k-means with k = 22
<tabled class="data" id="clusters22">
  <trd>
    <tdd>Erlang,0.0</tdd>
  </trd>
  <trd>
    <tdd>C#,7.0</tdd>
    <tdd>Java,7.0</tdd>
    <tdd>C++,8.0</tdd>
    <tdd>C,10.0</tdd>
  </trd>
  <trd>
    <tdd>AWK,0.0</tdd>
  </trd>
  <trd>
    <tdd>Assembler,0.0</tdd>
  </trd>
  <trd>
    <tdd>Cobol,6.0</tdd>
    <tdd>Visual Basic,6.0</tdd>
  </trd>
  <trd>
    <tdd>Delphi,4.0</tdd>
    <tdd>Fortran,6.0</tdd>
    <tdd>Pascal,6.0</tdd>
    <tdd>Objective C,8.0</tdd>
  </trd>
  <trd>
    <tdd>Scheme,4.0</tdd>
    <tdd>Smalltalk,4.0</tdd>
  </trd>
  <trd>
    <tdd>Python,0.0</tdd>
  </trd>
  <trd>
    <tdd>ActionScript,0.0</tdd>
  </trd>
  <trd>
    <tdd>PHP,0.0</tdd>
  </trd>
  <trd>
    <tdd>Javascript,5.0</tdd>
    <tdd>Perl,5.0</tdd>
  </trd>
  <trd>
    <tdd>REBOL,0.0</tdd>
  </trd>
  <trd>
    <tdd>R,4.0</tdd>
    <tdd>Mathematica,5.0</tdd>
    <tdd>Matlab,6.0</tdd>
    <tdd>ELisp,7.0</tdd>
    <tdd>J,8.0</tdd>
  </trd>
  <trd>
    <tdd>Shell,0.0</tdd>
  </trd>
  <trd>
    <tdd>F#,5.0</tdd>
    <tdd>O'Caml,5.0</tdd>
    <tdd>Clojure,6.0</tdd>
    <tdd>Go,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>Haxe,7.0</tdd>
    <tdd>Scala,8.0</tdd>
    <tdd>Standard ML,8.0</tdd>
  </trd>
  <trd>
    <tdd>Io,5.0</tdd>
    <tdd>Factor,6.0</tdd>
    <tdd>Lua,7.0</tdd>
    <tdd>Mozart-Oz,7.0</tdd>
  </trd>
  <trd>
    <tdd>Ruby,4.0</tdd>
    <tdd>Groovy,4.0</tdd>
  </trd>
  <trd>
    <tdd>TCL,0.0</tdd>
  </trd>
  <trd>
    <tdd>APL,5.0</tdd>
    <tdd>Prolog,5.0</tdd>
    <tdd>Forth,7.0</tdd>
  </trd>
  <trd>
    <tdd>Coq,8.0</tdd>
    <tdd>Agda,8.0</tdd>
    <tdd>Haskell,9.0</tdd>
  </trd>
  <trd>
    <tdd>Ada,5.0</tdd>
    <tdd>D,5.0</tdd>
    <tdd>Eiffel,5.0</tdd>
  </trd>
</tabled>
<div class="support" id="support22">
<ul></ul>
<ul>
<li>54 (1%) I can imagine this will be a popular language in twenty years time</li>
<li>39 (3%) I would like to write more of this language than I currently do</li>
<li class="supNeg">4 (3%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">94 (3%) This language has a high quality implementation</li>
<li>60 (4%) This language has a strong static type system</li>
<li>34 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">94 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supPos">91 (5%) This is a mainstream language</li>
<li class="supPos">83 (5%) The resources for learning this language are of high quality</li>
<li>28 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li>32 (5%) I find code written in this language very elegant</li>
<li class="supPos">91 (5%) There are many good commercial tools for this language</li>
<li>33 (6%) This language excels at symbolic manipulation</li>
<li>39 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>26 (7%) This language excels at concurrency</li>
<li class="supPos">91 (7%) I know many other people who use this language</li>
<li>55 (7%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supPos">75 (7%) I know this language well</li>
<li class="supPos">81 (7%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">91 (7%) I find it easy to write efficient code in this language</li>
<li>46 (7%) I would use this language for casual scripting</li>
<li>51 (8%) Code written in this language is very readable</li>
<li>61 (8%) This language is good for scientific computing</li>
<li class="supNeg">24 (8%) This language has a niche outside of which I would not use it</li>
<li>64 (8%) This language is good for numeric computing</li>
<li>26 (8%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supPos">89 (8%) I use many applications written in this language</li>
<li>26 (8%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">23 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>57 (9%) This is a high level language</li>
<li>72 (9%) I would use this language to write a command-line app</li>
<li class="supPos">83 (9%) There are many good tools for this language</li>
<li class="supPos">82 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
</ul>
<ul></ul>
<ul></ul>
<ul>
<li class="supPos">79 (0%) I learned this language early in my career as a programmer</li>
<li>37 (0%) This is a low level language</li>
<li>30 (0%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">5 (0%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">11 (0%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">5 (0%) I find code written in this language very elegant</li>
<li class="supNeg">6 (1%) When I write code in this language I can be very sure it is correct</li>
<li>60 (1%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">13 (1%) This language is good for scientific computing</li>
<li class="supNeg">5 (1%) I enjoy using this language</li>
<li class="supNeg">11 (1%) I can imagine using this language in my day job</li>
<li class="supNeg">20 (1%) This language is very flexible</li>
<li class="supNeg">1 (1%) Learning this language improved my ability as a programmer</li>
<li class="supNeg">16 (1%) This language excels at symbolic manipulation</li>
<li>27 (1%) I would list this language on my resume</li>
<li>30 (1%) This language is suitable for real-time applications</li>
<li class="supNeg">9 (1%) I still discover new features of this language on a fairly regular basis</li>
<li>51 (1%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">6 (1%) This language is built on a small core of orthogonal features</li>
<li>56 (1%) Code written in this language is very readable</li>
<li class="supPos">98 (1%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">13 (2%) I would use this language for writing server programs</li>
<li>41 (3%) There are many good tools for this language</li>
<li>33 (3%) This language is best for very large projects</li>
<li class="supPos">96 (3%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>48 (3%) This language encourages writing code that is easy to maintain.</li>
<li>32 (3%) I usually use this language on projects with many other members</li>
<li>33 (4%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">11 (4%) This language has a niche in which it is great</li>
<li>53 (4%) This is a mainstream language</li>
<li class="supNeg">4 (4%) This language has unusual features that I often miss when using other languages</li>
<li>27 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>42 (4%) This language has a high quality implementation</li>
<li class="supNeg">11 (4%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">16 (4%) This language excels at concurrency</li>
<li>34 (4%) This language has a very dogmatic community</li>
<li>51 (5%) It's unusual for me to discover unfamiliar features</li>
<li>38 (5%) I find it easy to write efficient code in this language</li>
<li class="supNeg">13 (5%) I would use this language for writing embedded programs</li>
<li>53 (5%) I know this language well</li>
<li class="supNeg">11 (5%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">5 (5%) This language is good for distributed computing</li>
<li>65 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li>36 (5%) This language has a strong static type system</li>
<li class="supNeg">5 (5%) I would like to write more of this language than I currently do</li>
<li class="supNeg">18 (5%) Programs written in this language tend to be efficient</li>
<li class="supNeg">6 (6%) Code written in this language tends to be terse</li>
<li class="supNeg">12 (6%) This language is minimal</li>
<li class="supNeg">10 (6%) There are many good open-source tools for this language</li>
<li class="supPos">93 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>26 (6%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supNeg">22 (6%) I would use this language to write a command-line app</li>
<li class="supNeg">6 (6%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supPos">87 (7%) Developers who primarily use this language often burn out after a few years</li>
<li>55 (7%) This language is large</li>
<li class="supNeg">15 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li>68 (7%) This language has many features which feel "tacked on"</li>
<li class="supNeg">20 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">7 (7%) Learning this language significantly changed how I use other languages.</li>
<li>34 (8%) Programs written in this language tend to play well with others</li>
<li>71 (8%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>61 (9%) This is a high level language</li>
<li class="supPos">85 (9%) I often get angry when writing code in this language</li>
<li>55 (9%) It is easy to tell at a glance what code in this language does</li>
<li class="supNeg">18 (9%) This language is expressive</li>
<li class="supNeg">24 (9%) This language encourages writing reusable code.</li>
</ul>
<ul>
<li>47 (2%) This language has a very coherent design</li>
<li>45 (2%) I would use this language to write a command-line app</li>
<li class="supNeg">24 (3%) When I write code in this language I can be very sure it is correct</li>
<li>30 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>31 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>52 (4%) Code written in this language is very readable</li>
<li class="supNeg">15 (4%) This language is best for very small projects</li>
<li>26 (4%) Code written in this language tends to be terse</li>
<li>55 (4%) Programs written in this language tend to be efficient</li>
<li>69 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>50 (5%) This is a low level language</li>
<li>35 (5%) Learning this language improved my ability as a programmer</li>
<li>36 (5%) I find code written in this language very elegant</li>
<li>31 (5%) I would use this language for casual scripting</li>
<li>60 (6%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">17 (6%) I would use this language as a scripting language embedded inside a larger application</li>
<li>43 (6%) This language has a very dogmatic community</li>
<li>56 (6%) This language is suitable for real-time applications</li>
<li>61 (6%) I often get angry when writing code in this language</li>
<li>25 (7%) The semantics of this language are much different than other languages I know.</li>
<li>42 (7%) This language is large</li>
<li>54 (7%) This is a high level language</li>
<li>42 (7%) I would use this language for writing embedded programs</li>
<li>63 (7%) Programs written in this language will usually work in future versions of the language</li>
<li>44 (7%) This language has a good library distribution mechanism.</li>
<li>27 (7%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">22 (7%) This language is good for distributed computing</li>
<li>66 (7%) Code written in this language tends to be verbose</li>
<li>54 (7%) This language has a strong static type system</li>
<li class="supNeg">24 (7%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">16 (7%) I would use this language for writing server programs</li>
<li>43 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>36 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>47 (8%) This is a mainstream language</li>
<li>32 (8%) I would use this language for a web project</li>
<li>52 (8%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">21 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>33 (8%) This language is built on a small core of orthogonal features</li>
<li>67 (8%) This language has an annoying syntax</li>
<li>53 (8%) This language encourages writing code that is easy to maintain.</li>
<li>51 (8%) This language makes it easy to shoot yourself in the foot</li>
<li>58 (8%) This language has a niche outside of which I would not use it</li>
<li>28 (8%) This language excels at concurrency</li>
<li>56 (8%) This language has many features which feel "tacked on"</li>
<li class="supNeg">23 (8%) This language excels at symbolic manipulation</li>
<li>44 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>35 (8%) This language is minimal</li>
<li class="supNeg">23 (8%) There are many good open-source tools for this language</li>
<li>32 (8%) There is a wide variety of open source code written in this language</li>
<li>56 (8%) There are many good commercial tools for this language</li>
<li>42 (9%) It is easy to debug programs written in this language when it goes wrong</li>
<li>56 (9%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">18 (9%) This language excels at text processing</li>
<li>40 (9%) Code written in this language tends to be very reliable</li>
<li>53 (9%) This language has a very rigid idea of how things should be done</li>
<li>36 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li>41 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>53 (9%) It is easy to tell at a glance what code in this language does</li>
<li>45 (9%) Writing code in this language is a lot of work</li>
<li class="supNeg">13 (9%) I enjoy using this language</li>
</ul>
<ul>
<li>68 (0%) I use this language out of choice</li>
<li class="supPos">84 (0%) This is a high level language</li>
<li class="supNeg">23 (0%) This is a low level language</li>
<li>70 (0%) This language is likely to have a strong influence on future languages</li>
<li>32 (0%) I would use this language for writing server programs</li>
<li>53 (0%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>29 (0%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>36 (0%) This language is frequently used for applications it isn't suitable for</li>
<li>33 (0%) I know many other people who use this language</li>
<li>28 (1%) This language is good for distributed computing</li>
<li class="supNeg">14 (1%) Writing code in this language is a lot of work</li>
<li class="supPos">84 (1%) I find code written in this language very elegant</li>
<li>40 (1%) I usually use this language on solo projects</li>
<li>41 (1%) There is a wide variety of open source code written in this language</li>
<li>30 (1%) This language excels at concurrency</li>
<li>48 (1%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supNeg">20 (1%) I can imagine using this language in my day job</li>
<li>26 (1%) When I write code in this language I can be very sure it is correct</li>
<li>38 (1%) I use many applications written in this language</li>
<li>45 (1%) Code written in this language tends to be terse</li>
<li>61 (1%) This language has a good community</li>
<li>45 (2%) This language is good for scientific computing</li>
<li>46 (2%) This language excels at text processing</li>
<li>72 (2%) I would like to write more of this language than I currently do</li>
<li>29 (2%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">13 (2%) This language has a strong static type system</li>
<li class="supPos">97 (2%) This language would be good for teaching children to write software</li>
<li>30 (2%) I usually use this language on projects with many other members</li>
<li class="supNeg">21 (2%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>33 (2%) This language is likely to be a passing fad</li>
<li>60 (3%) This language has unusual features that I often miss when using other languages</li>
<li class="supPos">80 (3%) Learning this language significantly changed how I use other languages.</li>
<li>40 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>31 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>53 (3%) This language has a very dogmatic community</li>
<li>40 (3%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">75 (3%) Code written in this language is very readable</li>
<li class="supPos">80 (3%) Learning this language improved my ability as a programmer</li>
<li class="supPos">86 (3%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>32 (3%) This language has many features which feel "tacked on"</li>
<li>42 (3%) This language is well documented</li>
<li>43 (3%) Developers who primarily use this language often burn out after a few years</li>
<li>42 (4%) Programs written in this language tend to be efficient</li>
<li>48 (4%) I still discover new features of this language on a fairly regular basis</li>
<li>55 (4%) The semantics of this language are much different than other languages I know.</li>
<li>35 (4%) I would use this language for writing programs for an embedded hardware platform</li>
<li>37 (4%) This is a mainstream language</li>
<li class="supPos">92 (4%) This language is good for beginners</li>
<li>44 (4%) I learned this language early in my career as a programmer</li>
<li>47 (4%) I enjoy using this language</li>
<li>65 (4%) This language encourages writing code that is easy to maintain.</li>
<li>50 (4%) There are many good open-source tools for this language</li>
<li>25 (4%) This language has a niche outside of which I would not use it</li>
<li class="supPos">83 (4%) I find this language easy to prototype in</li>
<li>52 (4%) I would use this language for a web project</li>
<li>52 (4%) Code written in this language tends to be very reliable</li>
<li>38 (5%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>53 (5%) I regularly use this language</li>
<li class="supNeg">18 (5%) I often get angry when writing code in this language</li>
<li>47 (5%) This language is suitable for real-time applications</li>
<li class="supNeg">14 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>31 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>50 (5%) There are many good commercial tools for this language</li>
<li>46 (5%) This language has a very rigid idea of how things should be done</li>
<li>42 (5%) Libraries in this language tend to be well documented.</li>
<li>52 (5%) I can imagine this will be a popular language in twenty years time</li>
<li>43 (5%) I would list this language on my resume</li>
<li>70 (6%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">20 (6%) This language has a niche in which it is great</li>
<li class="supPos">93 (6%) This language has a very coherent design</li>
<li>68 (6%) This language has a high quality implementation</li>
<li>47 (6%) Programs written in this language will usually work in future versions of the language</li>
<li>48 (6%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>44 (6%) This language matches it's problem domain particularly well.</li>
<li class="supNeg">15 (6%) I am reluctant to admit to knowing this language</li>
<li>41 (7%) I often feel like I am not smart enough to write this language</li>
<li>40 (7%) This language is good for numeric computing</li>
<li>61 (7%) I would use this language for mobile applications</li>
<li class="supNeg">24 (7%) This language has an annoying syntax</li>
<li>74 (7%) I know this language well</li>
<li>71 (8%) This language is expressive</li>
<li class="supPos">81 (8%) This language is very flexible</li>
<li class="supNeg">21 (8%) This language is unusually bad for beginners</li>
<li>57 (8%) There are many good tools for this language</li>
<li>53 (8%) I would use this language for casual scripting</li>
<li>58 (8%) I would use this language for a desktop GUI project</li>
<li class="supPos">87 (8%) This language encourages writing reusable code.</li>
<li>55 (9%) This language is likely to be around for a very long time</li>
</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul>
<li>48 (0%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>31 (0%) This language is suitable for real-time applications</li>
<li>25 (0%) This language excels at concurrency</li>
<li>59 (0%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>56 (0%) Developers who primarily use this language often burn out after a few years</li>
<li>35 (0%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>57 (0%) I enjoy playing with this language but would never use it for "real code"</li>
<li>44 (0%) This language is likely to be a passing fad</li>
<li>54 (0%) This language has a high quality implementation</li>
<li>68 (0%) This language is frequently used for applications it isn't suitable for</li>
<li>72 (1%) This is a high level language</li>
<li>57 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>34 (1%) The semantics of this language are much different than other languages I know.</li>
<li>60 (2%) I often get angry when writing code in this language</li>
<li>65 (2%) This language has a good community</li>
<li>55 (2%) This language is well suited for an agile development approach using short iterations.</li>
<li>67 (2%) I regularly use this language</li>
<li class="supPos">80 (2%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">15 (2%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">10 (2%) This language has a strong static type system</li>
<li>25 (2%) This language is best for very large projects</li>
<li>63 (2%) This language is expressive</li>
<li>62 (2%) There are many good tools for this language</li>
<li>44 (3%) This language is likely to have a strong influence on future languages</li>
<li>37 (3%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">22 (3%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>58 (3%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">24 (3%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">83 (3%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>40 (3%) This language has unusual features that I often miss when using other languages</li>
<li>48 (3%) This language would be good for teaching children to write software</li>
<li>31 (3%) This is a low level language</li>
<li>46 (3%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>26 (3%) I enjoy using this language</li>
<li class="supNeg">19 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>61 (3%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>33 (4%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>42 (4%) This language matches it's problem domain particularly well.</li>
<li>71 (4%) There are many good open-source tools for this language</li>
<li>57 (4%) I use this language out of choice</li>
<li>52 (4%) This language is well documented</li>
<li>37 (4%) Learning this language significantly changed how I use other languages.</li>
<li>26 (4%) This language has a very coherent design</li>
<li>45 (4%) I would like to write more of this language than I currently do</li>
<li class="supPos">80 (4%) I find this language easy to prototype in</li>
<li class="supNeg">18 (4%) Code written in this language tends to be very reliable</li>
<li>47 (4%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">12 (4%) When I write code in this language I can be very sure it is correct</li>
<li>48 (4%) This language has a very dogmatic community</li>
<li class="supNeg">18 (4%) I would use this language for writing embedded programs</li>
<li>63 (4%) Programs written in this language will usually work in future versions of the language</li>
<li>42 (5%) I still discover new features of this language on a fairly regular basis</li>
<li>57 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li>36 (5%) Code written in this language is very readable</li>
<li>56 (6%) Programs written in this language tend to play well with others</li>
<li class="supNeg">21 (6%) This language is good for distributed computing</li>
<li>41 (6%) I would use this language for a desktop GUI project</li>
<li>57 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>33 (6%) It's unusual for me to discover unfamiliar features</li>
<li>73 (6%) I would use this language for a web project</li>
<li>46 (6%) This language encourages writing reusable code.</li>
<li>60 (6%) This language has a niche outside of which I would not use it</li>
<li>34 (7%) This language has a niche in which it is great</li>
<li>50 (7%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>50 (7%) I learned this language early in my career as a programmer</li>
<li>50 (7%) This language excels at symbolic manipulation</li>
<li>30 (8%) I can imagine using this language in my day job</li>
<li>53 (8%) There are many good commercial tools for this language</li>
<li class="supPos">79 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>42 (8%) I find it easy to write efficient code in this language</li>
<li>63 (8%) The resources for learning this language are of high quality</li>
<li>31 (8%) Programs written in this language tend to be efficient</li>
<li class="supPos">87 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">76 (9%) This is a mainstream language</li>
<li class="supNeg">23 (9%) This language is good for numeric computing</li>
<li>36 (9%) I find code written in this language very elegant</li>
<li>51 (9%) Libraries in this language tend to be well documented.</li>
<li>61 (9%) This language is likely to be around for a very long time</li>
<li>72 (9%) I use many applications written in this language</li>
<li class="supPos">84 (9%) I know many other people who use this language</li>
<li>60 (9%) I would list this language on my resume</li>
</ul>
<ul></ul>
<ul>
<li>54 (3%) Code written in this language is very readable</li>
<li class="supNeg">18 (4%) This language is good for distributed computing</li>
<li class="supNeg">18 (5%) This is a low level language</li>
<li>32 (5%) Writing code in this language is a lot of work</li>
<li class="supNeg">7 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li>57 (5%) I would use this language for casual scripting</li>
<li class="supNeg">21 (5%) This language has a strong static type system</li>
<li>54 (5%) This language is unusually bad for beginners</li>
<li class="supNeg">24 (5%) I would use this language for a web project</li>
<li class="supPos">78 (6%) I find this language easy to prototype in</li>
<li>49 (6%) I usually use this language on solo projects</li>
<li class="supPos">87 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li>43 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>42 (6%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">7 (6%) I would use this language for writing server programs</li>
<li class="supNeg">22 (7%) I enjoy using this language</li>
<li class="supPos">82 (7%) This is a high level language</li>
<li>25 (7%) When I write code in this language I can be very sure it is correct</li>
<li>32 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>27 (7%) This language excels at concurrency</li>
<li>36 (7%) I learned this language early in my career as a programmer</li>
<li>52 (8%) This language has many features which feel "tacked on"</li>
<li>40 (8%) This language would be good for teaching children to write software</li>
<li class="supNeg">22 (8%) I can imagine using this language in my day job</li>
<li>33 (8%) This language is likely to have a strong influence on future languages</li>
<li>54 (8%) This language encourages writing reusable code.</li>
<li>29 (8%) I usually use this language on projects with many other members</li>
<li>50 (8%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>35 (8%) I would use this language as a scripting language embedded inside a larger application</li>
<li>36 (8%) I can imagine this will be a popular language in twenty years time</li>
<li>57 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>54 (8%) This language has a good community</li>
<li>55 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li>47 (8%) I would like to write more of this language than I currently do</li>
<li>48 (9%) This language is large</li>
<li>70 (9%) This language has a niche in which it is great</li>
<li>31 (9%) This language is suitable for real-time applications</li>
<li>53 (9%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>59 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">18 (9%) I would use this language for mobile applications</li>
<li>43 (9%) This language has a very dogmatic community</li>
<li>48 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>45 (9%) Developers who primarily use this language often burn out after a few years</li>
</ul>
<ul></ul>
<ul>
<li>33 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>50 (4%) This language is unusually bad for beginners</li>
<li>55 (5%) This language matches it's problem domain particularly well.</li>
<li>36 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li>33 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>36 (7%) This language has a very rigid idea of how things should be done</li>
<li class="supPos">80 (7%) I find it easy to write efficient code in this language</li>
<li class="supNeg">24 (7%) Writing code in this language is a lot of work</li>
<li>35 (7%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>50 (7%) This language excels at text processing</li>
<li>70 (7%) This language has a high quality implementation</li>
<li>38 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>66 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li>36 (8%) This is a mainstream language</li>
<li>36 (8%) I would use this language for writing embedded programs</li>
<li>31 (8%) This language makes it easy to shoot yourself in the foot</li>
<li>36 (8%) I usually use this language on projects with many other members</li>
<li>45 (8%) This language is likely to be around for a very long time</li>
<li>65 (8%) Code written in this language is very readable</li>
<li class="supPos">83 (8%) This is a high level language</li>
<li class="supNeg">18 (8%) There is a lot of accidental complexity when writing code in this language</li>
<li>36 (8%) I use many applications written in this language</li>
<li>49 (8%) This language would be good for teaching children to write software</li>
<li class="supPos">87 (8%) This language encourages writing reusable code.</li>
<li>64 (9%) I would use this language for casual scripting</li>
<li class="supPos">83 (9%) I find this language easy to prototype in</li>
<li>41 (9%) This language is best for very small projects</li>
<li>72 (9%) This language encourages writing code that is easy to maintain.</li>
<li>37 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>44 (9%) I would use this language as a scripting language embedded inside a larger application</li>
<li>49 (9%) Code written in this language tends to be terse</li>
<li>70 (9%) This language has a very coherent design</li>
</ul>
<ul>
<li>59 (1%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">76 (3%) This is a high level language</li>
<li>65 (3%) This language is expressive</li>
<li>32 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>39 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>61 (4%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">21 (4%) When I write code in this language I can be very sure it is correct</li>
<li>43 (4%) This language has many features which feel "tacked on"</li>
<li>31 (4%) This is a low level language</li>
<li>45 (4%) This language is suitable for real-time applications</li>
<li>37 (4%) Developers who primarily use this language often burn out after a few years</li>
<li>33 (4%) There are many good tools for this language</li>
<li>53 (5%) I would like to write more of this language than I currently do</li>
<li>45 (5%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>35 (5%) This language is good for scientific computing</li>
<li class="supPos">78 (5%) This language encourages writing reusable code.</li>
<li>29 (5%) There are many good open-source tools for this language</li>
<li>40 (6%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>29 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>56 (6%) This language excels at symbolic manipulation</li>
<li>33 (6%) Libraries in this language tend to be well documented.</li>
<li>26 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>47 (6%) Programs written in this language will usually work in future versions of the language</li>
<li>47 (6%) I would use this language for a desktop GUI project</li>
<li>42 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>26 (6%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>49 (7%) This language has a niche outside of which I would not use it</li>
<li>43 (7%) This language excels at text processing</li>
<li>54 (7%) This language has unusual features that I often miss when using other languages</li>
<li>74 (7%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>66 (7%) I use this language out of choice</li>
<li>71 (7%) I find this language easy to prototype in</li>
<li>47 (7%) Learning this language significantly changed how I use other languages.</li>
<li>43 (7%) The resources for learning this language are of high quality</li>
<li>72 (7%) This language is very flexible</li>
<li class="supNeg">23 (7%) This language has a strong static type system</li>
<li>38 (8%) This language is good for numeric computing</li>
<li>62 (8%) I find code written in this language very elegant</li>
<li>36 (8%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supPos">75 (8%) This language has a very coherent design</li>
<li>30 (8%) There are many good commercial tools for this language</li>
<li>32 (9%) This language has a very dogmatic community</li>
<li>45 (9%) I would use this language for writing embedded programs</li>
<li>44 (9%) I would use this language for a web project</li>
<li class="supNeg">23 (9%) This language has a very rigid idea of how things should be done</li>
<li>44 (9%) I still discover new features of this language on a fairly regular basis</li>
<li>46 (9%) I usually use this language on solo projects</li>
</ul>
<ul>
<li class="supNeg">19 (0%) I would use this language for writing embedded programs</li>
<li>30 (0%) The semantics of this language are much different than other languages I know.</li>
<li>29 (0%) This language has a very rigid idea of how things should be done</li>
<li>63 (0%) Programs written in this language tend to play well with others</li>
<li>49 (0%) I find it easy to write efficient code in this language</li>
<li>31 (0%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">23 (0%) This is a low level language</li>
<li>37 (0%) Code written in this language tends to be verbose</li>
<li>59 (0%) I would use this language for mobile applications</li>
<li>49 (0%) Developers who primarily use this language often burn out after a few years</li>
<li>35 (1%) This language matches it's problem domain particularly well.</li>
<li>61 (1%) There are many good commercial tools for this language</li>
<li class="supNeg">22 (1%) I often feel like I am not smart enough to write this language</li>
<li>39 (1%) Code written in this language tends to be very reliable</li>
<li>34 (1%) This language is good for numeric computing</li>
<li>43 (1%) I enjoy using this language</li>
<li>54 (2%) This language has a high quality implementation</li>
<li>39 (2%) I am reluctant to admit to knowing this language</li>
<li>37 (2%) This language is good for distributed computing</li>
<li>36 (2%) This language is good for scientific computing</li>
<li>52 (2%) I would like to write more of this language than I currently do</li>
<li class="supPos">95 (2%) I find this language easy to prototype in</li>
<li>71 (2%) I know this language well</li>
<li>68 (2%) This language has many features which feel "tacked on"</li>
<li class="supNeg">20 (2%) I learned this language early in my career as a programmer</li>
<li>67 (2%) It is easy to tell at a glance what code in this language does</li>
<li>30 (3%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>69 (3%) This language encourages writing code that is easy to maintain.</li>
<li>58 (3%) I usually use this language on solo projects</li>
<li>33 (3%) This language is minimal</li>
<li>47 (3%) Code written in this language tends to be terse</li>
<li class="supPos">83 (4%) This is a high level language</li>
<li>37 (4%) This language is suitable for real-time applications</li>
<li class="supNeg">17 (4%) I would use this language for writing programs for an embedded hardware platform</li>
<li>67 (4%) Code written in this language is very readable</li>
<li>61 (4%) I usually use this language on projects with many other members</li>
<li>26 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>65 (4%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>52 (4%) This language excels at symbolic manipulation</li>
<li>45 (4%) This language has unusual features that I often miss when using other languages</li>
<li>66 (4%) I would use this language for a desktop GUI project</li>
<li>58 (4%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>66 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li>51 (4%) There are many good tools for this language</li>
<li class="supPos">80 (4%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">23 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">21 (5%) When I write code in this language I can be very sure it is correct</li>
<li>62 (5%) I find code written in this language very elegant</li>
<li>50 (5%) This language is large</li>
<li>35 (5%) This language is likely to be around for a very long time</li>
<li>72 (5%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>30 (5%) This language has an annoying syntax</li>
<li>66 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li>66 (5%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>52 (5%) I would use this language for writing server programs</li>
<li>47 (5%) This language makes it easy to shoot yourself in the foot</li>
<li>61 (5%) I still discover new features of this language on a fairly regular basis</li>
<li>32 (5%) This language has a niche outside of which I would not use it</li>
<li class="supPos">82 (6%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>42 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>47 (6%) I regularly use this language</li>
<li>53 (6%) I can imagine this will be a popular language in twenty years time</li>
<li class="supPos">81 (6%) I would use this language for casual scripting</li>
<li>51 (6%) This language is best for very large projects</li>
<li class="supPos">77 (6%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>60 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>72 (7%) This language has a good community</li>
<li>31 (7%) It's unusual for me to discover unfamiliar features</li>
<li>49 (7%) I can imagine using this language in my day job</li>
<li>43 (7%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>26 (7%) This language excels at concurrency</li>
<li>47 (7%) This language has a very coherent design</li>
<li class="supNeg">23 (7%) This language has a niche in which it is great</li>
<li>67 (7%) There are many good open-source tools for this language</li>
<li>46 (8%) Learning this language significantly changed how I use other languages.</li>
<li>49 (9%) It is easy to debug programs written in this language when it goes wrong</li>
<li>50 (9%) I often get angry when writing code in this language</li>
<li class="supNeg">20 (9%) This language has a strong static type system</li>
<li class="supPos">88 (9%) I would use this language to write a command-line app</li>
</ul>
<ul></ul>
<ul>
<li>55 (0%) I use this language out of choice</li>
<li class="supNeg">17 (1%) I know many other people who use this language</li>
<li>64 (1%) This language is unusually bad for beginners</li>
<li class="supNeg">23 (1%) I usually use this language on solo projects</li>
<li class="supNeg">20 (1%) I use many applications written in this language</li>
<li>33 (1%) This language has many features which feel "tacked on"</li>
<li class="supNeg">17 (1%) This language is good for distributed computing</li>
<li>27 (2%) This language is good for beginners</li>
<li>45 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">22 (2%) This language excels at concurrency</li>
<li class="supNeg">9 (2%) It is easy to tell at a glance what code in this language does</li>
<li>46 (2%) It's unusual for me to discover unfamiliar features</li>
<li>38 (3%) Code written in this language is very readable</li>
<li class="supNeg">2 (3%) I can imagine using this language in my day job</li>
<li class="supNeg">4 (3%) I can imagine this will be a popular language in twenty years time</li>
<li>51 (3%) I often get angry when writing code in this language</li>
<li>37 (3%) There are many good commercial tools for this language</li>
<li>28 (3%) I would use this language for a web project</li>
<li class="supNeg">16 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>70 (3%) This language has a very coherent design</li>
<li>37 (4%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">15 (4%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supNeg">19 (4%) This language is best for very large projects</li>
<li>36 (4%) Code written in this language tends to be very reliable</li>
<li>55 (4%) This language has a niche in which it is great</li>
<li>34 (4%) This language is frequently used for applications it isn't suitable for</li>
<li class="supNeg">20 (5%) There is a wide variety of open source code written in this language</li>
<li>36 (5%) This language has a good community</li>
<li>42 (5%) This language has a very dogmatic community</li>
<li>43 (5%) This language encourages writing code that is easy to maintain.</li>
<li>42 (5%) This language is likely to have a strong influence on future languages</li>
<li>56 (5%) Developers who primarily use this language often burn out after a few years</li>
<li>27 (5%) I would use this language to write a command-line app</li>
<li>31 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>47 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li>45 (5%) This language has unusual features that I often miss when using other languages</li>
<li>59 (5%) This language is expressive</li>
<li class="supPos">79 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">23 (6%) I would use this language for a desktop GUI project</li>
<li>54 (6%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">19 (6%) This is a mainstream language</li>
<li class="supNeg">19 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>34 (6%) I regularly use this language</li>
<li>65 (6%) This language is built on a small core of orthogonal features</li>
<li>44 (6%) The resources for learning this language are of high quality</li>
<li>67 (6%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">21 (7%) There are many good open-source tools for this language</li>
<li class="supNeg">19 (7%) I still discover new features of this language on a fairly regular basis</li>
<li>60 (7%) I find code written in this language very elegant</li>
<li>44 (7%) I would use this language for casual scripting</li>
<li>27 (7%) There are many good tools for this language</li>
<li>30 (7%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">7 (7%) Libraries in this language tend to be well documented.</li>
<li>27 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>37 (7%) I enjoy using this language</li>
<li>39 (7%) This language is well documented</li>
<li class="supNeg">15 (8%) Code written in this language tends to be verbose</li>
<li>37 (8%) Writing code in this language is a lot of work</li>
<li>46 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>40 (8%) This language is likely to be around for a very long time</li>
<li>46 (8%) I would like to write more of this language than I currently do</li>
<li>45 (8%) This language has a very rigid idea of how things should be done</li>
<li>37 (8%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>47 (9%) This language encourages writing reusable code.</li>
<li class="supNeg">18 (9%) Programs written in this language tend to play well with others</li>
<li>27 (9%) This language has a good library distribution mechanism.</li>
<li class="supNeg">16 (9%) This language excels at text processing</li>
<li>48 (9%) I know this language well</li>
<li>65 (9%) I often feel like I am not smart enough to write this language</li>
<li>67 (9%) Learning this language improved my ability as a programmer</li>
<li>51 (9%) This language excels at symbolic manipulation</li>
<li>31 (9%) I would use this language for mobile applications</li>
<li>34 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
</ul>
<ul>
<li class="supNeg">20 (1%) I would use this language for writing programs for an embedded hardware platform</li>
<li>37 (1%) I would use this language for writing embedded programs</li>
<li class="supPos">95 (3%) Learning this language improved my ability as a programmer</li>
<li class="supPos">80 (3%) This language has a very coherent design</li>
<li>71 (3%) The semantics of this language are much different than other languages I know.</li>
<li>40 (3%) This language is well documented</li>
<li class="supPos">95 (3%) This language has a strong static type system</li>
<li class="supPos">85 (3%) I use this language out of choice</li>
<li>55 (4%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">94 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supPos">93 (4%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">24 (5%) I can imagine using this language in my day job</li>
<li class="supPos">93 (6%) This is a high level language</li>
<li>25 (6%) This language excels at concurrency</li>
<li>57 (6%) Code written in this language is very readable</li>
<li class="supNeg">9 (6%) This is a low level language</li>
<li class="supNeg">19 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">11 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>67 (8%) This language excels at symbolic manipulation</li>
<li>62 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supPos">87 (8%) This language is expressive</li>
<li>59 (8%) I enjoy using this language</li>
<li class="supPos">88 (8%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>28 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>39 (9%) This language is large</li>
<li>38 (9%) I would use this language for mobile applications</li>
<li class="supPos">86 (9%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">90 (9%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">13 (9%) I often get angry when writing code in this language</li>
</ul>
<ul>
<li>32 (0%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>25 (1%) There are many good open-source tools for this language</li>
<li>41 (2%) Learning this language significantly changed how I use other languages.</li>
<li>41 (2%) This language excels at concurrency</li>
<li>56 (2%) This language is expressive</li>
<li>29 (2%) There is a wide variety of open source code written in this language</li>
<li>54 (2%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>66 (2%) This language has a strong static type system</li>
<li>60 (2%) This language is good for numeric computing</li>
<li>41 (3%) There are many good commercial tools for this language</li>
<li class="supNeg">22 (3%) I know many other people who use this language</li>
<li>47 (3%) I would list this language on my resume</li>
<li>45 (3%) I know this language well</li>
<li>35 (3%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>36 (3%) I would use this language for a web project</li>
<li>25 (3%) I regularly use this language</li>
<li>48 (3%) I would use this language for writing server programs</li>
<li>42 (4%) This language excels at symbolic manipulation</li>
<li>42 (4%) This language is very flexible</li>
<li>54 (4%) This language is good for scientific computing</li>
<li>27 (4%) The semantics of this language are much different than other languages I know.</li>
<li>33 (4%) I enjoy using this language</li>
<li class="supNeg">24 (4%) Code written in this language tends to be terse</li>
<li>44 (4%) This language has a good library distribution mechanism.</li>
<li>44 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>63 (5%) This is a high level language</li>
<li>73 (5%) This language is best for very large projects</li>
<li>32 (5%) I can imagine using this language in my day job</li>
<li>46 (5%) This language would be good for teaching children to write software</li>
<li>34 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>44 (5%) There are many good tools for this language</li>
<li>62 (5%) It is easy to tell at a glance what code in this language does</li>
<li>30 (5%) This language is good for beginners</li>
<li class="supPos">85 (5%) This language encourages writing reusable code.</li>
<li class="supNeg">21 (6%) I would use this language as a scripting language embedded inside a larger application</li>
<li>60 (6%) I use this language out of choice</li>
<li>44 (6%) This language has an annoying syntax</li>
<li>35 (6%) This is a mainstream language</li>
<li>44 (6%) This language has unusual features that I often miss when using other languages</li>
<li>45 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>40 (6%) I usually use this language on projects with many other members</li>
<li>57 (6%) Programs written in this language tend to play well with others</li>
<li>31 (6%) I use many applications written in this language</li>
<li>57 (7%) This language has a very dogmatic community</li>
<li>32 (7%) This language is good for distributed computing</li>
<li>35 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">85 (7%) This language encourages writing code that is easy to maintain.</li>
<li>27 (7%) This language is likely to be around for a very long time</li>
<li>26 (7%) This language is minimal</li>
<li>36 (7%) I would use this language for casual scripting</li>
<li>33 (7%) I am reluctant to admit to knowing this language</li>
<li>35 (8%) This language excels at text processing</li>
<li>65 (8%) Code written in this language is very readable</li>
<li>57 (8%) I would like to write more of this language than I currently do</li>
<li class="supPos">78 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>49 (8%) I find code written in this language very elegant</li>
<li>26 (8%) I often feel like I am not smart enough to write this language</li>
<li>58 (8%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>40 (8%) Libraries in this language tend to be well documented.</li>
<li>40 (8%) Programs written in this language will usually work in future versions of the language</li>
<li>36 (8%) This language has a niche outside of which I would not use it</li>
<li>45 (8%) This is a low level language</li>
<li>49 (9%) This language is likely to have a strong influence on future languages</li>
<li>60 (9%) This language is large</li>
<li>52 (9%) When I write code in this language I can be very sure it is correct</li>
<li>45 (9%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>44 (9%) I would use this language for mobile applications</li>
<li>64 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>58 (9%) I would use this language to write a command-line app</li>
<li>55 (9%) This language has many features which feel "tacked on"</li>
</ul>
<ul></ul>
</div>
k-means with k = 23
<tabled class="data" id="clusters23">
  <trd>
    <tdd>Fortran,5.0</tdd>
    <tdd>Cobol,5.0</tdd>
  </trd>
  <trd>
    <tdd>AWK,0.0</tdd>
  </trd>
  <trd>
    <tdd>Eiffel,5.0</tdd>
    <tdd>Ada,6.0</tdd>
    <tdd>Standard ML,6.0</tdd>
  </trd>
  <trd>
    <tdd>R,4.0</tdd>
    <tdd>Matlab,5.0</tdd>
    <tdd>Mathematica,5.0</tdd>
    <tdd>ELisp,6.0</tdd>
  </trd>
  <trd>
    <tdd>Agda,0.0</tdd>
  </trd>
  <trd>
    <tdd>Common Lisp,5.0</tdd>
    <tdd>Scheme,6.0</tdd>
    <tdd>Smalltalk,6.0</tdd>
    <tdd>Haskell,8.0</tdd>
  </trd>
  <trd>
    <tdd>Shell,0.0</tdd>
  </trd>
  <trd>
    <tdd>Prolog,5.0</tdd>
    <tdd>APL,6.0</tdd>
    <tdd>Coq,8.0</tdd>
  </trd>
  <trd>
    <tdd>REBOL,0.0</tdd>
  </trd>
  <trd>
    <tdd>Visual Basic,5.0</tdd>
    <tdd>Delphi,5.0</tdd>
    <tdd>Pascal,6.0</tdd>
    <tdd>PHP,7.0</tdd>
  </trd>
  <trd>
    <tdd>Assembler,0.0</tdd>
  </trd>
  <trd>
    <tdd>TCL,6.0</tdd>
    <tdd>ActionScript,6.0</tdd>
  </trd>
  <trd>
    <tdd>C,6.0</tdd>
    <tdd>C++,6.0</tdd>
  </trd>
  <trd>
    <tdd>J,0.0</tdd>
  </trd>
  <trd>
    <tdd>D,4.0</tdd>
    <tdd>Go,4.0</tdd>
    <tdd>O'Caml,6.0</tdd>
    <tdd>Objective C,7.0</tdd>
  </trd>
  <trd>
    <tdd>Forth,0.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,4.0</tdd>
    <tdd>Io,4.0</tdd>
  </trd>
  <trd>
    <tdd>Javascript,6.0</tdd>
    <tdd>Perl,7.0</tdd>
    <tdd>Java,9.0</tdd>
  </trd>
  <trd>
    <tdd>Erlang,5.0</tdd>
    <tdd>Mozart-Oz,5.0</tdd>
  </trd>
  <trd>
    <tdd>Groovy,5.0</tdd>
    <tdd>Haxe,5.0</tdd>
    <tdd>Lua,6.0</tdd>
    <tdd>F#,7.0</tdd>
  </trd>
  <trd>
    <tdd>Clojure,5.0</tdd>
    <tdd>Scala,6.0</tdd>
    <tdd>Ruby,7.0</tdd>
  </trd>
  <trd>
    <tdd>C#,5.0</tdd>
    <tdd>Python,5.0</tdd>
  </trd>
</tabled>
<div class="support" id="support23">
<ul>
<li class="supNeg">8 (0%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">21 (0%) Libraries in this language tend to be well documented.</li>
<li class="supPos">76 (0%) This language is unusually bad for beginners</li>
<li>30 (0%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">16 (0%) Learning this language significantly changed how I use other languages.</li>
<li>44 (0%) This language has a very coherent design</li>
<li>48 (0%) This language makes it easy to shoot yourself in the foot</li>
<li>36 (0%) The resources for learning this language are of high quality</li>
<li>42 (0%) This language has a strong static type system</li>
<li class="supPos">80 (0%) I learned this language early in my career as a programmer</li>
<li>68 (0%) This language is likely to be around for a very long time</li>
<li class="supNeg">8 (1%) I can imagine using this language in my day job</li>
<li>29 (1%) I know many other people who use this language</li>
<li class="supNeg">12 (1%) This language is likely to have a strong influence on future languages</li>
<li>73 (1%) I often get angry when writing code in this language</li>
<li class="supNeg">15 (1%) I can imagine this will be a popular language in twenty years time</li>
<li>58 (1%) This language has many features which feel "tacked on"</li>
<li class="supNeg">11 (2%) This language is expressive</li>
<li>35 (2%) This language is best for very large projects</li>
<li>53 (2%) There are many good commercial tools for this language</li>
<li class="supNeg">12 (2%) This language excels at symbolic manipulation</li>
<li>35 (2%) There are many good tools for this language</li>
<li>30 (2%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">13 (2%) I still discover new features of this language on a fairly regular basis</li>
<li>37 (2%) This language has a very dogmatic community</li>
<li>30 (2%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>41 (2%) This language encourages writing code that is easy to maintain.</li>
<li>70 (2%) Programs written in this language will usually work in future versions of the language</li>
<li>61 (2%) Writing code in this language is a lot of work</li>
<li>40 (3%) This language matches it's problem domain particularly well.</li>
<li class="supNeg">3 (3%) I enjoy using this language</li>
<li class="supNeg">5 (3%) I regularly use this language</li>
<li class="supNeg">15 (3%) I would use this language for a desktop GUI project</li>
<li>28 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">14 (3%) This language would be good for teaching children to write software</li>
<li>50 (3%) It is easy to tell at a glance what code in this language does</li>
<li>52 (3%) This language is frequently used for applications it isn't suitable for</li>
<li>66 (3%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>48 (4%) This is a high level language</li>
<li class="supNeg">7 (4%) This language excels at text processing</li>
<li>31 (4%) I find this language easy to prototype in</li>
<li>29 (4%) I use many applications written in this language</li>
<li>44 (4%) This is a mainstream language</li>
<li class="supNeg">4 (4%) I would use this language for mobile applications</li>
<li>66 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">10 (5%) I would use this language for writing server programs</li>
<li>52 (6%) Code written in this language is very readable</li>
<li>37 (6%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">6 (6%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">19 (6%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>31 (6%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">19 (6%) This language is likely to be a passing fad</li>
<li>31 (6%) I would list this language on my resume</li>
<li class="supNeg">23 (6%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">13 (6%) When I write code in this language I can be very sure it is correct</li>
<li>53 (6%) This language has a high quality implementation</li>
<li class="supNeg">12 (7%) This language is very flexible</li>
<li class="supNeg">20 (7%) I would use this language for casual scripting</li>
<li>36 (7%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">7 (7%) I usually use this language on solo projects</li>
<li>51 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">24 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">7 (7%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">8 (8%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>72 (8%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">8 (8%) This language is best for very small projects</li>
<li>36 (8%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">20 (8%) I usually use this language on projects with many other members</li>
<li class="supNeg">13 (8%) This language is built on a small core of orthogonal features</li>
<li>40 (8%) This language is suitable for real-time applications</li>
<li>45 (8%) This is a low level language</li>
<li class="supNeg">23 (8%) This language has a niche in which it is great</li>
<li class="supPos">80 (8%) This language has a niche outside of which I would not use it</li>
<li class="supNeg">16 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">21 (9%) It is easy to debug programs written in this language when it goes wrong</li>
<li>57 (9%) I know this language well</li>
<li class="supNeg">24 (9%) This language encourages writing reusable code.</li>
<li>30 (9%) This language has a good library distribution mechanism.</li>
</ul>
<ul></ul>
<ul>
<li>33 (1%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">23 (1%) I still discover new features of this language on a fairly regular basis</li>
<li>26 (1%) There is a wide variety of open source code written in this language</li>
<li>41 (2%) Learning this language significantly changed how I use other languages.</li>
<li>32 (2%) I would use this language for a web project</li>
<li class="supNeg">23 (2%) I can imagine this will be a popular language in twenty years time</li>
<li>44 (2%) I would list this language on my resume</li>
<li>60 (2%) This language is good for numeric computing</li>
<li class="supNeg">22 (3%) I know many other people who use this language</li>
<li class="supNeg">22 (3%) This language makes it easy to shoot yourself in the foot</li>
<li>43 (3%) I would use this language for writing server programs</li>
<li>65 (4%) This language is well documented</li>
<li>28 (4%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>27 (4%) I can imagine using this language in my day job</li>
<li>32 (4%) This language is likely to be around for a very long time</li>
<li>53 (4%) I would like to write more of this language than I currently do</li>
<li>36 (5%) This language excels at concurrency</li>
<li>54 (5%) I learned this language early in my career as a programmer</li>
<li>33 (5%) This language excels at text processing</li>
<li>46 (5%) This language is very flexible</li>
<li>47 (5%) I would use this language to write a command-line app</li>
<li>48 (5%) This language would be good for teaching children to write software</li>
<li>39 (5%) There are many good commercial tools for this language</li>
<li>28 (5%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>30 (6%) This language is good for distributed computing</li>
<li>56 (6%) This language is good for scientific computing</li>
<li>71 (6%) This is a high level language</li>
<li>61 (6%) This language has a very dogmatic community</li>
<li>38 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supPos">84 (6%) This language encourages writing reusable code.</li>
<li>52 (6%) Programs written in this language tend to be efficient</li>
<li>30 (6%) There are many good open-source tools for this language</li>
<li>40 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>74 (6%) Learning this language improved my ability as a programmer</li>
<li>65 (6%) It is easy to tell at a glance what code in this language does</li>
<li>67 (7%) I find it easy to write efficient code in this language</li>
<li>44 (7%) This language has an annoying syntax</li>
<li>32 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">22 (7%) This language has a niche in which it is great</li>
<li>41 (7%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>57 (7%) When I write code in this language I can be very sure it is correct</li>
<li>66 (7%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">19 (7%) I regularly use this language</li>
<li>30 (7%) I use many applications written in this language</li>
<li>39 (7%) This language has a niche outside of which I would not use it</li>
<li>46 (7%) Programs written in this language tend to play well with others</li>
<li>66 (7%) Code written in this language is very readable</li>
<li>72 (8%) Code written in this language tends to be very reliable</li>
<li>36 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>33 (8%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">13 (8%) This language is best for very small projects</li>
<li>36 (8%) I would use this language for casual scripting</li>
<li>34 (8%) I would use this language for a desktop GUI project</li>
<li>62 (8%) I use this language out of choice</li>
<li>63 (8%) The resources for learning this language are of high quality</li>
<li>55 (8%) I find this language easy to prototype in</li>
<li>39 (8%) I usually use this language on projects with many other members</li>
<li>60 (8%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>41 (8%) This language matches it's problem domain particularly well.</li>
<li>70 (9%) This language is best for very large projects</li>
<li>43 (9%) Writing code in this language is a lot of work</li>
<li>42 (9%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>37 (9%) The semantics of this language are much different than other languages I know.</li>
</ul>
<ul>
<li>40 (0%) There is a lot of accidental complexity when writing code in this language</li>
<li>42 (1%) Code written in this language tends to be terse</li>
<li>40 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>53 (1%) Code written in this language is very readable</li>
<li>52 (3%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>50 (3%) The semantics of this language are much different than other languages I know.</li>
<li>39 (3%) I am reluctant to admit to knowing this language</li>
<li>33 (3%) This language has unusual features that I often miss when using other languages</li>
<li>43 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>30 (3%) Writing code in this language is a lot of work</li>
<li class="supNeg">18 (3%) This language has a strong static type system</li>
<li>45 (3%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">89 (3%) This language has a niche outside of which I would not use it</li>
<li class="supNeg">24 (4%) This language excels at concurrency</li>
<li>52 (4%) This language is unusually bad for beginners</li>
<li class="supNeg">17 (4%) This language is good for distributed computing</li>
<li class="supNeg">19 (4%) This is a low level language</li>
<li>27 (4%) This language is suitable for real-time applications</li>
<li class="supNeg">4 (4%) I would use this language for writing server programs</li>
<li>48 (4%) There are many good tools for this language</li>
<li>29 (5%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>42 (5%) Code written in this language tends to be verbose</li>
<li>55 (5%) This language has many features which feel "tacked on"</li>
<li class="supNeg">18 (5%) This language is best for very large projects</li>
<li>56 (5%) I would use this language for casual scripting</li>
<li>40 (5%) This language has a very coherent design</li>
<li>50 (6%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">7 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>25 (6%) I would use this language for a web project</li>
<li>36 (6%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">22 (6%) When I write code in this language I can be very sure it is correct</li>
<li>47 (6%) This language has a very dogmatic community</li>
<li>25 (6%) I can imagine using this language in my day job</li>
<li class="supPos">86 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li>48 (6%) I usually use this language on solo projects</li>
<li class="supPos">77 (6%) I find this language easy to prototype in</li>
<li>39 (6%) I find code written in this language very elegant</li>
<li>48 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>60 (6%) This language has a high quality implementation</li>
<li>56 (7%) Libraries in this language tend to be well documented.</li>
<li>32 (7%) I usually use this language on projects with many other members</li>
<li>51 (7%) This language encourages writing reusable code.</li>
<li>27 (7%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">15 (7%) I would use this language for mobile applications</li>
<li class="supPos">83 (7%) This is a high level language</li>
<li>33 (7%) I can imagine this will be a popular language in twenty years time</li>
<li>38 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">12 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>34 (7%) Code written in this language tends to be very reliable</li>
<li>25 (7%) I would use this language for a desktop GUI project</li>
<li class="supNeg">21 (7%) I enjoy using this language</li>
<li>41 (8%) This is a mainstream language</li>
<li>38 (8%) This language would be good for teaching children to write software</li>
<li>37 (8%) I learned this language early in my career as a programmer</li>
<li>47 (8%) I find it easy to write efficient code in this language</li>
<li>30 (8%) Learning this language improved my ability as a programmer</li>
<li>45 (8%) I would like to write more of this language than I currently do</li>
<li>58 (8%) I use this language out of choice</li>
<li class="supNeg">23 (8%) I would use this language to write a command-line app</li>
<li>48 (9%) This language encourages writing code that is easy to maintain.</li>
<li>32 (9%) This language is likely to have a strong influence on future languages</li>
<li>50 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>47 (9%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>46 (9%) This language is large</li>
<li>55 (9%) This language has a good community</li>
<li>55 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li>51 (9%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
</ul>
<ul></ul>
<ul>
<li>31 (2%) This language excels at concurrency</li>
<li>37 (2%) I use many applications written in this language</li>
<li>47 (2%) This language excels at text processing</li>
<li class="supNeg">21 (3%) This is a low level language</li>
<li>44 (3%) There is a wide variety of open source code written in this language</li>
<li>29 (4%) I usually use this language on projects with many other members</li>
<li>36 (4%) This is a mainstream language</li>
<li>46 (4%) Programs written in this language tend to be efficient</li>
<li>33 (4%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">19 (4%) Writing code in this language is a lot of work</li>
<li class="supPos">86 (4%) I find this language easy to prototype in</li>
<li>40 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>50 (5%) This language is suitable for real-time applications</li>
<li>25 (5%) This language has a niche outside of which I would not use it</li>
<li>38 (5%) I know many other people who use this language</li>
<li>30 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>32 (5%) This language is likely to be a passing fad</li>
<li class="supNeg">22 (5%) I can imagine using this language in my day job</li>
<li>70 (5%) Code written in this language is very readable</li>
<li>48 (6%) There are many good commercial tools for this language</li>
<li class="supPos">89 (6%) This is a high level language</li>
<li>32 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">23 (6%) I often get angry when writing code in this language</li>
<li>56 (6%) This language is likely to be around for a very long time</li>
<li>49 (6%) I regularly use this language</li>
<li class="supPos">86 (6%) Learning this language improved my ability as a programmer</li>
<li>55 (7%) There are many good tools for this language</li>
<li>26 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supPos">88 (7%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>53 (7%) I would use this language for a desktop GUI project</li>
<li>59 (7%) I would use this language for a web project</li>
<li class="supNeg">15 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>41 (8%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>38 (8%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>35 (8%) This language is good for distributed computing</li>
<li>54 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>58 (8%) I would use this language for casual scripting</li>
<li>51 (8%) This language matches it's problem domain particularly well.</li>
<li>34 (8%) I would use this language for writing embedded programs</li>
<li>38 (8%) This language has many features which feel "tacked on"</li>
<li>71 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">77 (9%) I would like to write more of this language than I currently do</li>
<li class="supNeg">7 (9%) I am reluctant to admit to knowing this language</li>
<li class="supPos">89 (9%) This language encourages writing reusable code.</li>
<li>73 (9%) This language is likely to have a strong influence on future languages</li>
<li>61 (9%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">78 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>51 (9%) There are many good open-source tools for this language</li>
<li>43 (9%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>38 (9%) I learned this language early in my career as a programmer</li>
<li>29 (9%) This language has an annoying syntax</li>
<li>36 (9%) This language is well documented</li>
</ul>
<ul></ul>
<ul>
<li class="supNeg">20 (1%) This language excels at concurrency</li>
<li class="supNeg">16 (1%) I know many other people who use this language</li>
<li class="supPos">88 (1%) This language has a niche outside of which I would not use it</li>
<li>33 (1%) There are many good commercial tools for this language</li>
<li>25 (1%) I would use this language for mobile applications</li>
<li class="supNeg">15 (2%) This language is good for distributed computing</li>
<li>34 (2%) This language has many features which feel "tacked on"</li>
<li class="supNeg">17 (3%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>45 (3%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">15 (4%) Programs written in this language tend to play well with others</li>
<li>29 (4%) I regularly use this language</li>
<li class="supNeg">14 (4%) This is a low level language</li>
<li>44 (4%) This language is well documented</li>
<li class="supNeg">12 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supNeg">18 (5%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">20 (5%) This language is best for very large projects</li>
<li>67 (5%) This language is unusually bad for beginners</li>
<li class="supNeg">12 (5%) It is easy to tell at a glance what code in this language does</li>
<li>67 (5%) I find code written in this language very elegant</li>
<li>67 (5%) This language is expressive</li>
<li>26 (5%) This language is very flexible</li>
<li>66 (6%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>25 (6%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">23 (6%) I would use this language for a desktop GUI project</li>
<li>33 (6%) This language is best for very small projects</li>
<li class="supNeg">14 (6%) I use many applications written in this language</li>
<li>26 (6%) This language is suitable for real-time applications</li>
<li class="supNeg">20 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>29 (7%) There are many good open-source tools for this language</li>
<li>26 (7%) There are many good tools for this language</li>
<li>44 (7%) Code written in this language is very readable</li>
<li>43 (7%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>57 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">21 (8%) This language is good for beginners</li>
<li>43 (8%) This language has a good community</li>
<li>50 (8%) This language has a very dogmatic community</li>
<li>46 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>74 (8%) This language has a very coherent design</li>
<li>58 (8%) This language excels at symbolic manipulation</li>
<li>34 (8%) This language is large</li>
<li>57 (8%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">6 (8%) I can imagine using this language in my day job</li>
<li>68 (8%) This language is built on a small core of orthogonal features</li>
<li class="supNeg">21 (8%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">21 (9%) I would use this language for a web project</li>
<li>61 (9%) This language is good for scientific computing</li>
<li>30 (9%) This language is likely to be around for a very long time</li>
<li>28 (9%) This language has a good library distribution mechanism.</li>
<li class="supNeg">24 (9%) This language is frequently used for applications it isn't suitable for</li>
<li>42 (9%) The resources for learning this language are of high quality</li>
<li>47 (9%) This language is minimal</li>
<li class="supNeg">9 (9%) This language excels at text processing</li>
<li>66 (9%) I find this language easy to prototype in</li>
</ul>
<ul></ul>
<ul>
<li>35 (1%) Writing code in this language is a lot of work</li>
<li>55 (1%) Code written in this language is very readable</li>
<li>69 (2%) This language has an annoying syntax</li>
<li>44 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">2 (2%) I still discover new features of this language on a fairly regular basis</li>
<li>32 (2%) I would use this language for mobile applications</li>
<li>63 (2%) I find this language easy to prototype in</li>
<li>57 (3%) It's unusual for me to discover unfamiliar features</li>
<li class="supNeg">11 (3%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">21 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li>52 (4%) This language is good for beginners</li>
<li class="supNeg">7 (4%) This language has unusual features that I often miss when using other languages</li>
<li>32 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">24 (4%) This language excels at symbolic manipulation</li>
<li class="supNeg">15 (4%) This language is good for distributed computing</li>
<li class="supNeg">15 (5%) The semantics of this language are much different than other languages I know.</li>
<li>58 (5%) I know this language well</li>
<li>38 (5%) This language has a high quality implementation</li>
<li>51 (5%) Libraries in this language tend to be well documented.</li>
<li>30 (6%) This language is expressive</li>
<li>37 (6%) This language is likely to be around for a very long time</li>
<li class="supNeg">24 (6%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>36 (6%) This language has a very dogmatic community</li>
<li>61 (6%) This is a high level language</li>
<li class="supNeg">12 (6%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">9 (7%) I enjoy using this language</li>
<li class="supNeg">22 (7%) Code written in this language tends to be terse</li>
<li>47 (7%) There are many good tools for this language</li>
<li>47 (7%) This language is large</li>
<li>41 (7%) This is a low level language</li>
<li>30 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>51 (7%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">12 (7%) I can imagine using this language in my day job</li>
<li>45 (8%) This language has a good library distribution mechanism.</li>
<li class="supNeg">23 (8%) This language is likely to have a strong influence on future languages</li>
<li>40 (8%) I would use this language to write a command-line app</li>
<li>43 (8%) This language encourages writing reusable code.</li>
<li>37 (8%) This language is best for very large projects</li>
<li>66 (8%) Code written in this language tends to be verbose</li>
<li class="supNeg">23 (8%) This language excels at concurrency</li>
<li>53 (8%) It is easy to tell at a glance what code in this language does</li>
<li>49 (8%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">11 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>52 (8%) This language makes it easy to shoot yourself in the foot</li>
<li>39 (8%) I use this language out of choice</li>
<li>49 (9%) This language is unusually bad for beginners</li>
<li>39 (9%) Programs written in this language tend to play well with others</li>
<li>53 (9%) The resources for learning this language are of high quality</li>
<li class="supNeg">17 (9%) When I write code in this language I can be very sure it is correct</li>
</ul>
<ul></ul>
<ul>
<li class="supNeg">23 (0%) This language is likely to have a strong influence on future languages</li>
<li>54 (0%) Code written in this language is very readable</li>
<li class="supNeg">21 (0%) I usually use this language on projects with many other members</li>
<li class="supNeg">12 (0%) This language is good for distributed computing</li>
<li>69 (0%) I would use this language for casual scripting</li>
<li>31 (0%) There are many good open-source tools for this language</li>
<li>38 (1%) Code written in this language tends to be terse</li>
<li>73 (1%) I enjoy playing with this language but would never use it for "real code"</li>
<li>58 (1%) I know this language well</li>
<li>33 (1%) This is a low level language</li>
<li>41 (1%) This is a mainstream language</li>
<li class="supNeg">17 (2%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>30 (2%) I would use this language for writing programs for an embedded hardware platform</li>
<li>51 (2%) This language has many features which feel "tacked on"</li>
<li>47 (2%) This language would be good for teaching children to write software</li>
<li>31 (2%) This language is built on a small core of orthogonal features</li>
<li>43 (2%) The resources for learning this language are of high quality</li>
<li>32 (2%) There are many good tools for this language</li>
<li>56 (2%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>25 (3%) This language has a very rigid idea of how things should be done</li>
<li>30 (3%) Learning this language significantly changed how I use other languages.</li>
<li>34 (3%) Writing code in this language is a lot of work</li>
<li>42 (3%) The semantics of this language are much different than other languages I know.</li>
<li>51 (3%) This language is likely to be around for a very long time</li>
<li>47 (3%) I would use this language for a web project</li>
<li class="supNeg">16 (4%) I would list this language on my resume</li>
<li class="supNeg">14 (4%) Programs written in this language tend to be efficient</li>
<li>41 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (4%) This language excels at concurrency</li>
<li>25 (4%) This language is good for beginners</li>
<li>42 (4%) I usually use this language on solo projects</li>
<li>31 (4%) This language has a good community</li>
<li class="supNeg">22 (4%) When I write code in this language I can be very sure it is correct</li>
<li>57 (5%) Programs written in this language tend to play well with others</li>
<li>46 (5%) This language encourages writing reusable code.</li>
<li>61 (5%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">11 (5%) It's unusual for me to discover unfamiliar features</li>
<li>50 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>60 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li>27 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">20 (6%) I would use this language for writing server programs</li>
<li>52 (6%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>47 (6%) This language is well documented</li>
<li>68 (7%) This language has an annoying syntax</li>
<li>65 (7%) I am reluctant to admit to knowing this language</li>
<li>36 (8%) I would like to write more of this language than I currently do</li>
<li>38 (8%) This language has a very dogmatic community</li>
<li>26 (8%) I can imagine using this language in my day job</li>
<li>25 (8%) I know many other people who use this language</li>
<li>51 (8%) I use many applications written in this language</li>
<li class="supNeg">24 (8%) This language has a strong static type system</li>
<li class="supNeg">18 (8%) This language has unusual features that I often miss when using other languages</li>
<li>38 (8%) This language has a good library distribution mechanism.</li>
<li>37 (8%) Code written in this language tends to be very reliable</li>
<li class="supNeg">8 (8%) I still discover new features of this language on a fairly regular basis</li>
<li>45 (9%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>25 (9%) This language has a niche in which it is great</li>
<li>56 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li>28 (9%) Libraries in this language tend to be well documented.</li>
</ul>
<ul>
<li>55 (0%) I can imagine this will be a popular language in twenty years time</li>
<li>73 (0%) This language is good for numeric computing</li>
<li class="supNeg">18 (0%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">78 (0%) I usually use this language on projects with many other members</li>
<li>43 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>39 (0%) I would like to write more of this language than I currently do</li>
<li>55 (0%) Libraries in this language tend to be well documented.</li>
<li class="supPos">77 (0%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">87 (0%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">82 (0%) There are many good open-source tools for this language</li>
<li class="supPos">98 (1%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supPos">98 (1%) I find it easy to write efficient code in this language</li>
<li class="supNeg">4 (1%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">86 (1%) There are many good commercial tools for this language</li>
<li class="supPos">76 (1%) There are many good tools for this language</li>
<li class="supPos">88 (1%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>47 (2%) I often feel like I am not smart enough to write this language</li>
<li>56 (2%) This language has a strong static type system</li>
<li class="supPos">97 (2%) I use many applications written in this language</li>
<li class="supPos">93 (2%) This language has a high quality implementation</li>
<li>39 (2%) I would use this language for casual scripting</li>
<li>44 (2%) I find this language easy to prototype in</li>
<li class="supPos">87 (2%) This is a mainstream language</li>
<li class="supNeg">7 (2%) I am reluctant to admit to knowing this language</li>
<li>36 (2%) This language has a very coherent design</li>
<li>43 (3%) This language has a very dogmatic community</li>
<li class="supPos">85 (3%) I know many other people who use this language</li>
<li>31 (3%) This language has a niche outside of which I would not use it</li>
<li class="supPos">84 (3%) Programs written in this language tend to be efficient</li>
<li>33 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>60 (3%) I would use this language for mobile applications</li>
<li class="supPos">92 (3%) Learning this language improved my ability as a programmer</li>
<li>47 (3%) This language has a good library distribution mechanism.</li>
<li class="supNeg">21 (3%) This language excels at concurrency</li>
<li>37 (3%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">78 (4%) The resources for learning this language are of high quality</li>
<li class="supPos">95 (4%) This language is suitable for real-time applications</li>
<li>33 (4%) This language is well suited for an agile development approach using short iterations.</li>
<li>29 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">75 (4%) I know this language well</li>
<li>28 (4%) I find code written in this language very elegant</li>
<li>62 (4%) Writing code in this language is a lot of work</li>
<li class="supPos">95 (4%) Programs written in this language will usually work in future versions of the language</li>
<li>40 (4%) Learning this language significantly changed how I use other languages.</li>
<li>61 (4%) Code written in this language tends to be verbose</li>
<li>56 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>38 (4%) This language has a good community</li>
<li>28 (4%) This language excels at symbolic manipulation</li>
<li>41 (4%) It is easy to tell at a glance what code in this language does</li>
<li>36 (5%) I would use this language for a web project</li>
<li class="supNeg">19 (5%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">5 (5%) I use this language out of choice</li>
<li>49 (5%) This language encourages writing code that is easy to maintain.</li>
<li>49 (6%) This is a high level language</li>
<li>69 (6%) This language is best for very large projects</li>
<li class="supPos">78 (6%) I would use this language to write a command-line app</li>
<li class="supPos">93 (6%) There is a wide variety of open source code written in this language</li>
<li>45 (6%) Code written in this language is very readable</li>
<li>57 (6%) I often get angry when writing code in this language</li>
<li>68 (6%) This language is good for scientific computing</li>
<li>34 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (7%) I enjoy using this language</li>
<li>34 (7%) Code written in this language tends to be very reliable</li>
<li class="supPos">82 (7%) I learned this language early in my career as a programmer</li>
<li class="supNeg">17 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>73 (8%) This language is very flexible</li>
<li>69 (8%) This is a low level language</li>
<li>31 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">91 (8%) Developers who primarily use this language often burn out after a few years</li>
<li>27 (8%) This language excels at text processing</li>
<li>41 (8%) Code written in this language tends to be terse</li>
<li>46 (8%) I would use this language for writing server programs</li>
<li class="supPos">83 (9%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">90 (9%) This language is likely to be around for a very long time</li>
</ul>
<ul></ul>
<ul>
<li>59 (1%) This language is good for scientific computing</li>
<li>30 (2%) I would use this language as a scripting language embedded inside a larger application</li>
<li>38 (3%) This language is good for distributed computing</li>
<li>38 (3%) I can imagine using this language in my day job</li>
<li>45 (3%) I would use this language for a web project</li>
<li>55 (3%) Code written in this language is very readable</li>
<li>65 (4%) This language has a good community</li>
<li class="supPos">80 (4%) I find it easy to write efficient code in this language</li>
<li>70 (4%) This language is suitable for real-time applications</li>
<li>40 (4%) This language has a very rigid idea of how things should be done</li>
<li>71 (4%) I use this language out of choice</li>
<li>44 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>35 (5%) This language is good for beginners</li>
<li>57 (5%) Programs written in this language tend to play well with others</li>
<li>70 (6%) This language is best for very large projects</li>
<li>53 (6%) This language matches it's problem domain particularly well.</li>
<li>53 (6%) This language is unusually bad for beginners</li>
<li>59 (6%) This language has many features which feel "tacked on"</li>
<li>48 (6%) I still discover new features of this language on a fairly regular basis</li>
<li>37 (6%) I often feel like I am not smart enough to write this language</li>
<li>48 (6%) This language is large</li>
<li>42 (7%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>47 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li>62 (7%) This language has a very coherent design</li>
<li>38 (7%) I usually use this language on projects with many other members</li>
<li>49 (7%) This language has a good library distribution mechanism.</li>
<li>25 (7%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>69 (7%) Programs written in this language tend to be efficient</li>
<li>69 (7%) This language encourages writing code that is easy to maintain.</li>
<li>38 (7%) This language is minimal</li>
<li>50 (8%) I usually use this language on solo projects</li>
<li>54 (8%) The resources for learning this language are of high quality</li>
<li>39 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>73 (8%) I find this language easy to prototype in</li>
<li>47 (8%) This language is very flexible</li>
<li>51 (8%) I would use this language for casual scripting</li>
<li>35 (8%) Writing code in this language is a lot of work</li>
<li class="supPos">83 (8%) This language encourages writing reusable code.</li>
<li>47 (8%) This language has an annoying syntax</li>
<li>60 (8%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>41 (8%) This is a mainstream language</li>
<li>40 (8%) This language is frequently used for applications it isn't suitable for</li>
<li>51 (9%) I would use this language for writing embedded programs</li>
<li>36 (9%) This language would be good for teaching children to write software</li>
<li class="supNeg">17 (9%) This language has a niche in which it is great</li>
<li>55 (9%) This language has a very dogmatic community</li>
<li>65 (9%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>42 (9%) This language excels at text processing</li>
<li>38 (9%) This language is well documented</li>
<li>35 (9%) There is a wide variety of open source code written in this language</li>
<li>53 (9%) This language has unusual features that I often miss when using other languages</li>
<li>55 (9%) I enjoy playing with this language but would never use it for "real code"</li>
<li>36 (9%) When I write code in this language I can be very sure it is correct</li>
</ul>
<ul></ul>
<ul>
<li>44 (0%) I would use this language for mobile applications</li>
<li class="supPos">79 (0%) This language is very flexible</li>
<li>64 (0%) I use this language out of choice</li>
<li>30 (0%) This language is good for scientific computing</li>
<li class="supNeg">8 (0%) I know many other people who use this language</li>
<li>46 (0%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supNeg">24 (0%) I would use this language for writing programs for an embedded hardware platform</li>
<li>70 (0%) I find code written in this language very elegant</li>
<li>56 (0%) I usually use this language on solo projects</li>
<li>69 (1%) This language is best for very small projects</li>
<li>26 (1%) There are many good open-source tools for this language</li>
<li>34 (1%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>48 (1%) This language is good for beginners</li>
<li>51 (1%) This language has unusual features that I often miss when using other languages</li>
<li>27 (1%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>31 (1%) I am reluctant to admit to knowing this language</li>
<li>43 (1%) This language has a niche outside of which I would not use it</li>
<li>59 (2%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">23 (2%) There are many good commercial tools for this language</li>
<li class="supNeg">15 (2%) I would list this language on my resume</li>
<li>51 (2%) Programs written in this language tend to play well with others</li>
<li>46 (2%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">12 (2%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>36 (2%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">77 (2%) This is a high level language</li>
<li>40 (2%) This language has many features which feel "tacked on"</li>
<li>48 (2%) I would like to write more of this language than I currently do</li>
<li>42 (2%) The resources for learning this language are of high quality</li>
<li>72 (2%) I find this language easy to prototype in</li>
<li>53 (2%) This language excels at symbolic manipulation</li>
<li>59 (3%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>29 (3%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>43 (3%) I enjoy using this language</li>
<li>59 (3%) This language has a good community</li>
<li>47 (3%) This language makes it easy to shoot yourself in the foot</li>
<li>41 (3%) This language is suitable for real-time applications</li>
<li>44 (3%) I know this language well</li>
<li>58 (3%) This language encourages writing code that is easy to maintain.</li>
<li class="supNeg">14 (3%) This is a mainstream language</li>
<li>45 (3%) This language is good for numeric computing</li>
<li>29 (4%) This language excels at concurrency</li>
<li>25 (4%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">8 (4%) This language has a niche in which it is great</li>
<li class="supNeg">18 (4%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">9 (4%) I usually use this language on projects with many other members</li>
<li>41 (4%) Programs written in this language will usually work in future versions of the language</li>
<li>26 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>25 (4%) There is a wide variety of open source code written in this language</li>
<li>65 (4%) This language is expressive</li>
<li class="supNeg">23 (4%) It's unusual for me to discover unfamiliar features</li>
<li>65 (4%) Learning this language improved my ability as a programmer</li>
<li>29 (4%) It is easy to debug programs written in this language when it goes wrong</li>
<li class="supPos">77 (4%) This language is likely to be a passing fad</li>
<li>29 (4%) This language is good for distributed computing</li>
<li>41 (5%) I would use this language for a desktop GUI project</li>
<li>36 (5%) This language is likely to have a strong influence on future languages</li>
<li>31 (5%) This is a low level language</li>
<li>38 (5%) Developers who primarily use this language often burn out after a few years</li>
<li>59 (5%) This language would be good for teaching children to write software</li>
<li>30 (5%) There are many good tools for this language</li>
<li>69 (5%) I would use this language for casual scripting</li>
<li>45 (5%) I find it easy to write efficient code in this language</li>
<li>45 (6%) Learning this language significantly changed how I use other languages.</li>
<li class="supNeg">6 (6%) I use many applications written in this language</li>
<li>29 (6%) Writing code in this language is a lot of work</li>
<li>40 (6%) This language excels at text processing</li>
<li>31 (7%) Libraries in this language tend to be well documented.</li>
<li>38 (7%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>31 (7%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>54 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">19 (7%) I can imagine using this language in my day job</li>
<li class="supNeg">21 (7%) This language has a strong static type system</li>
<li class="supNeg">15 (7%) I learned this language early in my career as a programmer</li>
<li class="supPos">79 (7%) This language encourages writing reusable code.</li>
<li class="supPos">76 (8%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>28 (8%) I would use this language for writing server programs</li>
<li>40 (8%) This language has a good library distribution mechanism.</li>
<li>35 (8%) This language has an annoying syntax</li>
<li class="supPos">80 (9%) This language has a very coherent design</li>
<li>64 (9%) Code written in this language tends to be terse</li>
<li class="supNeg">19 (9%) Code written in this language tends to be verbose</li>
<li>44 (9%) I still discover new features of this language on a fairly regular basis</li>
</ul>
<ul>
<li>25 (0%) This language excels at concurrency</li>
<li>34 (1%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>60 (1%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>44 (2%) This language is likely to have a strong influence on future languages</li>
<li>47 (3%) This language would be good for teaching children to write software</li>
<li>67 (3%) This language has a good community</li>
<li>70 (3%) This is a high level language</li>
<li>57 (3%) This language is well suited for an agile development approach using short iterations.</li>
<li>33 (3%) This is a low level language</li>
<li>62 (3%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">79 (3%) I find this language easy to prototype in</li>
<li>56 (4%) This language makes it easy to shoot yourself in the foot</li>
<li>63 (4%) I often get angry when writing code in this language</li>
<li>49 (4%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>41 (4%) This language is likely to be a passing fad</li>
<li>70 (5%) I regularly use this language</li>
<li>55 (5%) I can imagine this will be a popular language in twenty years time</li>
<li>71 (6%) I would use this language for a web project</li>
<li>42 (6%) I would like to write more of this language than I currently do</li>
<li>38 (6%) This language matches it's problem domain particularly well.</li>
<li>45 (6%) I still discover new features of this language on a fairly regular basis</li>
<li class="supPos">87 (6%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>53 (6%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>53 (7%) I learned this language early in my career as a programmer</li>
<li>73 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>35 (7%) This language has unusual features that I often miss when using other languages</li>
<li class="supPos">85 (7%) There is a wide variety of open source code written in this language</li>
<li>62 (7%) Developers who primarily use this language often burn out after a few years</li>
<li>35 (7%) I find code written in this language very elegant</li>
<li>57 (8%) This language is expressive</li>
<li>61 (8%) Programs written in this language tend to play well with others</li>
<li>61 (8%) There is a lot of accidental complexity when writing code in this language</li>
<li>34 (8%) I can imagine using this language in my day job</li>
<li>64 (8%) This language is likely to be around for a very long time</li>
<li>41 (9%) Code written in this language is very readable</li>
<li>31 (9%) Learning this language significantly changed how I use other languages.</li>
<li>44 (9%) This language is good for beginners</li>
<li>45 (9%) This language excels at symbolic manipulation</li>
<li>36 (9%) Programs written in this language tend to be efficient</li>
<li class="supPos">76 (9%) I use many applications written in this language</li>
<li>28 (9%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
</ul>
<ul>
<li class="supPos">79 (0%) This is a high level language</li>
<li>40 (0%) This language has a very dogmatic community</li>
<li>49 (0%) I would use this language for casual scripting</li>
<li class="supNeg">18 (0%) There is a lot of accidental complexity when writing code in this language</li>
<li>45 (0%) I would use this language to write a command-line app</li>
<li>64 (0%) This language is expressive</li>
<li>66 (0%) This language excels at symbolic manipulation</li>
<li>33 (0%) This language has a very rigid idea of how things should be done</li>
<li>56 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>28 (0%) This is a low level language</li>
<li>25 (0%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>49 (0%) This language has many features which feel "tacked on"</li>
<li>46 (0%) I enjoy using this language</li>
<li class="supPos">78 (1%) This language encourages writing reusable code.</li>
<li class="supNeg">16 (1%) This language is best for very small projects</li>
<li>45 (1%) Code written in this language tends to be terse</li>
<li>60 (2%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>30 (2%) I would use this language as a scripting language embedded inside a larger application</li>
<li>37 (2%) There are many good tools for this language</li>
<li>47 (2%) This language is good for scientific computing</li>
<li>31 (3%) This language is good for numeric computing</li>
<li>46 (3%) It is easy to debug programs written in this language when it goes wrong</li>
<li>38 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>69 (3%) This language has a very coherent design</li>
<li>63 (3%) I use this language out of choice</li>
<li>63 (3%) I find this language easy to prototype in</li>
<li>74 (3%) This language has a high quality implementation</li>
<li>29 (3%) I often get angry when writing code in this language</li>
<li>32 (3%) This language is good for beginners</li>
<li>42 (3%) I often feel like I am not smart enough to write this language</li>
<li>35 (4%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">10 (4%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>72 (4%) The semantics of this language are much different than other languages I know.</li>
<li>63 (4%) This language has a niche outside of which I would not use it</li>
<li>42 (4%) I usually use this language on solo projects</li>
<li>30 (4%) This language is well documented</li>
<li>63 (4%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>33 (5%) I would use this language for mobile applications</li>
<li>55 (5%) I would use this language for a web project</li>
<li>71 (5%) This language has unusual features that I often miss when using other languages</li>
<li>29 (5%) This is a mainstream language</li>
<li>28 (5%) This language has a strong static type system</li>
<li>60 (5%) Programs written in this language will usually work in future versions of the language</li>
<li>72 (5%) This language encourages writing code that is easy to maintain.</li>
<li>38 (5%) There are many good commercial tools for this language</li>
<li>45 (5%) I would use this language for a desktop GUI project</li>
<li>64 (5%) Learning this language significantly changed how I use other languages.</li>
<li>57 (5%) This language is built on a small core of orthogonal features</li>
<li>29 (5%) When I write code in this language I can be very sure it is correct</li>
<li>34 (5%) This language excels at text processing</li>
<li>29 (6%) I would use this language for writing embedded programs</li>
<li>37 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>50 (6%) This language is likely to be a passing fad</li>
<li>58 (7%) I find code written in this language very elegant</li>
<li>43 (7%) Code written in this language tends to be verbose</li>
<li>36 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>43 (7%) Code written in this language is very readable</li>
<li class="supPos">78 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li>46 (8%) I still discover new features of this language on a fairly regular basis</li>
<li>65 (8%) This language has an annoying syntax</li>
<li>67 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li>33 (8%) There are many good open-source tools for this language</li>
<li>51 (8%) This language is very flexible</li>
<li>57 (8%) This language has a good library distribution mechanism.</li>
<li>39 (9%) This language is minimal</li>
<li>70 (9%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>46 (9%) I find it easy to write efficient code in this language</li>
<li>48 (9%) It is easy to tell at a glance what code in this language does</li>
<li>74 (9%) Learning this language improved my ability as a programmer</li>
<li>39 (9%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>49 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>45 (9%) I am reluctant to admit to knowing this language</li>
<li>63 (9%) Code written in this language tends to be very reliable</li>
<li>37 (9%) This language would be good for teaching children to write software</li>
<li>73 (9%) This language is likely to have a strong influence on future languages</li>
</ul>
<ul>
<li>74 (0%) I would use this language for casual scripting</li>
<li>54 (1%) This language excels at text processing</li>
<li>42 (3%) I use many applications written in this language</li>
<li>56 (3%) I would like to write more of this language than I currently do</li>
<li>41 (4%) This is a mainstream language</li>
<li>43 (4%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>63 (4%) This language has a good community</li>
<li class="supNeg">24 (4%) Writing code in this language is a lot of work</li>
<li>45 (4%) This language is suitable for real-time applications</li>
<li class="supPos">86 (4%) I find this language easy to prototype in</li>
<li>25 (5%) This is a low level language</li>
<li>52 (5%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>45 (5%) This language is large</li>
<li>46 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>61 (5%) I would use this language for a desktop GUI project</li>
<li>62 (5%) This language has a good library distribution mechanism.</li>
<li>43 (5%) This language is unusually bad for beginners</li>
<li>31 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>58 (6%) The resources for learning this language are of high quality</li>
<li>48 (6%) This language is best for very small projects</li>
<li>43 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>58 (6%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">80 (6%) This is a high level language</li>
<li>71 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li>43 (7%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>48 (7%) Programs written in this language will usually work in future versions of the language</li>
<li>45 (7%) I can imagine using this language in my day job</li>
<li>73 (8%) This language encourages writing code that is easy to maintain.</li>
<li>48 (8%) This language has unusual features that I often miss when using other languages</li>
<li>48 (8%) Libraries in this language tend to be well documented.</li>
<li>64 (8%) This language is expressive</li>
<li class="supNeg">19 (8%) I learned this language early in my career as a programmer</li>
<li>27 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>41 (8%) I know many other people who use this language</li>
<li>37 (8%) This language is likely to be around for a very long time</li>
<li>67 (8%) Code written in this language is very readable</li>
<li>64 (9%) It is easy to tell at a glance what code in this language does</li>
<li>63 (9%) I find code written in this language very elegant</li>
<li>35 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>25 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>69 (9%) I would use this language to write a command-line app</li>
<li>37 (9%) Learning this language significantly changed how I use other languages.</li>
<li>63 (9%) Programs written in this language tend to play well with others</li>
<li>36 (9%) This language has an annoying syntax</li>
<li>58 (9%) This language has many features which feel "tacked on"</li>
</ul>
<ul>
<li>72 (0%) I would use this language for a desktop GUI project</li>
<li class="supPos">88 (2%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>56 (3%) Learning this language significantly changed how I use other languages.</li>
<li class="supPos">88 (3%) This is a high level language</li>
<li class="supNeg">19 (3%) This is a low level language</li>
<li class="supPos">82 (3%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">19 (3%) I learned this language early in my career as a programmer</li>
<li>53 (3%) Code written in this language tends to be terse</li>
<li>70 (3%) Code written in this language is very readable</li>
<li>38 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>73 (4%) I find code written in this language very elegant</li>
<li class="supPos">80 (4%) This language has a good community</li>
<li>31 (4%) When I write code in this language I can be very sure it is correct</li>
<li>29 (4%) Code written in this language tends to be verbose</li>
<li>54 (5%) There are many good tools for this language</li>
<li>26 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>69 (5%) It is easy to tell at a glance what code in this language does</li>
<li class="supPos">92 (5%) I find this language easy to prototype in</li>
<li class="supPos">79 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">92 (5%) This language is very flexible</li>
<li>33 (5%) This language makes it easy to shoot yourself in the foot</li>
<li>65 (6%) Programs written in this language tend to play well with others</li>
<li>51 (6%) There are many good commercial tools for this language</li>
<li>71 (6%) There are many good open-source tools for this language</li>
<li class="supPos">92 (6%) I use this language out of choice</li>
<li>35 (6%) This language has a very rigid idea of how things should be done</li>
<li>74 (6%) This language is likely to be a passing fad</li>
<li>31 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li>66 (7%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li class="supPos">89 (7%) This language encourages writing reusable code.</li>
<li class="supNeg">21 (7%) This language has a niche in which it is great</li>
<li class="supNeg">10 (7%) Writing code in this language is a lot of work</li>
<li class="supNeg">22 (7%) This language has an annoying syntax</li>
<li class="supPos">76 (7%) This language is likely to have a strong influence on future languages</li>
<li>62 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">22 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supPos">76 (8%) I would use this language for casual scripting</li>
<li class="supPos">76 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supPos">87 (8%) I would use this language to write a command-line app</li>
<li>46 (8%) I regularly use this language</li>
<li>69 (8%) I would use this language for mobile applications</li>
<li>52 (8%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supPos">88 (8%) This language is expressive</li>
<li>43 (8%) This language is likely to be around for a very long time</li>
<li>74 (9%) This language encourages writing code that is easy to maintain.</li>
<li>49 (9%) I usually use this language on projects with many other members</li>
<li class="supPos">90 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">20 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>40 (9%) Developers who primarily use this language often burn out after a few years</li>
<li>65 (9%) This language has a high quality implementation</li>
<li class="supNeg">11 (9%) It's unusual for me to discover unfamiliar features</li>
<li>31 (9%) I would use this language for writing embedded programs</li>
<li>64 (9%) This language excels at symbolic manipulation</li>
</ul>
<ul>
<li>35 (0%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>44 (0%) This language is suitable for real-time applications</li>
<li>35 (0%) I would use this language for writing programs for an embedded hardware platform</li>
<li>63 (0%) It's unusual for me to discover unfamiliar features</li>
<li class="supPos">83 (0%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">78 (0%) Programs written in this language tend to play well with others</li>
<li>35 (1%) I would use this language for writing embedded programs</li>
<li>36 (1%) This language excels at concurrency</li>
<li>71 (1%) I would use this language for writing server programs</li>
<li>40 (1%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supPos">77 (1%) There are many good tools for this language</li>
<li>45 (1%) I would like to write more of this language than I currently do</li>
<li class="supPos">82 (2%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">81 (2%) I would list this language on my resume</li>
<li class="supPos">80 (2%) This language encourages writing reusable code.</li>
<li>33 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>50 (2%) I enjoy using this language</li>
<li>44 (2%) Learning this language significantly changed how I use other languages.</li>
<li>69 (2%) This language is likely to be around for a very long time</li>
<li class="supNeg">15 (2%) This language has a very rigid idea of how things should be done</li>
<li>71 (3%) I usually use this language on projects with many other members</li>
<li>46 (3%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>64 (3%) This language has a very dogmatic community</li>
<li>74 (3%) I use many applications written in this language</li>
<li class="supPos">85 (3%) I would use this language for a web project</li>
<li>44 (3%) This language matches it's problem domain particularly well.</li>
<li class="supNeg">19 (4%) I often get angry when writing code in this language</li>
<li class="supPos">95 (4%) It is easy to tell at a glance what code in this language does</li>
<li class="supNeg">15 (4%) I often feel like I am not smart enough to write this language</li>
<li>70 (4%) I know this language well</li>
<li>44 (4%) This language is good for distributed computing</li>
<li>43 (4%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">87 (4%) I find this language easy to prototype in</li>
<li>40 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>40 (4%) This language is likely to be a passing fad</li>
<li class="supPos">81 (4%) I would use this language for mobile applications</li>
<li class="supPos">91 (4%) This language is well documented</li>
<li>40 (4%) Code written in this language tends to be terse</li>
<li>40 (5%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>60 (5%) This language is good for numeric computing</li>
<li>64 (5%) I still discover new features of this language on a fairly regular basis</li>
<li class="supPos">94 (5%) The resources for learning this language are of high quality</li>
<li>33 (5%) When I write code in this language I can be very sure it is correct</li>
<li class="supPos">89 (5%) I would use this language for a desktop GUI project</li>
<li>43 (5%) Programs written in this language tend to be efficient</li>
<li>73 (6%) This is a high level language</li>
<li class="supNeg">24 (6%) This language is built on a small core of orthogonal features</li>
<li class="supPos">78 (6%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supPos">93 (6%) This language has a high quality implementation</li>
<li class="supPos">85 (6%) This is a mainstream language</li>
<li>32 (6%) This language has an annoying syntax</li>
<li>62 (6%) I usually use this language on solo projects</li>
<li>70 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>66 (7%) This language has many features which feel "tacked on"</li>
<li>58 (7%) I regularly use this language</li>
<li>66 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>41 (8%) I learned this language early in my career as a programmer</li>
<li>29 (8%) This is a low level language</li>
<li class="supPos">85 (8%) I would use this language to write a command-line app</li>
<li>29 (8%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">87 (8%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">19 (9%) The semantics of this language are much different than other languages I know.</li>
<li>58 (9%) This language is likely to have a strong influence on future languages</li>
<li>56 (9%) Code written in this language tends to be very reliable</li>
<li>52 (9%) This language excels at symbolic manipulation</li>
<li>44 (9%) This language has unusual features that I often miss when using other languages</li>
</ul>
<ul></ul>
</div>
k-means with k = 24
<tabled class="data" id="clusters24">
  <trd>
    <tdd>Coq,0.0</tdd>
  </trd>
  <trd>
    <tdd>Scheme,5.0</tdd>
    <tdd>Lua,6.0</tdd>
    <tdd>Smalltalk,6.0</tdd>
    <tdd>Io,6.0</tdd>
  </trd>
  <trd>
    <tdd>Assembler,0.0</tdd>
  </trd>
  <trd>
    <tdd>Shell,0.0</tdd>
  </trd>
  <trd>
    <tdd>REBOL,0.0</tdd>
  </trd>
  <trd>
    <tdd>Factor,5.0</tdd>
    <tdd>J,5.0</tdd>
  </trd>
  <trd>
    <tdd>R,4.0</tdd>
    <tdd>Matlab,4.0</tdd>
    <tdd>Mathematica,4.0</tdd>
  </trd>
  <trd>
    <tdd>Forth,5.0</tdd>
    <tdd>APL,5.0</tdd>
  </trd>
  <trd>
    <tdd>TCL,6.0</tdd>
    <tdd>ActionScript,6.0</tdd>
  </trd>
  <trd>
    <tdd>AWK,0.0</tdd>
  </trd>
  <trd>
    <tdd>C++,7.0</tdd>
    <tdd>C,8.0</tdd>
    <tdd>Java,8.0</tdd>
  </trd>
  <trd>
    <tdd>D,5.0</tdd>
    <tdd>Ada,6.0</tdd>
    <tdd>Eiffel,6.0</tdd>
    <tdd>Go,6.0</tdd>
    <tdd>Objective C,7.0</tdd>
    <tdd>Standard ML,7.0</tdd>
    <tdd>Mozart-Oz,8.0</tdd>
  </trd>
  <trd>
    <tdd>Haskell,0.0</tdd>
  </trd>
  <trd>
    <tdd>ELisp,0.0</tdd>
  </trd>
  <trd>
    <tdd>Python,5.0</tdd>
    <tdd>Ruby,5.0</tdd>
    <tdd>C#,7.0</tdd>
  </trd>
  <trd>
    <tdd>Groovy,4.0</tdd>
    <tdd>Haxe,4.0</tdd>
  </trd>
  <trd>
    <tdd>Prolog,0.0</tdd>
  </trd>
  <trd>
    <tdd>Agda,0.0</tdd>
  </trd>
  <trd>
    <tdd>Delphi,4.0</tdd>
    <tdd>Pascal,5.0</tdd>
    <tdd>Visual Basic,6.0</tdd>
  </trd>
  <trd>
    <tdd>F#,5.0</tdd>
    <tdd>O'Caml,5.0</tdd>
    <tdd>Clojure,6.0</tdd>
    <tdd>Common Lisp,7.0</tdd>
    <tdd>Scala,7.0</tdd>
    <tdd>Erlang,8.0</tdd>
  </trd>
  <trd>
    <tdd>Fortran,5.0</tdd>
    <tdd>Cobol,5.0</tdd>
  </trd>
  <trd>
    <tdd>Javascript,5.0</tdd>
    <tdd>Perl,6.0</tdd>
    <tdd>PHP,6.0</tdd>
  </trd>
</tabled>
<div class="support" id="support24">
<ul></ul>
<ul>
<li>26 (1%) This language is good for distributed computing</li>
<li class="supNeg">24 (1%) When I write code in this language I can be very sure it is correct</li>
<li class="supNeg">14 (2%) This language has a strong static type system</li>
<li>60 (2%) This language has a good community</li>
<li>46 (2%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>37 (3%) This language is frequently used for applications it isn't suitable for</li>
<li>51 (3%) I would use this language for a web project</li>
<li>26 (4%) This is a low level language</li>
<li>28 (4%) I would use this language for writing server programs</li>
<li class="supPos">80 (4%) I find this language easy to prototype in</li>
<li class="supPos">80 (4%) This is a high level language</li>
<li>26 (5%) This language excels at concurrency</li>
<li>61 (5%) This language encourages writing code that is easy to maintain.</li>
<li>70 (5%) I use this language out of choice</li>
<li>45 (5%) This language is suitable for real-time applications</li>
<li>29 (5%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>32 (5%) I would use this language for writing programs for an embedded hardware platform</li>
<li>26 (5%) This language has an annoying syntax</li>
<li>37 (5%) Developers who primarily use this language often burn out after a few years</li>
<li>38 (6%) This language has many features which feel "tacked on"</li>
<li class="supNeg">20 (6%) I often get angry when writing code in this language</li>
<li>39 (6%) This language is good for numeric computing</li>
<li class="supNeg">20 (6%) Writing code in this language is a lot of work</li>
<li>35 (6%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>33 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>40 (6%) This language is good for scientific computing</li>
<li>25 (6%) I can imagine using this language in my day job</li>
<li>54 (6%) This language has unusual features that I often miss when using other languages</li>
<li>38 (6%) Programs written in this language tend to be efficient</li>
<li>45 (6%) This language excels at text processing</li>
<li>45 (6%) Code written in this language tends to be terse</li>
<li>45 (7%) Programs written in this language will usually work in future versions of the language</li>
<li>67 (7%) This language is expressive</li>
<li>48 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>72 (7%) It is easy to tell at a glance what code in this language does</li>
<li class="supPos">78 (7%) This language is very flexible</li>
<li>41 (7%) I still discover new features of this language on a fairly regular basis</li>
<li>54 (7%) I would use this language for a desktop GUI project</li>
<li>27 (8%) I usually use this language on projects with many other members</li>
<li>43 (8%) I usually use this language on solo projects</li>
<li class="supPos">88 (8%) This language has a very coherent design</li>
<li>37 (8%) Libraries in this language tend to be well documented.</li>
<li>26 (8%) This language is unusually bad for beginners</li>
<li class="supNeg">20 (8%) I am reluctant to admit to knowing this language</li>
<li>56 (8%) I would use this language for mobile applications</li>
<li>42 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supPos">75 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>64 (9%) I would like to write more of this language than I currently do</li>
<li>36 (9%) I learned this language early in my career as a programmer</li>
<li class="supPos">76 (9%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>66 (9%) Code written in this language is very readable</li>
<li class="supPos">80 (9%) This language encourages writing reusable code.</li>
<li>49 (9%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>33 (9%) This is a mainstream language</li>
<li>51 (9%) I can imagine this will be a popular language in twenty years time</li>
</ul>
<ul></ul>
<ul></ul>
<ul></ul>
<ul>
<li>45 (0%) The resources for learning this language are of high quality</li>
<li>63 (0%) I would use this language for casual scripting</li>
<li>30 (0%) This language has a very rigid idea of how things should be done</li>
<li>55 (0%) This language excels at symbolic manipulation</li>
<li class="supNeg">11 (0%) I can imagine using this language in my day job</li>
<li class="supPos">75 (0%) This is a high level language</li>
<li>70 (0%) I find code written in this language very elegant</li>
<li>29 (0%) This language has a strong static type system</li>
<li>38 (0%) This language has many features which feel "tacked on"</li>
<li>52 (0%) Programs written in this language tend to be efficient</li>
<li>54 (1%) I usually use this language on solo projects</li>
<li>56 (1%) I would use this language for writing embedded programs</li>
<li>46 (1%) I would use this language to write a command-line app</li>
<li>72 (1%) This language has a very coherent design</li>
<li>32 (1%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>46 (1%) This language is suitable for real-time applications</li>
<li class="supNeg">22 (1%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">11 (1%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>44 (2%) I often get angry when writing code in this language</li>
<li class="supPos">97 (2%) The semantics of this language are much different than other languages I know.</li>
<li>60 (2%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>61 (2%) This language is unusually bad for beginners</li>
<li>38 (2%) Writing code in this language is a lot of work</li>
<li>45 (2%) This language has a good library distribution mechanism.</li>
<li>47 (2%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>53 (3%) This language makes it easy to shoot yourself in the foot</li>
<li class="supPos">96 (3%) I enjoy playing with this language but would never use it for "real code"</li>
<li>35 (3%) Libraries in this language tend to be well documented.</li>
<li>43 (3%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li class="supNeg">14 (3%) This is a mainstream language</li>
<li>46 (3%) This language is good for beginners</li>
<li>37 (3%) This language excels at concurrency</li>
<li>37 (3%) This language is likely to have a strong influence on future languages</li>
<li>50 (3%) This language would be good for teaching children to write software</li>
<li>34 (3%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">80 (4%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supNeg">23 (4%) I would use this language for a web project</li>
<li>35 (4%) I regularly use this language</li>
<li>38 (4%) This language is likely to be around for a very long time</li>
<li class="supNeg">4 (4%) Code written in this language tends to be verbose</li>
<li>29 (4%) It is easy to debug programs written in this language when it goes wrong</li>
<li>58 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li>51 (5%) I would like to write more of this language than I currently do</li>
<li class="supPos">75 (5%) This language is expressive</li>
<li>38 (5%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>46 (5%) This language is built on a small core of orthogonal features</li>
<li class="supNeg">21 (5%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>33 (5%) There are many good open-source tools for this language</li>
<li>56 (5%) This language has a good community</li>
<li>38 (6%) I would use this language for mobile applications</li>
<li>29 (6%) It is easy to tell at a glance what code in this language does</li>
<li class="supPos">75 (6%) I find this language easy to prototype in</li>
<li class="supPos">76 (6%) Learning this language improved my ability as a programmer</li>
<li>47 (6%) This language has a niche outside of which I would not use it</li>
<li>47 (6%) Programs written in this language tend to play well with others</li>
<li>52 (6%) Programs written in this language will usually work in future versions of the language</li>
<li>60 (6%) I still discover new features of this language on a fairly regular basis</li>
<li>70 (6%) I use this language out of choice</li>
<li>50 (6%) This language has an annoying syntax</li>
<li class="supNeg">12 (6%) I usually use this language on projects with many other members</li>
<li class="supNeg">20 (7%) I would list this language on my resume</li>
<li>36 (7%) Developers who primarily use this language often burn out after a few years</li>
<li class="supPos">78 (7%) This language has a high quality implementation</li>
<li>35 (7%) This language has a very dogmatic community</li>
<li>26 (7%) This language is good for distributed computing</li>
<li>43 (7%) I would use this language for a desktop GUI project</li>
<li>39 (7%) This language is well documented</li>
<li>28 (7%) There are many good tools for this language</li>
<li class="supNeg">15 (7%) I know many other people who use this language</li>
<li>39 (8%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">18 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">21 (8%) I am reluctant to admit to knowing this language</li>
<li>33 (8%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>65 (8%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">16 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>30 (9%) There are many good commercial tools for this language</li>
<li>62 (9%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">10 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li>50 (9%) I know this language well</li>
<li>27 (9%) I would use this language for writing server programs</li>
</ul>
<ul>
<li>40 (0%) There is a lot of accidental complexity when writing code in this language</li>
<li>42 (1%) Code written in this language tends to be terse</li>
<li>40 (1%) This language makes it easy to shoot yourself in the foot</li>
<li>36 (1%) I usually use this language on projects with many other members</li>
<li class="supNeg">21 (1%) This language has a strong static type system</li>
<li>45 (1%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>41 (1%) I am reluctant to admit to knowing this language</li>
<li>44 (1%) This language has a very rigid idea of how things should be done</li>
<li>26 (1%) This language excels at concurrency</li>
<li>54 (1%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">20 (2%) This language is good for distributed computing</li>
<li>53 (2%) Code written in this language is very readable</li>
<li>26 (2%) This language is minimal</li>
<li>63 (2%) This language has an annoying syntax</li>
<li>59 (2%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supPos">82 (3%) I enjoy playing with this language but would never use it for "real code"</li>
<li>29 (3%) Writing code in this language is a lot of work</li>
<li>30 (3%) Programs written in this language tend to be efficient</li>
<li>51 (3%) This language is large</li>
<li>47 (3%) This language encourages writing reusable code.</li>
<li>50 (3%) The semantics of this language are much different than other languages I know.</li>
<li>33 (3%) This language has unusual features that I often miss when using other languages</li>
<li class="supPos">92 (3%) This language is good for numeric computing</li>
<li class="supNeg">20 (4%) This language excels at text processing</li>
<li>43 (4%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">23 (4%) Learning this language significantly changed how I use other languages.</li>
<li>54 (4%) I would use this language for casual scripting</li>
<li class="supPos">89 (4%) This language has a niche outside of which I would not use it</li>
<li>44 (4%) This language is frequently used for applications it isn't suitable for</li>
<li>47 (4%) There are many good tools for this language</li>
<li>31 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>45 (4%) This is a mainstream language</li>
<li>34 (4%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">22 (4%) I would use this language for a web project</li>
<li class="supNeg">18 (4%) This is a low level language</li>
<li>40 (4%) I would like to write more of this language than I currently do</li>
<li>52 (4%) This language is unusually bad for beginners</li>
<li class="supNeg">16 (4%) This language is best for very large projects</li>
<li>57 (5%) This language has many features which feel "tacked on"</li>
<li class="supPos">80 (5%) I find this language easy to prototype in</li>
<li>26 (5%) This language is suitable for real-time applications</li>
<li>33 (5%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">5 (5%) I would use this language for writing server programs</li>
<li>51 (5%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li class="supPos">91 (5%) This language is good for scientific computing</li>
<li class="supNeg">12 (5%) I would use this language for mobile applications</li>
<li>42 (5%) Code written in this language tends to be verbose</li>
<li>41 (6%) This language has a very coherent design</li>
<li>51 (6%) I find it easy to write efficient code in this language</li>
<li>36 (6%) I can imagine this will be a popular language in twenty years time</li>
<li>47 (6%) This language is best for very small projects</li>
<li class="supNeg">9 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">9 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">86 (6%) This is a high level language</li>
<li>46 (6%) I usually use this language on solo projects</li>
<li>46 (6%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>45 (6%) This language has a very dogmatic community</li>
<li>51 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li>54 (6%) Libraries in this language tend to be well documented.</li>
<li>50 (6%) Developers who primarily use this language often burn out after a few years</li>
<li>47 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">23 (7%) When I write code in this language I can be very sure it is correct</li>
<li>37 (7%) I find code written in this language very elegant</li>
<li>28 (7%) I would use this language for a desktop GUI project</li>
<li>61 (7%) This language has a high quality implementation</li>
<li>26 (7%) I can imagine using this language in my day job</li>
<li>38 (7%) I use many applications written in this language</li>
<li>41 (8%) This language is good for beginners</li>
<li class="supPos">85 (8%) This language matches it's problem domain particularly well.</li>
<li>27 (8%) Learning this language improved my ability as a programmer</li>
<li>49 (8%) This language is likely to be a passing fad</li>
<li>32 (8%) Code written in this language tends to be very reliable</li>
<li>39 (8%) I would list this language on my resume</li>
<li>40 (8%) This language would be good for teaching children to write software</li>
<li>51 (8%) This language encourages writing code that is easy to maintain.</li>
<li>35 (8%) This language is likely to have a strong influence on future languages</li>
<li class="supNeg">21 (9%) I enjoy using this language</li>
<li>29 (9%) I would use this language for writing embedded programs</li>
<li>37 (9%) There is a wide variety of open source code written in this language</li>
<li>37 (9%) I learned this language early in my career as a programmer</li>
<li class="supNeg">21 (9%) I would use this language to write a command-line app</li>
<li>57 (9%) There are many good commercial tools for this language</li>
</ul>
<ul>
<li>73 (0%) This language has a very coherent design</li>
<li>27 (0%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>36 (0%) Code written in this language is very readable</li>
<li class="supNeg">21 (0%) I use many applications written in this language</li>
<li class="supNeg">17 (0%) I know many other people who use this language</li>
<li>46 (0%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>70 (0%) This language is built on a small core of orthogonal features</li>
<li>28 (0%) This language is good for beginners</li>
<li>65 (0%) This language is unusually bad for beginners</li>
<li>55 (0%) I use this language out of choice</li>
<li>39 (0%) This language encourages writing code that is easy to maintain.</li>
<li>41 (1%) This language has unusual features that I often miss when using other languages</li>
<li>44 (1%) This language excels at symbolic manipulation</li>
<li>34 (1%) This language has many features which feel "tacked on"</li>
<li>52 (1%) This language has a niche in which it is great</li>
<li class="supNeg">6 (1%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">1 (1%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">23 (1%) I usually use this language on solo projects</li>
<li>60 (1%) Developers who primarily use this language often burn out after a few years</li>
<li>74 (1%) The semantics of this language are much different than other languages I know.</li>
<li>45 (1%) It's unusual for me to discover unfamiliar features</li>
<li>53 (2%) This language encourages writing reusable code.</li>
<li>57 (2%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>34 (2%) I am reluctant to admit to knowing this language</li>
<li class="supNeg">17 (2%) This language is good for distributed computing</li>
<li class="supNeg">15 (2%) This is a mainstream language</li>
<li>49 (2%) I often get angry when writing code in this language</li>
<li>61 (2%) Learning this language improved my ability as a programmer</li>
<li class="supNeg">8 (2%) It is easy to tell at a glance what code in this language does</li>
<li>40 (2%) The resources for learning this language are of high quality</li>
<li>45 (3%) This language matches it's problem domain particularly well.</li>
<li>27 (3%) I would use this language for a desktop GUI project</li>
<li class="supNeg">22 (3%) This language excels at concurrency</li>
<li class="supNeg">16 (3%) There are many good open-source tools for this language</li>
<li>34 (3%) This language is well documented</li>
<li>27 (3%) I would use this language for a web project</li>
<li class="supNeg">22 (3%) There are many good tools for this language</li>
<li>38 (3%) There are many good commercial tools for this language</li>
<li class="supNeg">3 (3%) I can imagine using this language in my day job</li>
<li>50 (3%) There is a lot of accidental complexity when writing code in this language</li>
<li>49 (3%) I would use this language for casual scripting</li>
<li class="supNeg">21 (3%) This language is best for very large projects</li>
<li class="supNeg">16 (4%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li class="supNeg">9 (4%) This language has a strong static type system</li>
<li class="supNeg">22 (4%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>25 (4%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">18 (5%) There is a wide variety of open source code written in this language</li>
<li>56 (5%) This language is expressive</li>
<li class="supNeg">14 (5%) It is easy to debug programs written in this language when it goes wrong</li>
<li>32 (5%) Writing code in this language is a lot of work</li>
<li>35 (5%) Code written in this language tends to be very reliable</li>
<li>34 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>37 (6%) This language has a good community</li>
<li>43 (6%) I know this language well</li>
<li class="supNeg">11 (6%) Code written in this language tends to be verbose</li>
<li>49 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li>28 (6%) I would use this language to write a command-line app</li>
<li>42 (6%) This language has a very dogmatic community</li>
<li>43 (6%) This language is likely to have a strong influence on future languages</li>
<li>30 (6%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supNeg">22 (6%) This language has a good library distribution mechanism.</li>
<li>41 (6%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>65 (6%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supPos">78 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supPos">77 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>41 (7%) This language has a very rigid idea of how things should be done</li>
<li class="supNeg">22 (7%) I still discover new features of this language on a fairly regular basis</li>
<li class="supNeg">20 (7%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>33 (8%) I regularly use this language</li>
<li>47 (8%) This language has a high quality implementation</li>
<li>61 (8%) I find code written in this language very elegant</li>
<li>37 (9%) I enjoy using this language</li>
<li>60 (9%) This language makes it easy to shoot yourself in the foot</li>
<li>44 (9%) I would like to write more of this language than I currently do</li>
<li class="supNeg">13 (9%) This language excels at text processing</li>
<li>57 (9%) This language has an annoying syntax</li>
<li>55 (9%) Learning this language significantly changed how I use other languages.</li>
</ul>
<ul>
<li class="supNeg">23 (0%) This language is likely to have a strong influence on future languages</li>
<li>54 (0%) Code written in this language is very readable</li>
<li class="supNeg">21 (0%) I usually use this language on projects with many other members</li>
<li class="supNeg">12 (0%) This language is good for distributed computing</li>
<li>69 (0%) I would use this language for casual scripting</li>
<li>31 (0%) There are many good open-source tools for this language</li>
<li>38 (1%) Code written in this language tends to be terse</li>
<li>73 (1%) I enjoy playing with this language but would never use it for "real code"</li>
<li>58 (1%) I know this language well</li>
<li>33 (1%) This is a low level language</li>
<li>41 (1%) This is a mainstream language</li>
<li class="supNeg">17 (2%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>30 (2%) I would use this language for writing programs for an embedded hardware platform</li>
<li>51 (2%) This language has many features which feel "tacked on"</li>
<li>47 (2%) This language would be good for teaching children to write software</li>
<li>31 (2%) This language is built on a small core of orthogonal features</li>
<li>43 (2%) The resources for learning this language are of high quality</li>
<li>32 (2%) There are many good tools for this language</li>
<li>56 (2%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>25 (3%) This language has a very rigid idea of how things should be done</li>
<li>30 (3%) Learning this language significantly changed how I use other languages.</li>
<li>34 (3%) Writing code in this language is a lot of work</li>
<li>42 (3%) The semantics of this language are much different than other languages I know.</li>
<li>51 (3%) This language is likely to be around for a very long time</li>
<li>47 (3%) I would use this language for a web project</li>
<li class="supNeg">16 (4%) I would list this language on my resume</li>
<li class="supNeg">14 (4%) Programs written in this language tend to be efficient</li>
<li>41 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">23 (4%) This language excels at concurrency</li>
<li>25 (4%) This language is good for beginners</li>
<li>42 (4%) I usually use this language on solo projects</li>
<li>31 (4%) This language has a good community</li>
<li class="supNeg">22 (4%) When I write code in this language I can be very sure it is correct</li>
<li>57 (5%) Programs written in this language tend to play well with others</li>
<li>46 (5%) This language encourages writing reusable code.</li>
<li>61 (5%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">11 (5%) It's unusual for me to discover unfamiliar features</li>
<li>50 (6%) This language makes it easy to shoot yourself in the foot</li>
<li>60 (6%) This language is well suited for an agile development approach using short iterations.</li>
<li>27 (6%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">20 (6%) I would use this language for writing server programs</li>
<li>52 (6%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>47 (6%) This language is well documented</li>
<li>68 (7%) This language has an annoying syntax</li>
<li>65 (7%) I am reluctant to admit to knowing this language</li>
<li>36 (8%) I would like to write more of this language than I currently do</li>
<li>38 (8%) This language has a very dogmatic community</li>
<li>26 (8%) I can imagine using this language in my day job</li>
<li>25 (8%) I know many other people who use this language</li>
<li>51 (8%) I use many applications written in this language</li>
<li class="supNeg">24 (8%) This language has a strong static type system</li>
<li class="supNeg">18 (8%) This language has unusual features that I often miss when using other languages</li>
<li>38 (8%) This language has a good library distribution mechanism.</li>
<li>37 (8%) Code written in this language tends to be very reliable</li>
<li class="supNeg">8 (8%) I still discover new features of this language on a fairly regular basis</li>
<li>45 (9%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>25 (9%) This language has a niche in which it is great</li>
<li>56 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li>28 (9%) Libraries in this language tend to be well documented.</li>
</ul>
<ul></ul>
<ul>
<li class="supPos">97 (1%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>54 (1%) I can imagine this will be a popular language in twenty years time</li>
<li>38 (2%) I would like to write more of this language than I currently do</li>
<li class="supNeg">3 (2%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">92 (2%) This language has a high quality implementation</li>
<li class="supNeg">22 (3%) This language excels at concurrency</li>
<li class="supPos">96 (3%) Programs written in this language will usually work in future versions of the language</li>
<li>31 (4%) I enjoy playing with this language but would never use it for "real code"</li>
<li>29 (4%) I find code written in this language very elegant</li>
<li>59 (4%) This language has a strong static type system</li>
<li>58 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li class="supPos">81 (5%) The resources for learning this language are of high quality</li>
<li class="supPos">94 (5%) There is a wide variety of open source code written in this language</li>
<li>42 (5%) I would use this language for casual scripting</li>
<li class="supPos">92 (5%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>30 (5%) This language excels at symbolic manipulation</li>
<li>34 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supPos">79 (5%) I know this language well</li>
<li>48 (6%) Code written in this language is very readable</li>
<li class="supPos">91 (6%) This is a mainstream language</li>
<li class="supPos">90 (6%) There are many good commercial tools for this language</li>
<li class="supPos">92 (6%) I use many applications written in this language</li>
<li>37 (7%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supPos">83 (7%) This language is frequently used for applications it isn't suitable for</li>
<li class="supPos">90 (7%) I know many other people who use this language</li>
<li>67 (7%) This language is good for numeric computing</li>
<li>52 (7%) This language has a good library distribution mechanism.</li>
<li>61 (8%) I often get angry when writing code in this language</li>
<li class="supPos">92 (8%) I find it easy to write efficient code in this language</li>
<li class="supPos">88 (8%) There are many good open-source tools for this language</li>
<li>63 (9%) This language is good for scientific computing</li>
<li>54 (9%) This is a high level language</li>
<li>56 (9%) Writing code in this language is a lot of work</li>
<li class="supNeg">24 (9%) This language has a niche outside of which I would not use it</li>
<li>26 (9%) I would use this language as a scripting language embedded inside a larger application</li>
</ul>
<ul>
<li>55 (6%) This language is good for scientific computing</li>
<li>42 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>36 (6%) This language excels at text processing</li>
<li>64 (6%) I use this language out of choice</li>
<li class="supPos">82 (7%) This language encourages writing reusable code.</li>
<li>39 (7%) I would use this language for a web project</li>
<li>27 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li>31 (7%) There are many good open-source tools for this language</li>
<li>47 (8%) This language is very flexible</li>
<li>41 (8%) Learning this language significantly changed how I use other languages.</li>
<li>68 (8%) This is a high level language</li>
<li>40 (8%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>53 (8%) This language has a very dogmatic community</li>
<li>37 (9%) I enjoy using this language</li>
<li>47 (9%) This language matches it's problem domain particularly well.</li>
<li>45 (9%) I would use this language for writing server programs</li>
<li>43 (9%) This language would be good for teaching children to write software</li>
<li>27 (9%) There is a wide variety of open source code written in this language</li>
<li>43 (9%) I would use this language for casual scripting</li>
<li>54 (9%) This language is likely to have a strong influence on future languages</li>
<li>59 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">17 (9%) This language has a niche in which it is great</li>
<li>62 (9%) I find this language easy to prototype in</li>
<li>28 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
</ul>
<ul></ul>
<ul></ul>
<ul>
<li class="supPos">80 (2%) This language encourages writing reusable code.</li>
<li>34 (2%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>65 (3%) This language has a very dogmatic community</li>
<li class="supPos">84 (3%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>70 (3%) I know this language well</li>
<li>42 (3%) This language makes it easy to shoot yourself in the foot</li>
<li>39 (4%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>43 (4%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li>48 (4%) I would like to write more of this language than I currently do</li>
<li>47 (4%) I enjoy using this language</li>
<li>65 (4%) I still discover new features of this language on a fairly regular basis</li>
<li class="supPos">92 (5%) The resources for learning this language are of high quality</li>
<li class="supPos">78 (5%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">18 (5%) I often feel like I am not smart enough to write this language</li>
<li>40 (5%) This language is suitable for real-time applications</li>
<li>71 (5%) I use many applications written in this language</li>
<li>48 (5%) Learning this language significantly changed how I use other languages.</li>
<li>41 (5%) This language is good for distributed computing</li>
<li>62 (5%) I usually use this language on solo projects</li>
<li>31 (5%) When I write code in this language I can be very sure it is correct</li>
<li>66 (5%) This language has many features which feel "tacked on"</li>
<li>41 (5%) This language matches it's problem domain particularly well.</li>
<li>44 (6%) Code written in this language tends to be terse</li>
<li>66 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>29 (6%) This language has an annoying syntax</li>
<li>67 (6%) I would use this language for writing server programs</li>
<li>30 (6%) I would use this language for writing programs for an embedded hardware platform</li>
<li class="supPos">90 (6%) I find this language easy to prototype in</li>
<li>73 (6%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>57 (6%) I regularly use this language</li>
<li class="supPos">77 (6%) I would list this language on my resume</li>
<li>73 (6%) Programs written in this language tend to play well with others</li>
<li class="supNeg">20 (6%) This language has a very rigid idea of how things should be done</li>
<li>51 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li>66 (7%) I usually use this language on projects with many other members</li>
<li class="supPos">90 (7%) I would use this language for a web project</li>
<li>30 (7%) I would use this language for writing embedded programs</li>
<li>27 (7%) This is a low level language</li>
<li class="supPos">77 (7%) This language encourages writing code that is easy to maintain.</li>
<li class="supPos">86 (7%) This language is well documented</li>
<li>29 (7%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>30 (8%) This language excels at concurrency</li>
<li>28 (8%) This language is built on a small core of orthogonal features</li>
<li>59 (8%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>53 (8%) This language excels at symbolic manipulation</li>
<li class="supPos">77 (8%) This is a high level language</li>
<li>61 (8%) This language is likely to have a strong influence on future languages</li>
<li>46 (8%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">23 (9%) The semantics of this language are much different than other languages I know.</li>
<li class="supPos">79 (9%) This is a mainstream language</li>
<li class="supPos">89 (9%) I would use this language to write a command-line app</li>
<li>59 (9%) This language has a very coherent design</li>
<li class="supPos">86 (9%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>33 (9%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li class="supPos">83 (9%) I would use this language for a desktop GUI project</li>
<li>34 (9%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supPos">82 (9%) Libraries in this language tend to be well documented.</li>
</ul>
<ul>
<li>40 (0%) This language is likely to have a strong influence on future languages</li>
<li class="supPos">79 (0%) This is a high level language</li>
<li>55 (0%) I usually use this language on solo projects</li>
<li>56 (0%) This language is expressive</li>
<li>55 (0%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">24 (0%) This is a low level language</li>
<li>47 (0%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>40 (0%) This language is suitable for real-time applications</li>
<li>40 (0%) I regularly use this language</li>
<li>41 (0%) I am reluctant to admit to knowing this language</li>
<li>31 (0%) This language has a very rigid idea of how things should be done</li>
<li>43 (0%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>50 (0%) The thought that I may still be using this language in twenty years time fills me with dread</li>
<li>74 (0%) I would use this language for casual scripting</li>
<li>46 (1%) This language is large</li>
<li>60 (1%) I would use this language for a desktop GUI project</li>
<li class="supNeg">19 (1%) I often feel like I am not smart enough to write this language</li>
<li>58 (1%) I find code written in this language very elegant</li>
<li>72 (1%) I would use this language for a web project</li>
<li>42 (1%) This language has unusual features that I often miss when using other languages</li>
<li>48 (1%) I would use this language for writing server programs</li>
<li>43 (1%) I would list this language on my resume</li>
<li>58 (1%) This language would be good for teaching children to write software</li>
<li>48 (1%) This language is best for very small projects</li>
<li>67 (2%) This language has a good community</li>
<li>55 (2%) This language excels at text processing</li>
<li>74 (2%) This language encourages writing code that is easy to maintain.</li>
<li>44 (2%) I can imagine using this language in my day job</li>
<li>42 (2%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>52 (2%) I would like to write more of this language than I currently do</li>
<li>29 (2%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>32 (2%) Programs written in this language tend to be efficient</li>
<li>42 (2%) It is easy to debug programs written in this language when it goes wrong</li>
<li>47 (2%) This language is best for very large projects</li>
<li>73 (2%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>40 (3%) I use many applications written in this language</li>
<li>30 (3%) This language excels at concurrency</li>
<li class="supPos">90 (3%) I find this language easy to prototype in</li>
<li>66 (3%) This language has a good library distribution mechanism.</li>
<li>42 (3%) This language has a niche outside of which I would not use it</li>
<li>34 (3%) This language is good for scientific computing</li>
<li class="supNeg">13 (3%) I learned this language early in my career as a programmer</li>
<li class="supNeg">20 (4%) Writing code in this language is a lot of work</li>
<li>33 (4%) This language is minimal</li>
<li>32 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>55 (4%) There are many good open-source tools for this language</li>
<li>32 (4%) This language has an annoying syntax</li>
<li>39 (4%) Code written in this language tends to be terse</li>
<li>34 (4%) This language is likely to be around for a very long time</li>
<li>53 (4%) Programs written in this language will usually work in future versions of the language</li>
<li>48 (4%) This language is unusually bad for beginners</li>
<li>70 (4%) This language is well suited for an agile development approach using short iterations.</li>
<li>43 (5%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>39 (5%) I enjoy using this language</li>
<li>40 (5%) This is a mainstream language</li>
<li>44 (5%) This language has a very coherent design</li>
<li>66 (5%) This language has many features which feel "tacked on"</li>
<li>37 (5%) Learning this language improved my ability as a programmer</li>
<li>43 (5%) It's unusual for me to discover unfamiliar features</li>
<li>41 (5%) This language is good for numeric computing</li>
<li class="supNeg">21 (5%) When I write code in this language I can be very sure it is correct</li>
<li>66 (6%) I use this language out of choice</li>
<li>46 (6%) Libraries in this language tend to be well documented.</li>
<li class="supPos">76 (6%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>52 (6%) There are many good tools for this language</li>
<li>45 (6%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>54 (7%) I enjoy playing with this language but would never use it for "real code"</li>
<li>55 (7%) Programs written in this language tend to play well with others</li>
<li>45 (7%) Code written in this language tends to be verbose</li>
<li>45 (7%) This language is frequently used for applications it isn't suitable for</li>
<li>30 (7%) Learning this language significantly changed how I use other languages.</li>
<li>28 (7%) I would use this language for writing embedded programs</li>
<li>45 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>52 (7%) I would use this language as a scripting language embedded inside a larger application</li>
<li>71 (8%) Code written in this language is very readable</li>
<li>46 (8%) Code written in this language tends to be very reliable</li>
<li>59 (8%) The resources for learning this language are of high quality</li>
<li>32 (8%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">22 (8%) I would use this language for writing programs for an embedded hardware platform</li>
<li>40 (9%) This language is good for beginners</li>
<li>39 (9%) This language has a strong static type system</li>
<li>60 (9%) It is easy to tell at a glance what code in this language does</li>
<li>45 (9%) This language matches it's problem domain particularly well.</li>
<li class="supNeg">21 (9%) The semantics of this language are much different than other languages I know.</li>
<li>56 (9%) I rarely have difficulty abstracting patterns I find in my code</li>
</ul>
<ul></ul>
<ul></ul>
<ul>
<li>36 (0%) Writing code in this language is a lot of work</li>
<li>55 (1%) It's unusual for me to discover unfamiliar features</li>
<li>26 (1%) There is a wide variety of open source code written in this language</li>
<li>42 (1%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supNeg">8 (1%) I can imagine this will be a popular language in twenty years time</li>
<li class="supNeg">18 (1%) The semantics of this language are much different than other languages I know.</li>
<li>35 (1%) I usually use this language on projects with many other members</li>
<li>44 (1%) This language is unusually bad for beginners</li>
<li>68 (1%) This language has an annoying syntax</li>
<li class="supNeg">18 (1%) I usually use this language on solo projects</li>
<li>55 (2%) Code written in this language is very readable</li>
<li>62 (2%) I find this language easy to prototype in</li>
<li class="supNeg">19 (2%) I would use this language as a scripting language embedded inside a larger application</li>
<li>41 (2%) This language has a high quality implementation</li>
<li class="supNeg">15 (2%) I would use this language for writing server programs</li>
<li class="supNeg">3 (3%) I still discover new features of this language on a fairly regular basis</li>
<li>55 (3%) This language encourages writing code that is easy to maintain.</li>
<li>31 (3%) I would use this language for mobile applications</li>
<li>55 (3%) I know this language well</li>
<li>70 (3%) Code written in this language tends to be verbose</li>
<li>47 (3%) This language makes it easy to shoot yourself in the foot</li>
<li class="supNeg">9 (4%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">10 (4%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">22 (4%) This language excels at symbolic manipulation</li>
<li class="supNeg">7 (4%) This language has a niche in which it is great</li>
<li>31 (4%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>52 (4%) This language is good for beginners</li>
<li>28 (5%) I would use this language for a web project</li>
<li>43 (5%) This language is large</li>
<li class="supNeg">15 (5%) This language is good for distributed computing</li>
<li>44 (5%) There are many good tools for this language</li>
<li>32 (5%) This language is expressive</li>
<li>27 (6%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>54 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>50 (6%) Libraries in this language tend to be well documented.</li>
<li class="supNeg">15 (6%) This language is very flexible</li>
<li>55 (6%) This language has a niche outside of which I would not use it</li>
<li>67 (6%) This language would be good for teaching children to write software</li>
<li class="supNeg">22 (6%) This language is best for very small projects</li>
<li>38 (6%) This language has a very dogmatic community</li>
<li>44 (6%) This is a low level language</li>
<li>36 (6%) This language is likely to be around for a very long time</li>
<li>39 (6%) I use many applications written in this language</li>
<li class="supNeg">11 (7%) I enjoy using this language</li>
<li class="supNeg">21 (7%) I regularly use this language</li>
<li class="supNeg">23 (7%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>42 (7%) This language has a good library distribution mechanism.</li>
<li class="supNeg">17 (7%) There are many good open-source tools for this language</li>
<li>50 (7%) This is a mainstream language</li>
<li class="supNeg">15 (7%) I would use this language for writing programs for an embedded hardware platform</li>
<li>61 (7%) This is a high level language</li>
<li>47 (7%) I know many other people who use this language</li>
<li>30 (8%) I would use this language for writing embedded programs</li>
<li class="supNeg">21 (8%) Code written in this language tends to be terse</li>
<li>46 (8%) This language encourages writing reusable code.</li>
<li>40 (8%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">11 (8%) I can imagine using this language in my day job</li>
<li>42 (8%) I would use this language to write a command-line app</li>
<li>54 (8%) It is easy to debug programs written in this language when it goes wrong</li>
<li>39 (8%) This language is best for very large projects</li>
<li>34 (8%) I would use this language for casual scripting</li>
<li>42 (8%) Third-party libraries are readily available  well-documented  and of high quality</li>
<li>28 (8%) This language excels at text processing</li>
<li class="supNeg">23 (9%) This language is likely to have a strong influence on future languages</li>
<li>51 (9%) It is easy to tell at a glance what code in this language does</li>
<li>48 (9%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li>42 (9%) Programs written in this language tend to play well with others</li>
<li class="supNeg">24 (9%) This language excels at concurrency</li>
<li class="supNeg">13 (9%) This language matches it's problem domain particularly well.</li>
</ul>
<ul>
<li>72 (2%) This language has a very coherent design</li>
<li>71 (3%) This language has a high quality implementation</li>
<li>41 (4%) This language is good for beginners</li>
<li>36 (4%) I would use this language for writing programs for an embedded hardware platform</li>
<li>39 (4%) This is a mainstream language</li>
<li class="supPos">86 (4%) This is a high level language</li>
<li>30 (4%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li class="supNeg">22 (5%) This is a low level language</li>
<li>39 (5%) I use many applications written in this language</li>
<li class="supNeg">19 (5%) There is a lot of accidental complexity when writing code in this language</li>
<li>31 (5%) This language is frequently used for applications it isn't suitable for</li>
<li>40 (6%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li>73 (6%) I find code written in this language very elegant</li>
<li class="supNeg">23 (6%) Writing code in this language is a lot of work</li>
<li>52 (6%) This language is unusually bad for beginners</li>
<li class="supPos">77 (6%) This language is likely to have a strong influence on future languages</li>
<li>51 (6%) I often feel like I am not smart enough to write this language</li>
<li>53 (7%) Code written in this language tends to be terse</li>
<li>34 (7%) This language has a very rigid idea of how things should be done</li>
<li>69 (7%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supPos">89 (7%) This language encourages writing reusable code.</li>
<li>49 (7%) This language is likely to be around for a very long time</li>
<li>57 (7%) This language has a good library distribution mechanism.</li>
<li>42 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>45 (7%) I regularly use this language</li>
<li>27 (7%) I often get angry when writing code in this language</li>
<li>30 (7%) This language makes it easy to shoot yourself in the foot</li>
<li>64 (7%) Code written in this language is very readable</li>
<li>73 (7%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">11 (8%) I am sometimes embarrassed to admit to my peers that I know this language</li>
<li>60 (8%) Learning this language significantly changed how I use other languages.</li>
<li>26 (8%) Code written in this language tends to be verbose</li>
<li>38 (8%) I know many other people who use this language</li>
<li>50 (8%) This language has many features which feel "tacked on"</li>
<li>64 (8%) I would use this language for casual scripting</li>
<li>50 (8%) Libraries in this language tend to be well documented.</li>
<li>59 (8%) Programs written in this language tend to play well with others</li>
<li class="supPos">84 (8%) I find this language easy to prototype in</li>
<li>54 (8%) There are many good tools for this language</li>
<li>60 (8%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>39 (8%) When I write code in this language I can be very sure it is correct</li>
<li>39 (9%) I usually use this language on projects with many other members</li>
<li class="supPos">75 (9%) This language encourages writing code that is easy to maintain.</li>
<li>61 (9%) This language is suitable for real-time applications</li>
<li>42 (9%) There is a wide variety of open source code written in this language</li>
<li>63 (9%) I enjoy playing with this language but would never use it for "real code"</li>
<li>49 (9%) There are many good commercial tools for this language</li>
</ul>
<ul>
<li class="supNeg">8 (0%) I would use this language as a scripting language embedded inside a larger application</li>
<li class="supNeg">21 (0%) Libraries in this language tend to be well documented.</li>
<li class="supPos">76 (0%) This language is unusually bad for beginners</li>
<li>30 (0%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li class="supNeg">16 (0%) Learning this language significantly changed how I use other languages.</li>
<li>44 (0%) This language has a very coherent design</li>
<li>48 (0%) This language makes it easy to shoot yourself in the foot</li>
<li>36 (0%) The resources for learning this language are of high quality</li>
<li>42 (0%) This language has a strong static type system</li>
<li class="supPos">80 (0%) I learned this language early in my career as a programmer</li>
<li>68 (0%) This language is likely to be around for a very long time</li>
<li class="supNeg">8 (1%) I can imagine using this language in my day job</li>
<li>29 (1%) I know many other people who use this language</li>
<li class="supNeg">12 (1%) This language is likely to have a strong influence on future languages</li>
<li>73 (1%) I often get angry when writing code in this language</li>
<li class="supNeg">15 (1%) I can imagine this will be a popular language in twenty years time</li>
<li>58 (1%) This language has many features which feel "tacked on"</li>
<li class="supNeg">11 (2%) This language is expressive</li>
<li>35 (2%) This language is best for very large projects</li>
<li>53 (2%) There are many good commercial tools for this language</li>
<li class="supNeg">12 (2%) This language excels at symbolic manipulation</li>
<li>35 (2%) There are many good tools for this language</li>
<li>30 (2%) If this language didn't exist  I would have trouble finding a satisfactory replacement</li>
<li class="supNeg">13 (2%) I still discover new features of this language on a fairly regular basis</li>
<li>37 (2%) This language has a very dogmatic community</li>
<li>30 (2%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>41 (2%) This language encourages writing code that is easy to maintain.</li>
<li>70 (2%) Programs written in this language will usually work in future versions of the language</li>
<li>61 (2%) Writing code in this language is a lot of work</li>
<li>40 (3%) This language matches it's problem domain particularly well.</li>
<li class="supNeg">3 (3%) I enjoy using this language</li>
<li class="supNeg">5 (3%) I regularly use this language</li>
<li class="supNeg">15 (3%) I would use this language for a desktop GUI project</li>
<li>28 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li class="supNeg">14 (3%) This language would be good for teaching children to write software</li>
<li>50 (3%) It is easy to tell at a glance what code in this language does</li>
<li>52 (3%) This language is frequently used for applications it isn't suitable for</li>
<li>66 (3%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>48 (4%) This is a high level language</li>
<li class="supNeg">7 (4%) This language excels at text processing</li>
<li>31 (4%) I find this language easy to prototype in</li>
<li>29 (4%) I use many applications written in this language</li>
<li>44 (4%) This is a mainstream language</li>
<li class="supNeg">4 (4%) I would use this language for mobile applications</li>
<li>66 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li class="supNeg">10 (5%) I would use this language for writing server programs</li>
<li>52 (6%) Code written in this language is very readable</li>
<li>37 (6%) The semantics of this language are much different than other languages I know.</li>
<li class="supNeg">6 (6%) I often write things in this language with the intent of rewriting them in something else later</li>
<li class="supNeg">19 (6%) I rarely have difficulty abstracting patterns I find in my code</li>
<li>31 (6%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">19 (6%) This language is likely to be a passing fad</li>
<li>31 (6%) I would list this language on my resume</li>
<li class="supNeg">23 (6%) I often feel like I am not smart enough to write this language</li>
<li class="supNeg">13 (6%) When I write code in this language I can be very sure it is correct</li>
<li>53 (6%) This language has a high quality implementation</li>
<li class="supNeg">12 (7%) This language is very flexible</li>
<li class="supNeg">20 (7%) I would use this language for casual scripting</li>
<li>36 (7%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supNeg">7 (7%) I usually use this language on solo projects</li>
<li>51 (7%) There is a lot of accidental complexity when writing code in this language</li>
<li class="supNeg">24 (7%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li class="supNeg">7 (7%) This language has unusual features that I often miss when using other languages</li>
<li class="supNeg">8 (8%) I would recommend most programmers learn this language  regardless of whether they have a specific need for it</li>
<li>72 (8%) Developers who primarily use this language often burn out after a few years</li>
<li class="supNeg">8 (8%) This language is best for very small projects</li>
<li>36 (8%) When I run into problems my colleagues can provide me with immediate help with this language</li>
<li class="supNeg">20 (8%) I usually use this language on projects with many other members</li>
<li class="supNeg">13 (8%) This language is built on a small core of orthogonal features</li>
<li>40 (8%) This language is suitable for real-time applications</li>
<li>45 (8%) This is a low level language</li>
<li class="supNeg">23 (8%) This language has a niche in which it is great</li>
<li class="supPos">80 (8%) This language has a niche outside of which I would not use it</li>
<li class="supNeg">16 (9%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">21 (9%) It is easy to debug programs written in this language when it goes wrong</li>
<li>57 (9%) I know this language well</li>
<li class="supNeg">24 (9%) This language encourages writing reusable code.</li>
<li>30 (9%) This language has a good library distribution mechanism.</li>
</ul>
<ul>
<li>35 (0%) This language is easier to use for it's problem domain by removing unneeded expressiveness (such as not being Turing complete).</li>
<li>56 (1%) I often write things in this language with the intent of rewriting them in something else later</li>
<li>66 (1%) This language has a good community</li>
<li class="supPos">81 (1%) There is a wide variety of open source code written in this language</li>
<li class="supNeg">11 (2%) This language has a strong static type system</li>
<li class="supNeg">24 (2%) This language excels at concurrency</li>
<li>37 (2%) It is easy to debug programs written in this language when it goes wrong</li>
<li>29 (2%) This language is suitable for real-time applications</li>
<li class="supNeg">21 (2%) This language allows me to write programs where I know exactly what they are doing under the hood</li>
<li>32 (3%) This is a low level language</li>
<li class="supNeg">20 (3%) If my code in this language successfully compiles  there is a good chance my code is correct.</li>
<li>32 (3%) This language has a wide variety of agreed-upon conventions  which are generally adhered to reasonably well  and which increase my productivity</li>
<li>43 (3%) This language matches it's problem domain particularly well.</li>
<li>60 (3%) There are many good tools for this language</li>
<li>27 (3%) This language is best for very large projects</li>
<li>46 (3%) This language would be good for teaching children to write software</li>
<li class="supNeg">12 (3%) When I write code in this language I can be very sure it is correct</li>
<li>45 (4%) Code written in this language will usually run in all the major implementations if it runs in one of them.</li>
<li>69 (4%) There are many good open-source tools for this language</li>
<li>61 (4%) This language makes it easy to shoot yourself in the foot</li>
<li>69 (5%) This is a high level language</li>
<li>53 (5%) I enjoy playing with this language but would never use it for "real code"</li>
<li>73 (5%) I would use this language for a web project</li>
<li>59 (5%) This language is well suited for an agile development approach using short iterations.</li>
<li class="supNeg">15 (5%) Code written in this language tends to be very reliable</li>
<li>44 (5%) This language encourages writing code that is easy to maintain.</li>
<li>48 (5%) This language is likely to be a passing fad</li>
<li class="supNeg">15 (6%) I would use this language for writing embedded programs</li>
<li>33 (6%) This language has a niche in which it is great</li>
<li class="supNeg">19 (6%) This language is good for distributed computing</li>
<li>51 (6%) This language has well-organized libraries with consistent  carefully thought-out interfaces</li>
<li class="supPos">87 (6%) I use a lot of code written in this language which I really don't want to have to make changes to</li>
<li>43 (6%) I find it easy to write efficient code in this language</li>
<li>52 (6%) I learned this language early in my career as a programmer</li>
<li>72 (6%) This language is frequently used for applications it isn't suitable for</li>
<li>42 (7%) This language encourages writing reusable code.</li>
<li>56 (7%) I rarely have difficulty abstracting patterns I find in my code</li>
<li class="supPos">76 (7%) I find this language easy to prototype in</li>
<li class="supPos">85 (7%) It is too easy to write code in this language that looks like it does one thing but actually does something else</li>
<li class="supNeg">23 (7%) This language is good for numeric computing</li>
<li class="supPos">78 (7%) This is a mainstream language</li>
<li>52 (7%) Libraries in this language tend to be well documented.</li>
<li>61 (7%) The resources for learning this language are of high quality</li>
<li>71 (7%) I use many applications written in this language</li>
<li>60 (8%) I would list this language on my resume</li>
<li>57 (8%) There are many good commercial tools for this language</li>
<li>51 (8%) I use this language out of choice</li>
<li class="supPos">82 (8%) I know many other people who use this language</li>
<li>42 (8%) This language has a very dogmatic community</li>
<li>48 (9%) Code written in this language tends to be verbose</li>
<li>63 (9%) There is a lot of accidental complexity when writing code in this language</li>
<li>49 (9%) I usually use this language on solo projects</li>
<li>67 (9%) I often get angry when writing code in this language</li>
<li>25 (9%) I can imagine using this language in my day job</li>
<li class="supNeg">22 (9%) This language has a very rigid idea of how things should be done</li>
<li>45 (9%) This language is good for beginners</li>
</ul>
<ul></ul>
<ul></ul>
</div>



</div>


</body>
</html>